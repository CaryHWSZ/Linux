###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     28/Dec/2014  20:59:03 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_mbox.c                                 #
#    Command line =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_mbox.c -lCN                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\ -o   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\       #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "F:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\S #
#                    oftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\ -I      #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\BSP\ -I       #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\C #
#                    PU\ST\STM32\inc\ -I C:\Users\Administrator\Desktop\uCOS- #
#                    II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe- #
#                    LCD\..\..\..\..\..\uC-CPU\ -I                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-CPU\ARM-Cortex-M3\IAR\ -I                              #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-LCD\Source\ -I C:\Users\Administrator\Desktop\uCOS-II\ #
#                    Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD #
#                    \..\..\..\..\..\uC-LIB\ -I C:\Users\Administrator\Deskto #
#                    p\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS #
#                    -Probe-LCD\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Ge #
#                    neric\IAR\ -I C:\Users\Administrator\Desktop\uCOS-II\Mic #
#                    rium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\.. #
#                    \..\..\..\..\uCOS-II\Source\ -I                          #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM #
#                    32\ -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\So #
#                    ftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\ #
#                    ..\..\uC-Probe\Target\Communication\Generic\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Plugins\uCOS-II\ -I "F:\Program Files     #
#                    (x86)\IAR Systems\Embedded Workbench 5.4\arm\INC\" -Om   #
#    List file    =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\os_mb #
#                    ox.lst                                                   #
#    Object file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\os_mbo #
#                    x.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\uCOS-II\Source\os_mbox.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                       MESSAGE MAILBOX MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MBOX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if OS_MBOX_EN > 0
     29          /*
     30          *********************************************************************************************************
     31          *                                     ACCEPT MESSAGE FROM MAILBOX
     32          *
     33          * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
     34          *              OSMboxAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
     39          *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
     40          *              == (void *)0  if the mailbox is empty or,
     41          *                            if 'pevent' is a NULL pointer or,
     42          *                            if you didn't pass the proper event pointer.
     43          *********************************************************************************************************
     44          */
     45          
     46          #if OS_MBOX_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     47          void  *OSMboxAccept (OS_EVENT *pevent)
     48          {
   \                     OSMboxAccept:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
     49              void      *pmsg;
     50          #if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
     51              OS_CPU_SR  cpu_sr = 0;
     52          #endif
     53          
     54          
     55          
     56          #if OS_ARG_CHK_EN > 0
     57              if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
   \   00000004   01D1               BNE.N    ??OSMboxAccept_0
     58                  return ((void *)0);
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   32BD               POP      {R1,R4,R5,PC}
     59              }
     60          #endif
     61              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
   \                     ??OSMboxAccept_0:
   \   0000000A   2078               LDRB     R0,[R4, #+0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   01D0               BEQ.N    ??OSMboxAccept_1
     62                  return ((void *)0);
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   32BD               POP      {R1,R4,R5,PC}
     63              }
     64              OS_ENTER_CRITICAL();
   \                     ??OSMboxAccept_1:
   \   00000014   ........           BL       OS_CPU_SR_Save
     65              pmsg               = pevent->OSEventPtr;
   \   00000018   6568               LDR      R5,[R4, #+4]
     66              pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   6160               STR      R1,[R4, #+4]
     67              OS_EXIT_CRITICAL();
   \   0000001E   ........           BL       OS_CPU_SR_Restore
     68              return (pmsg);                                        /* Return the message received (or NULL)     */
   \   00000022   2846               MOV      R0,R5
   \   00000024   32BD               POP      {R1,R4,R5,PC}    ;; return
     69          }
     70          #endif
     71          /*$PAGE*/
     72          /*
     73          *********************************************************************************************************
     74          *                                        CREATE A MESSAGE MAILBOX
     75          *
     76          * Description: This function creates a message mailbox if free event control blocks are available.
     77          *
     78          * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
     79          *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
     80          *                            will be considered empty.
     81          *
     82          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
     83          *                                created mailbox
     84          *              == (OS_EVENT *)0  if no event control blocks were available
     85          *********************************************************************************************************
     86          */
     87          

   \                                 In section .text, align 2, keep-with-next
     88          OS_EVENT  *OSMboxCreate (void *pmsg)
     89          {
   \                     OSMboxCreate:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
     90              OS_EVENT  *pevent;
     91          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
     92              OS_CPU_SR  cpu_sr = 0;
     93          #endif
     94          
     95          
     96          
     97              if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
   \   00000004   ....               LDR.N    R0,??DataTable5  ;; OSIntNesting
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   01D0               BEQ.N    ??OSMboxCreate_0
     98                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   32BD               POP      {R1,R4,R5,PC}
     99              }
    100              OS_ENTER_CRITICAL();
   \                     ??OSMboxCreate_0:
   \   00000010   ........           BL       OS_CPU_SR_Save
    101              pevent = OSEventFreeList;                    /* Get next free event control block                  */
   \   00000014   ....               LDR.N    R1,??DataTable4  ;; OSEventFreeList
   \   00000016   0A68               LDR      R2,[R1, #+0]
   \   00000018   1500               MOVS     R5,R2
    102              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   0000001A   01D0               BEQ.N    ??OSMboxCreate_1
    103                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   0000001C   5268               LDR      R2,[R2, #+4]
   \   0000001E   0A60               STR      R2,[R1, #+0]
    104              }
    105              OS_EXIT_CRITICAL();
   \                     ??OSMboxCreate_1:
   \   00000020   ........           BL       OS_CPU_SR_Restore
    106              if (pevent != (OS_EVENT *)0) {
   \   00000024   002D               CMP      R5,#+0
   \   00000026   0BD0               BEQ.N    ??OSMboxCreate_2
    107                  pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   2870               STRB     R0,[R5, #+0]
    108                  pevent->OSEventCnt     = 0;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   2881               STRH     R0,[R5, #+8]
    109                  pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
   \   00000030   6C60               STR      R4,[R5, #+4]
    110          #if OS_EVENT_NAME_SIZE > 1
    111                  pevent->OSEventName[0] = '?';
   \   00000032   3F20               MOVS     R0,#+63
   \   00000034   E873               STRB     R0,[R5, #+15]
    112                  pevent->OSEventName[1] = OS_ASCII_NUL;
   \   00000036   0020               MOVS     R0,#+0
   \   00000038   2874               STRB     R0,[R5, #+16]
    113          #endif
    114                  OS_EventWaitListInit(pevent);
   \   0000003A   2846               MOV      R0,R5
   \   0000003C   ........           BL       OS_EventWaitListInit
    115              }
    116              return (pevent);                             /* Return pointer to event control block              */
   \                     ??OSMboxCreate_2:
   \   00000040   2846               MOV      R0,R5
   \   00000042   32BD               POP      {R1,R4,R5,PC}    ;; return
    117          }
    118          /*$PAGE*/
    119          /*
    120          *********************************************************************************************************
    121          *                                         DELETE A MAIBOX
    122          *
    123          * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
    124          *
    125          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    126          *                            mailbox.
    127          *
    128          *              opt           determines delete options as follows:
    129          *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
    130          *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
    131          *                                                    In this case, all the tasks pending will be readied.
    132          *
    133          *              perr          is a pointer to an error code that can contain one of the following values:
    134          *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
    135          *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
    136          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    137          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
    138          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
    139          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    140          *
    141          * Returns    : pevent        upon error
    142          *              (OS_EVENT *)0 if the mailbox was successfully deleted.
    143          *
    144          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    145          *                 the mailbox MUST check the return code of OSMboxPend().
    146          *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
    147          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    148          *                 time is directly proportional to the number of tasks waiting on the mailbox.
    149          *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
    150          *                 applications where the mailbox is used for mutual exclusion because the resource(s)
    151          *                 will no longer be guarded by the mailbox.
    152          *********************************************************************************************************
    153          */
    154          
    155          #if OS_MBOX_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    156          OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    157          {
   \                     OSMboxDel:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   8846               MOV      R8,R1
   \   00000008   1500               MOVS     R5,R2
    158              BOOLEAN    tasks_waiting;
    159              OS_EVENT  *pevent_return;
    160          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    161              OS_CPU_SR  cpu_sr = 0;
    162          #endif
    163          
    164          
    165          
    166          #if OS_ARG_CHK_EN > 0
    167              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
   \   0000000A   67D0               BEQ.N    ??OSMboxDel_0
    168                  return (pevent);
    169              }
    170              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
   \   0000000C   002C               CMP      R4,#+0
   \   0000000E   04D1               BNE.N    ??OSMboxDel_1
    171                  *perr = OS_ERR_PEVENT_NULL;
   \   00000010   0420               MOVS     R0,#+4
   \   00000012   2870               STRB     R0,[R5, #+0]
    172                  return (pevent);
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   BDE8F081           POP      {R4-R8,PC}
    173              }
    174          #endif
    175              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \                     ??OSMboxDel_1:
   \   0000001A   2078               LDRB     R0,[R4, #+0]
   \   0000001C   0128               CMP      R0,#+1
   \   0000001E   04D0               BEQ.N    ??OSMboxDel_2
    176                  *perr = OS_ERR_EVENT_TYPE;
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2870               STRB     R0,[R5, #+0]
    177                  return (pevent);
   \   00000024   2046               MOV      R0,R4
   \   00000026   BDE8F081           POP      {R4-R8,PC}
    178              }
    179              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \                     ??OSMboxDel_2:
   \   0000002A   ....               LDR.N    R0,??DataTable5  ;; OSIntNesting
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   04D0               BEQ.N    ??OSMboxDel_3
    180                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000032   0F20               MOVS     R0,#+15
   \   00000034   2870               STRB     R0,[R5, #+0]
    181                  return (pevent);
   \   00000036   2046               MOV      R0,R4
   \   00000038   BDE8F081           POP      {R4-R8,PC}
    182              }
    183              OS_ENTER_CRITICAL();
   \                     ??OSMboxDel_3:
   \   0000003C   ........           BL       OS_CPU_SR_Save
   \   00000040   0646               MOV      R6,R0
    184              if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
   \   00000042   A07A               LDRB     R0,[R4, #+10]
   \   00000044   471E               SUBS     R7,R0,#+1
   \   00000046   BF41               SBCS     R7,R7,R7
   \   00000048   FF43               MVNS     R7,R7
   \   0000004A   FF0F               LSRS     R7,R7,#+31
    185                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    186              } else {
    187                  tasks_waiting = OS_FALSE;                          /* No                                       */
    188              }
    189              switch (opt) {
   \   0000004C   B8F1000F           CMP      R8,#+0
   \   00000050   03D0               BEQ.N    ??OSMboxDel_4
   \   00000052   B8F1010F           CMP      R8,#+1
   \   00000056   22D0               BEQ.N    ??OSMboxDel_5
   \   00000058   3AE0               B.N      ??OSMboxDel_6
    190                  case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
    191                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMboxDel_4:
   \   0000005A   002F               CMP      R7,#+0
   \   0000005C   11D1               BNE.N    ??OSMboxDel_7
    192          #if OS_EVENT_NAME_SIZE > 1
    193                           pevent->OSEventName[0] = '?';             /* Unknown name                             */
   \   0000005E   3F20               MOVS     R0,#+63
   \   00000060   E073               STRB     R0,[R4, #+15]
    194                           pevent->OSEventName[1] = OS_ASCII_NUL;
   \   00000062   0020               MOVS     R0,#+0
   \   00000064   2074               STRB     R0,[R4, #+16]
    195          #endif
    196                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
   \   00000066   2070               STRB     R0,[R4, #+0]
    197                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
   \   00000068   ....               LDR.N    R0,??DataTable4  ;; OSEventFreeList
   \   0000006A   0168               LDR      R1,[R0, #+0]
   \   0000006C   6160               STR      R1,[R4, #+4]
    198                           pevent->OSEventCnt  = 0;
   \   0000006E   0021               MOVS     R1,#+0
   \   00000070   2181               STRH     R1,[R4, #+8]
    199                           OSEventFreeList     = pevent;             /* Get next free event control block        */
   \   00000072   0460               STR      R4,[R0, #+0]
    200                           OS_EXIT_CRITICAL();
   \   00000074   3046               MOV      R0,R6
   \   00000076   ........           BL       OS_CPU_SR_Restore
    201                           *perr               = OS_ERR_NONE;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   2870               STRB     R0,[R5, #+0]
    202                           pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
   \   0000007E   BDE8F081           POP      {R4-R8,PC}
    203                       } else {
    204                           OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_7:
   \   00000082   3046               MOV      R0,R6
   \   00000084   ........           BL       OS_CPU_SR_Restore
    205                           *perr               = OS_ERR_TASK_WAITING;
   \   00000088   4920               MOVS     R0,#+73
   \   0000008A   2870               STRB     R0,[R5, #+0]
    206                           pevent_return       = pevent;
   \   0000008C   2046               MOV      R0,R4
   \   0000008E   BDE8F081           POP      {R4-R8,PC}
    207                       }
    208                       break;
    209          
    210                  case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
    211                       while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
    212                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxDel_8:
   \   00000092   0023               MOVS     R3,#+0
   \   00000094   0222               MOVS     R2,#+2
   \   00000096   1946               MOV      R1,R3
   \   00000098   2046               MOV      R0,R4
   \   0000009A   ........           BL       OS_EventTaskRdy
    213                       }
   \                     ??OSMboxDel_5:
   \   0000009E   A07A               LDRB     R0,[R4, #+10]
   \   000000A0   0028               CMP      R0,#+0
   \   000000A2   F6D1               BNE.N    ??OSMboxDel_8
    214          #if OS_EVENT_NAME_SIZE > 1
    215                       pevent->OSEventName[0] = '?';                 /* Unknown name                             */
   \   000000A4   3F20               MOVS     R0,#+63
   \   000000A6   E073               STRB     R0,[R4, #+15]
    216                       pevent->OSEventName[1] = OS_ASCII_NUL;
   \   000000A8   0020               MOVS     R0,#+0
   \   000000AA   2074               STRB     R0,[R4, #+16]
    217          #endif
    218                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   000000AC   2070               STRB     R0,[R4, #+0]
    219                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   000000AE   ....               LDR.N    R0,??DataTable4  ;; OSEventFreeList
   \   000000B0   0168               LDR      R1,[R0, #+0]
   \   000000B2   6160               STR      R1,[R4, #+4]
    220                       pevent->OSEventCnt     = 0;
   \   000000B4   0021               MOVS     R1,#+0
   \   000000B6   2181               STRH     R1,[R4, #+8]
    221                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   000000B8   0460               STR      R4,[R0, #+0]
    222                       OS_EXIT_CRITICAL();
   \   000000BA   3046               MOV      R0,R6
   \   000000BC   ........           BL       OS_CPU_SR_Restore
    223                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000C0   012F               CMP      R7,#+1
   \   000000C2   01D1               BNE.N    ??OSMboxDel_9
    224                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000C4   ........           BL       OS_Sched
    225                       }
    226                       *perr         = OS_ERR_NONE;
   \                     ??OSMboxDel_9:
   \   000000C8   0020               MOVS     R0,#+0
   \   000000CA   2870               STRB     R0,[R5, #+0]
    227                       pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
   \   000000CC   BDE8F081           POP      {R4-R8,PC}
    228                       break;
    229          
    230                  default:
    231                       OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_6:
   \   000000D0   3046               MOV      R0,R6
   \   000000D2   ........           BL       OS_CPU_SR_Restore
    232                       *perr         = OS_ERR_INVALID_OPT;
   \   000000D6   0720               MOVS     R0,#+7
   \   000000D8   2870               STRB     R0,[R5, #+0]
    233                       pevent_return = pevent;
   \   000000DA   2046               MOV      R0,R4
    234                       break;
    235              }
    236              return (pevent_return);
   \                     ??OSMboxDel_0:
   \   000000DC   BDE8F081           POP      {R4-R8,PC}       ;; return
    237          }
    238          #endif
    239          
    240          /*$PAGE*/
    241          /*
    242          *********************************************************************************************************
    243          *                                      PEND ON MAILBOX FOR A MESSAGE
    244          *
    245          * Description: This function waits for a message to be sent to a mailbox
    246          *
    247          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    248          *
    249          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    250          *                            wait for a message to arrive at the mailbox up to the amount of time
    251          *                            specified by this argument.  If you specify 0, however, your task will wait
    252          *                            forever at the specified mailbox or, until a message arrives.
    253          *
    254          *              perr          is a pointer to where an error message will be deposited.  Possible error
    255          *                            messages are:
    256          *
    257          *                            OS_ERR_NONE         The call was successful and your task received a
    258          *                                                message.
    259          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    260          *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
    261          *                            OS_ERR_EVENT_TYPE   Invalid event type
    262          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    263          *                                                would lead to a suspension.
    264          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    265          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    266          *
    267          * Returns    : != (void *)0  is a pointer to the message received
    268          *              == (void *)0  if no message was received or,
    269          *                            if 'pevent' is a NULL pointer or,
    270          *                            if you didn't pass the proper pointer to the event control block.
    271          *********************************************************************************************************
    272          */
    273          /*$PAGE*/

   \                                 In section .text, align 4, keep-with-next
    274          void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
    275          {
   \                     OSMboxPend:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0646               MOV      R6,R0
   \   00000006   0C46               MOV      R4,R1
   \   00000008   1500               MOVS     R5,R2
    276              void      *pmsg;
    277          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    278              OS_CPU_SR  cpu_sr = 0;
    279          #endif
    280          
    281          
    282          
    283          #if OS_ARG_CHK_EN > 0
    284              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
   \   0000000A   02D1               BNE.N    ??OSMboxPend_0
    285                  return ((void *)0);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   BDE8F283           POP      {R1,R4-R9,PC}
    286              }
    287              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
   \                     ??OSMboxPend_0:
   \   00000012   002E               CMP      R6,#+0
   \   00000014   04D1               BNE.N    ??OSMboxPend_1
    288                  *perr = OS_ERR_PEVENT_NULL;
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   2870               STRB     R0,[R5, #+0]
    289                  return ((void *)0);
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   BDE8F283           POP      {R1,R4-R9,PC}
    290              }
    291          #endif
    292              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \                     ??OSMboxPend_1:
   \   00000020   3078               LDRB     R0,[R6, #+0]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   04D0               BEQ.N    ??OSMboxPend_2
    293                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0120               MOVS     R0,#+1
   \   00000028   2870               STRB     R0,[R5, #+0]
    294                  return ((void *)0);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   BDE8F283           POP      {R1,R4-R9,PC}
    295              }
    296              if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
   \                     ??OSMboxPend_2:
   \   00000030   ....               LDR.N    R0,??DataTable5  ;; OSIntNesting
   \   00000032   0078               LDRB     R0,[R0, #+0]
   \   00000034   0028               CMP      R0,#+0
   \   00000036   04D0               BEQ.N    ??OSMboxPend_3
    297                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
   \   00000038   0220               MOVS     R0,#+2
   \   0000003A   2870               STRB     R0,[R5, #+0]
    298                  return ((void *)0);
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   BDE8F283           POP      {R1,R4-R9,PC}
    299              }
    300              if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
   \                     ??OSMboxPend_3:
   \   00000042   3348               LDR.N    R0,??OSMboxPend_4  ;; OSLockNesting
   \   00000044   0078               LDRB     R0,[R0, #+0]
   \   00000046   0028               CMP      R0,#+0
   \   00000048   04D0               BEQ.N    ??OSMboxPend_5
    301                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
   \   0000004A   0D20               MOVS     R0,#+13
   \   0000004C   2870               STRB     R0,[R5, #+0]
    302                  return ((void *)0);
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   BDE8F283           POP      {R1,R4-R9,PC}
    303              }
    304              OS_ENTER_CRITICAL();
   \                     ??OSMboxPend_5:
   \   00000054   ........           BL       OS_CPU_SR_Save
   \   00000058   0746               MOV      R7,R0
    305              pmsg = pevent->OSEventPtr;
   \   0000005A   D6F80480           LDR      R8,[R6, #+4]
    306              if (pmsg != (void *)0) {                          /* See if there is already a message             */
   \   0000005E   B8F1000F           CMP      R8,#+0
   \   00000062   09D0               BEQ.N    ??OSMboxPend_6
    307                  pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   7060               STR      R0,[R6, #+4]
    308                  OS_EXIT_CRITICAL();
   \   00000068   3846               MOV      R0,R7
   \   0000006A   ........           BL       OS_CPU_SR_Restore
    309                  *perr = OS_ERR_NONE;
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   2870               STRB     R0,[R5, #+0]
    310                  return (pmsg);                                /* Return the message received (or NULL)         */
   \   00000072   4046               MOV      R0,R8
   \   00000074   BDE8F283           POP      {R1,R4-R9,PC}
    311              }
    312              OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
   \                     ??OSMboxPend_6:
   \   00000078   DFF89890           LDR.W    R9,??OSMboxPend_4+0x4  ;; OSTCBCur
   \   0000007C   D9F80000           LDR      R0,[R9, #+0]
   \   00000080   90F83010           LDRB     R1,[R0, #+48]
   \   00000084   41F00201           ORR      R1,R1,#0x2
   \   00000088   80F83010           STRB     R1,[R0, #+48]
    313              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000008C   D9F80000           LDR      R0,[R9, #+0]
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   80F83110           STRB     R1,[R0, #+49]
    314              OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
   \   00000096   D9F80000           LDR      R0,[R9, #+0]
   \   0000009A   C485               STRH     R4,[R0, #+46]
    315              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   0000009C   3046               MOV      R0,R6
   \   0000009E   ........           BL       OS_EventTaskWait
    316              OS_EXIT_CRITICAL();
   \   000000A2   3846               MOV      R0,R7
   \   000000A4   ........           BL       OS_CPU_SR_Restore
    317              OS_Sched();                                       /* Find next highest priority task ready to run  */
   \   000000A8   ........           BL       OS_Sched
    318              OS_ENTER_CRITICAL();
   \   000000AC   ........           BL       OS_CPU_SR_Save
   \   000000B0   0746               MOV      R7,R0
    319              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   000000B2   D9F80000           LDR      R0,[R9, #+0]
   \   000000B6   00F12401           ADD      R1,R0,#+36
   \   000000BA   497B               LDRB     R1,[R1, #+13]
   \   000000BC   0029               CMP      R1,#+0
   \   000000BE   02D0               BEQ.N    ??OSMboxPend_7
   \   000000C0   0229               CMP      R1,#+2
   \   000000C2   05D0               BEQ.N    ??OSMboxPend_8
   \   000000C4   07E0               B.N      ??OSMboxPend_9
    320                  case OS_STAT_PEND_OK:
    321                       pmsg =  OSTCBCur->OSTCBMsg;
   \                     ??OSMboxPend_7:
   \   000000C6   D0F82480           LDR      R8,[R0, #+36]
    322                      *perr =  OS_ERR_NONE;
   \   000000CA   0020               MOVS     R0,#+0
   \   000000CC   2870               STRB     R0,[R5, #+0]
   \   000000CE   07E0               B.N      ??OSMboxPend_10
    323                       break;
    324          
    325                  case OS_STAT_PEND_ABORT:
    326                       pmsg = (void *)0;
    327                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \                     ??OSMboxPend_8:
   \   000000D0   0E20               MOVS     R0,#+14
   \   000000D2   2870               STRB     R0,[R5, #+0]
   \   000000D4   04E0               B.N      ??OSMboxPend_10
    328                       break;
    329          
    330                  case OS_STAT_PEND_TO:
    331                  default:
    332                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSMboxPend_9:
   \   000000D6   3146               MOV      R1,R6
   \   000000D8   ........           BL       OS_EventTaskRemove
    333                       pmsg = (void *)0;
    334                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   000000DC   0A20               MOVS     R0,#+10
   \   000000DE   2870               STRB     R0,[R5, #+0]
    335                       break;
    336              }
    337              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSMboxPend_10:
   \   000000E0   D9F80000           LDR      R0,[R9, #+0]
   \   000000E4   0021               MOVS     R1,#+0
   \   000000E6   80F83010           STRB     R1,[R0, #+48]
    338              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   000000EA   D9F80000           LDR      R0,[R9, #+0]
   \   000000EE   80F83110           STRB     R1,[R0, #+49]
    339              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   000000F2   D9F80000           LDR      R0,[R9, #+0]
   \   000000F6   C161               STR      R1,[R0, #+28]
    340          #if (OS_EVENT_MULTI_EN > 0)
    341              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000000F8   D9F80000           LDR      R0,[R9, #+0]
   \   000000FC   0162               STR      R1,[R0, #+32]
    342          #endif
    343              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
   \   000000FE   D9F80000           LDR      R0,[R9, #+0]
   \   00000102   4162               STR      R1,[R0, #+36]
    344              OS_EXIT_CRITICAL();
   \   00000104   3846               MOV      R0,R7
   \   00000106   ........           BL       OS_CPU_SR_Restore
    345              return (pmsg);                                    /* Return received message                       */
   \   0000010A   4046               MOV      R0,R8
   \   0000010C   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
   \                     ??OSMboxPend_4:
   \   00000110   ........           DC32     OSLockNesting
   \   00000114   ........           DC32     OSTCBCur
    346          }
    347          /*$PAGE*/
    348          /*
    349          *********************************************************************************************************
    350          *                                      ABORT WAITING ON A MESSAGE MAILBOX
    351          *
    352          * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function 
    353          *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
    354          *              the mailbox via OSMboxPost() or OSMboxPostOpt().
    355          *
    356          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
    357          *
    358          *              opt           determines the type of ABORT performed:
    359          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    360          *                                                     mailbox
    361          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    362          *                                                     mailbox
    363          *
    364          *              perr          is a pointer to where an error message will be deposited.  Possible error
    365          *                            messages are:
    366          *
    367          *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
    368          *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
    369          *                                                and informed of the aborted wait; check return value 
    370          *                                                for the number of tasks whose wait on the mailbox 
    371          *                                                was aborted.
    372          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
    373          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    374          *
    375          * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
    376          *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
    377          *********************************************************************************************************
    378          */
    379          
    380          #if OS_MBOX_PEND_ABORT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    381          INT8U  OSMboxPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    382          {
   \                     OSMboxPendAbort:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   8846               MOV      R8,R1
   \   00000008   1500               MOVS     R5,R2
    383              INT8U      nbr_tasks;
    384          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    385              OS_CPU_SR  cpu_sr = 0;
    386          #endif
    387          
    388          
    389          
    390          #if OS_ARG_CHK_EN > 0
    391              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
   \   0000000A   02D1               BNE.N    ??OSMboxPendAbort_0
    392                  return (0);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   BDE8F081           POP      {R4-R8,PC}
    393              }
    394              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
   \                     ??OSMboxPendAbort_0:
   \   00000012   002C               CMP      R4,#+0
   \   00000014   04D1               BNE.N    ??OSMboxPendAbort_1
    395                  *perr = OS_ERR_PEVENT_NULL;
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   2870               STRB     R0,[R5, #+0]
    396                  return (0);
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   BDE8F081           POP      {R4-R8,PC}
    397              }
    398          #endif
    399              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \                     ??OSMboxPendAbort_1:
   \   00000020   2078               LDRB     R0,[R4, #+0]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   04D0               BEQ.N    ??OSMboxPendAbort_2
    400                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0120               MOVS     R0,#+1
   \   00000028   2870               STRB     R0,[R5, #+0]
    401                  return (0);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   BDE8F081           POP      {R4-R8,PC}
    402              }
    403              OS_ENTER_CRITICAL();
   \                     ??OSMboxPendAbort_2:
   \   00000030   ........           BL       OS_CPU_SR_Save
   \   00000034   0646               MOV      R6,R0
    404              if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on mailbox?      */
   \   00000036   A07A               LDRB     R0,[R4, #+10]
   \   00000038   0028               CMP      R0,#+0
   \   0000003A   20D0               BEQ.N    ??OSMboxPendAbort_3
    405                  nbr_tasks = 0;
   \   0000003C   0027               MOVS     R7,#+0
    406                  switch (opt) {
   \   0000003E   B8F1010F           CMP      R8,#+1
   \   00000042   0BD1               BNE.N    ??OSMboxPendAbort_4
    407                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    408                           while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on mailbox  */
   \                     ??OSMboxPendAbort_5:
   \   00000044   A07A               LDRB     R0,[R4, #+10]
   \   00000046   0028               CMP      R0,#+0
   \   00000048   0FD0               BEQ.N    ??OSMboxPendAbort_6
    409                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \   0000004A   0223               MOVS     R3,#+2
   \   0000004C   1A46               MOV      R2,R3
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   2046               MOV      R0,R4
   \   00000052   ........           BL       OS_EventTaskRdy
    410                               nbr_tasks++;
   \   00000056   7F1C               ADDS     R7,R7,#+1
   \   00000058   FFB2               UXTB     R7,R7
   \   0000005A   F3E7               B.N      ??OSMboxPendAbort_5
    411                           }
    412                           break;
    413                       
    414                      case OS_PEND_OPT_NONE:
    415                      default:                                       /* No,  ready HPT       waiting on mailbox  */
    416                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \                     ??OSMboxPendAbort_4:
   \   0000005C   0223               MOVS     R3,#+2
   \   0000005E   1A46               MOV      R2,R3
   \   00000060   3946               MOV      R1,R7
   \   00000062   2046               MOV      R0,R4
   \   00000064   ........           BL       OS_EventTaskRdy
    417                           nbr_tasks++;
   \   00000068   0127               MOVS     R7,#+1
    418                           break;
    419                  }
    420                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_6:
   \   0000006A   3046               MOV      R0,R6
   \   0000006C   ........           BL       OS_CPU_SR_Restore
    421                  OS_Sched();                                        /* Find HPT ready to run                    */
   \   00000070   ........           BL       OS_Sched
    422                  *perr = OS_ERR_PEND_ABORT;
   \   00000074   0E20               MOVS     R0,#+14
   \   00000076   2870               STRB     R0,[R5, #+0]
    423                  return (nbr_tasks);
   \   00000078   3846               MOV      R0,R7
   \   0000007A   BDE8F081           POP      {R4-R8,PC}
    424              }
    425              OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_3:
   \   0000007E   3046               MOV      R0,R6
   \   00000080   ........           BL       OS_CPU_SR_Restore
    426              *perr = OS_ERR_NONE;
   \   00000084   0020               MOVS     R0,#+0
   \   00000086   2870               STRB     R0,[R5, #+0]
    427              return (0);                                            /* No tasks waiting on mailbox              */
   \   00000088   BDE8F081           POP      {R4-R8,PC}       ;; return
    428          }
    429          #endif
    430          
    431          /*$PAGE*/
    432          /*
    433          *********************************************************************************************************
    434          *                                       POST MESSAGE TO A MAILBOX
    435          *
    436          * Description: This function sends a message to a mailbox
    437          *
    438          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    439          *
    440          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    441          *
    442          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    443          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    444          *                                   message at a time and thus, the message MUST be consumed before you
    445          *                                   are allowed to send another one.
    446          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    447          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    448          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    449          *
    450          * Note(s)    : 1) HPT means Highest Priority Task
    451          *********************************************************************************************************
    452          */
    453          
    454          #if OS_MBOX_POST_EN > 0

   \                                 In section .text, align 2, keep-with-next
    455          INT8U  OSMboxPost (OS_EVENT *pevent, void *pmsg)
    456          {
   \                     OSMboxPost:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
    457          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    458              OS_CPU_SR  cpu_sr = 0;
    459          #endif
    460          
    461          
    462          
    463          #if OS_ARG_CHK_EN > 0
    464              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
   \   00000006   002D               CMP      R5,#+0
   \   00000008   01D1               BNE.N    ??OSMboxPost_0
    465                  return (OS_ERR_PEVENT_NULL);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   70BD               POP      {R4-R6,PC}
    466              }
    467              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
   \                     ??OSMboxPost_0:
   \   0000000E   002C               CMP      R4,#+0
   \   00000010   01D1               BNE.N    ??OSMboxPost_1
    468                  return (OS_ERR_POST_NULL_PTR);
   \   00000012   0320               MOVS     R0,#+3
   \   00000014   70BD               POP      {R4-R6,PC}
    469              }
    470          #endif
    471              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \                     ??OSMboxPost_1:
   \   00000016   2878               LDRB     R0,[R5, #+0]
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   01D0               BEQ.N    ??OSMboxPost_2
    472                  return (OS_ERR_EVENT_TYPE);
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   70BD               POP      {R4-R6,PC}
    473              }
    474              OS_ENTER_CRITICAL();
   \                     ??OSMboxPost_2:
   \   00000020   ........           BL       OS_CPU_SR_Save
   \   00000024   0646               MOV      R6,R0
    475              if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
   \   00000026   A87A               LDRB     R0,[R5, #+10]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   0CD0               BEQ.N    ??OSMboxPost_3
    476                                                                /* Ready HPT waiting on event                    */
    477                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   0000002C   0023               MOVS     R3,#+0
   \   0000002E   0222               MOVS     R2,#+2
   \   00000030   2146               MOV      R1,R4
   \   00000032   2846               MOV      R0,R5
   \   00000034   ........           BL       OS_EventTaskRdy
    478                  OS_EXIT_CRITICAL();
   \   00000038   3046               MOV      R0,R6
   \   0000003A   ........           BL       OS_CPU_SR_Restore
    479                  OS_Sched();                                   /* Find highest priority task ready to run       */
   \   0000003E   ........           BL       OS_Sched
    480                  return (OS_ERR_NONE);
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   70BD               POP      {R4-R6,PC}
    481              }
    482              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPost_3:
   \   00000046   6868               LDR      R0,[R5, #+4]
   \   00000048   0028               CMP      R0,#+0
   \   0000004A   04D0               BEQ.N    ??OSMboxPost_4
    483                  OS_EXIT_CRITICAL();
   \   0000004C   3046               MOV      R0,R6
   \   0000004E   ........           BL       OS_CPU_SR_Restore
    484                  return (OS_ERR_MBOX_FULL);
   \   00000052   1420               MOVS     R0,#+20
   \   00000054   70BD               POP      {R4-R6,PC}
    485              }
    486              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPost_4:
   \   00000056   6C60               STR      R4,[R5, #+4]
    487              OS_EXIT_CRITICAL();
   \   00000058   3046               MOV      R0,R6
   \   0000005A   ........           BL       OS_CPU_SR_Restore
    488              return (OS_ERR_NONE);
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   70BD               POP      {R4-R6,PC}       ;; return
    489          }
    490          #endif
    491          
    492          /*$PAGE*/
    493          /*
    494          *********************************************************************************************************
    495          *                                       POST MESSAGE TO A MAILBOX
    496          *
    497          * Description: This function sends a message to a mailbox
    498          *
    499          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    500          *
    501          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    502          *
    503          *              opt           determines the type of POST performed:
    504          *                            OS_POST_OPT_NONE         POST to a single waiting task
    505          *                                                     (Identical to OSMboxPost())
    506          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
    507          *
    508          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    509          *
    510          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    511          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    512          *                                   message at a time and thus, the message MUST be consumed before you
    513          *                                   are allowed to send another one.
    514          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    515          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    516          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    517          *
    518          * Note(s)    : 1) HPT means Highest Priority Task
    519          *
    520          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    521          *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
    522          *********************************************************************************************************
    523          */
    524          
    525          #if OS_MBOX_POST_OPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    526          INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
    527          {
   \                     OSMboxPostOpt:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
   \   00000006   1646               MOV      R6,R2
    528          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    529              OS_CPU_SR  cpu_sr = 0;
    530          #endif
    531          
    532          
    533          
    534          #if OS_ARG_CHK_EN > 0
    535              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
   \   00000008   002D               CMP      R5,#+0
   \   0000000A   01D1               BNE.N    ??OSMboxPostOpt_0
    536                  return (OS_ERR_PEVENT_NULL);
   \   0000000C   0420               MOVS     R0,#+4
   \   0000000E   F2BD               POP      {R1,R4-R7,PC}
    537              }
    538              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
   \                     ??OSMboxPostOpt_0:
   \   00000010   002C               CMP      R4,#+0
   \   00000012   01D1               BNE.N    ??OSMboxPostOpt_1
    539                  return (OS_ERR_POST_NULL_PTR);
   \   00000014   0320               MOVS     R0,#+3
   \   00000016   F2BD               POP      {R1,R4-R7,PC}
    540              }
    541          #endif
    542              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \                     ??OSMboxPostOpt_1:
   \   00000018   2878               LDRB     R0,[R5, #+0]
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   01D0               BEQ.N    ??OSMboxPostOpt_2
    543                  return (OS_ERR_EVENT_TYPE);
   \   0000001E   0120               MOVS     R0,#+1
   \   00000020   F2BD               POP      {R1,R4-R7,PC}
    544              }
    545              OS_ENTER_CRITICAL();
   \                     ??OSMboxPostOpt_2:
   \   00000022   ........           BL       OS_CPU_SR_Save
   \   00000026   0746               MOV      R7,R0
    546              if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
   \   00000028   A87A               LDRB     R0,[R5, #+10]
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   1CD0               BEQ.N    ??OSMboxPostOpt_3
    547                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
   \   0000002E   16F0010F           TST      R6,#0x1
   \   00000032   09D0               BEQ.N    ??OSMboxPostOpt_4
    548                      while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
   \                     ??OSMboxPostOpt_5:
   \   00000034   A87A               LDRB     R0,[R5, #+10]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   0CD0               BEQ.N    ??OSMboxPostOpt_6
    549                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   0000003A   0023               MOVS     R3,#+0
   \   0000003C   0222               MOVS     R2,#+2
   \   0000003E   2146               MOV      R1,R4
   \   00000040   2846               MOV      R0,R5
   \   00000042   ........           BL       OS_EventTaskRdy
   \   00000046   F5E7               B.N      ??OSMboxPostOpt_5
    550                      }
    551                  } else {                                      /* No,  Post to HPT waiting on mbox              */
    552                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxPostOpt_4:
   \   00000048   0023               MOVS     R3,#+0
   \   0000004A   0222               MOVS     R2,#+2
   \   0000004C   2146               MOV      R1,R4
   \   0000004E   2846               MOV      R0,R5
   \   00000050   ........           BL       OS_EventTaskRdy
    553                  }
    554                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPostOpt_6:
   \   00000054   3846               MOV      R0,R7
   \   00000056   ........           BL       OS_CPU_SR_Restore
    555                  if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
   \   0000005A   16F0040F           TST      R6,#0x4
   \   0000005E   01D1               BNE.N    ??OSMboxPostOpt_7
    556                      OS_Sched();                               /* Find HPT ready to run                         */
   \   00000060   ........           BL       OS_Sched
    557                  }
    558                  return (OS_ERR_NONE);
   \                     ??OSMboxPostOpt_7:
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   F2BD               POP      {R1,R4-R7,PC}
    559              }
    560              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPostOpt_3:
   \   00000068   6868               LDR      R0,[R5, #+4]
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   04D0               BEQ.N    ??OSMboxPostOpt_8
    561                  OS_EXIT_CRITICAL();
   \   0000006E   3846               MOV      R0,R7
   \   00000070   ........           BL       OS_CPU_SR_Restore
    562                  return (OS_ERR_MBOX_FULL);
   \   00000074   1420               MOVS     R0,#+20
   \   00000076   F2BD               POP      {R1,R4-R7,PC}
    563              }
    564              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPostOpt_8:
   \   00000078   6C60               STR      R4,[R5, #+4]
    565              OS_EXIT_CRITICAL();
   \   0000007A   3846               MOV      R0,R7
   \   0000007C   ........           BL       OS_CPU_SR_Restore
    566              return (OS_ERR_NONE);
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   F2BD               POP      {R1,R4-R7,PC}    ;; return
    567          }
    568          #endif
    569          
    570          /*$PAGE*/
    571          /*
    572          *********************************************************************************************************
    573          *                                        QUERY A MESSAGE MAILBOX
    574          *
    575          * Description: This function obtains information about a message mailbox.
    576          *
    577          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    578          *
    579          *              p_mbox_data   is a pointer to a structure that will contain information about the message
    580          *                            mailbox.
    581          *
    582          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    583          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
    584          *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
    585          *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
    586          *********************************************************************************************************
    587          */
    588          
    589          #if OS_MBOX_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    590          INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
    591          {
   \                     OSMboxQuery:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
    592              INT8U      i;
    593          #if OS_LOWEST_PRIO <= 63
    594              INT8U     *psrc;
    595              INT8U     *pdest;
    596          #else
    597              INT16U    *psrc;
    598              INT16U    *pdest;
    599          #endif
    600          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    601              OS_CPU_SR  cpu_sr = 0;
    602          #endif
    603          
    604          
    605          
    606          #if OS_ARG_CHK_EN > 0
    607              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
   \   00000006   002D               CMP      R5,#+0
   \   00000008   01D1               BNE.N    ??OSMboxQuery_0
    608                  return (OS_ERR_PEVENT_NULL);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   70BD               POP      {R4-R6,PC}
    609              }
    610              if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
   \                     ??OSMboxQuery_0:
   \   0000000E   002C               CMP      R4,#+0
   \   00000010   01D1               BNE.N    ??OSMboxQuery_1
    611                  return (OS_ERR_PDATA_NULL);
   \   00000012   0920               MOVS     R0,#+9
   \   00000014   70BD               POP      {R4-R6,PC}
    612              }
    613          #endif
    614              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \                     ??OSMboxQuery_1:
   \   00000016   2878               LDRB     R0,[R5, #+0]
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   01D0               BEQ.N    ??OSMboxQuery_2
    615                  return (OS_ERR_EVENT_TYPE);
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   70BD               POP      {R4-R6,PC}
    616              }
    617              OS_ENTER_CRITICAL();
   \                     ??OSMboxQuery_2:
   \   00000020   ........           BL       OS_CPU_SR_Save
    618              p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
   \   00000024   A97A               LDRB     R1,[R5, #+10]
   \   00000026   2172               STRB     R1,[R4, #+8]
    619              psrc                    = &pevent->OSEventTbl[0];
   \   00000028   05F10B01           ADD      R1,R5,#+11
    620              pdest                   = &p_mbox_data->OSEventTbl[0];
   \   0000002C   221D               ADDS     R2,R4,#+4
    621              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
   \   0000002E   0023               MOVS     R3,#+0
   \   00000030   05E0               B.N      ??OSMboxQuery_3
    622                  *pdest++ = *psrc++;
   \                     ??OSMboxQuery_4:
   \   00000032   11F8016B           LDRB     R6,[R1], #+1
   \   00000036   02F8016B           STRB     R6,[R2], #+1
    623              }
   \   0000003A   5B1C               ADDS     R3,R3,#+1
   \   0000003C   DBB2               UXTB     R3,R3
   \                     ??OSMboxQuery_3:
   \   0000003E   1E46               MOV      R6,R3
   \   00000040   042E               CMP      R6,#+4
   \   00000042   F6D3               BCC.N    ??OSMboxQuery_4
    624              p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
   \   00000044   6968               LDR      R1,[R5, #+4]
   \   00000046   2160               STR      R1,[R4, #+0]
    625              OS_EXIT_CRITICAL();
   \   00000048   ........           BL       OS_CPU_SR_Restore
    626              return (OS_ERR_NONE);
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   70BD               POP      {R4-R6,PC}       ;; return
    627          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     OSIntNesting
    628          #endif                                                     /* OS_MBOX_QUERY_EN                         */
    629          #endif                                                     /* OS_MBOX_EN                               */

   Maximum stack usage in bytes:

     Function        .cstack
     --------        -------
     OSMboxAccept        16
     OSMboxCreate        16
     OSMboxDel           24
     OSMboxPend          32
     OSMboxPendAbort     24
     OSMboxPost          16
     OSMboxPostOpt       24
     OSMboxQuery         16


   Section sizes:

     Function/Label  Bytes
     --------------  -----
     OSMboxAccept      38
     OSMboxCreate      68
     OSMboxDel        224
     OSMboxPend       280
     OSMboxPendAbort  140
     OSMboxPost        98
     OSMboxPostOpt    132
     OSMboxQuery       80
     ??DataTable4       4
     ??DataTable5       4

 
 1 068 bytes in section .text
 
 1 068 bytes of CODE memory

Errors: none
Warnings: none
