###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     28/Dec/2014  20:59:01 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\BSP\bsp.c                     #
#    Command line =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\BSP\bsp.c -lCN                #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\ -o   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\       #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "F:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\S #
#                    oftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\ -I      #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\BSP\ -I       #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\C #
#                    PU\ST\STM32\inc\ -I C:\Users\Administrator\Desktop\uCOS- #
#                    II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe- #
#                    LCD\..\..\..\..\..\uC-CPU\ -I                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-CPU\ARM-Cortex-M3\IAR\ -I                              #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-LCD\Source\ -I C:\Users\Administrator\Desktop\uCOS-II\ #
#                    Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD #
#                    \..\..\..\..\..\uC-LIB\ -I C:\Users\Administrator\Deskto #
#                    p\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS #
#                    -Probe-LCD\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Ge #
#                    neric\IAR\ -I C:\Users\Administrator\Desktop\uCOS-II\Mic #
#                    rium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\.. #
#                    \..\..\..\..\uCOS-II\Source\ -I                          #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM #
#                    32\ -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\So #
#                    ftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\ #
#                    ..\..\uC-Probe\Target\Communication\Generic\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Plugins\uCOS-II\ -I "F:\Program Files     #
#                    (x86)\IAR Systems\Embedded Workbench 5.4\arm\INC\" -Om   #
#    List file    =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\bsp.l #
#                    st                                                       #
#    Object file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\bsp.o  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICIRUM BOARD SUPPORT PACKAGE
      4          *
      5          *                             (c) Copyright 2007; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        BOARD SUPPORT PACKAGE
     18          *
     19          *                                     ST Microelectronics STM32
     20          *                                              with the
     21          *                                   IAR STM32-SK Evaluation Board
     22          *
     23          * Filename      : bsp.c
     24          * Version       : V1.10
     25          * Programmer(s) : BAN
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                             INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          
     35          #define  BSP_MODULE
     36          #include <bsp.h>
     37          
     38          /*
     39          *********************************************************************************************************
     40          *                                            LOCAL DEFINES
     41          *********************************************************************************************************
     42          */
     43                                                                          /* -------------------- GPIOA PINS -------------------- */
     44          #define  BSP_GPIOA_PB_WAKEUP                     DEF_BIT_00
     45          #define  BSP_GPIOA_MIC_IN                        DEF_BIT_01
     46          #define  BSP_GPIOA_UART2_TX                      DEF_BIT_02
     47          #define  BSP_GPIOA_UART2_RX                      DEF_BIT_03
     48          #define  BSP_GPIOA_LED1                          DEF_BIT_04
     49          #define  BSP_GPIOA_LED2                          DEF_BIT_05
     50          #define  BSP_GPIOA_LED3                          DEF_BIT_06
     51          #define  BSP_GPIOA_LED4                          DEF_BIT_07
     52          #define  BSP_GPIOA_PWM_OUT                       DEF_BIT_08
     53          #define  BSP_GPIOA_LED5                          DEF_BIT_09
     54          #define  BSP_GPIOA_LED6                          DEF_BIT_10
     55          
     56          #if (BSP_CFG_LED_SPI1_EN == DEF_ENABLED)
     57          #define  BSP_GPIOA_LEDS        (BSP_GPIOA_LED1 | BSP_GPIOA_LED2 | BSP_GPIOA_LED3 | BSP_GPIOA_LED4 | BSP_GPIOA_LED5 | BSP_GPIOA_LED6)
     58          #else
     59          #define  BSP_GPIOA_LEDS        (BSP_GPIOA_LED5 | BSP_GPIOA_LED6)
     60          #endif
     61          
     62                                                                          /* -------------------- GPIOB PINS -------------------- */
     63          #define  BSP_GPIOB_LCD_LIGHT                     DEF_BIT_00
     64          #define  BSP_GPIOB_PB2                           DEF_BIT_05
     65          #define  BSP_GPIOB_LED7                          DEF_BIT_06
     66          #define  BSP_GPIOB_LED8                          DEF_BIT_07
     67          #define  BSP_GPIOB_CAN_RX                        DEF_BIT_08
     68          #define  BSP_GPIOB_CAN_TX                        DEF_BIT_09
     69          #define  BSP_GPIOB_LED9                          DEF_BIT_10
     70          #define  BSP_GPIOB_LED10                         DEF_BIT_11
     71          #define  BSP_GPIOB_LED11                         DEF_BIT_12
     72          #define  BSP_GPIOB_LED12                         DEF_BIT_13
     73          #define  BSP_GPIOB_LED13                         DEF_BIT_14
     74          #define  BSP_GPIOB_LED14                         DEF_BIT_15
     75          
     76          #if (BSP_CFG_LED_SPI2_EN == DEF_ENABLED)
     77          #define  BSP_GPIOB_LEDS        (BSP_GPIOB_LED7 | BSP_GPIOB_LED8 | BSP_GPIOB_LED9 | BSP_GPIOB_LED10 | BSP_GPIOB_LED11 | BSP_GPIOB_LED12 | BSP_GPIOB_LED13 | BSP_GPIOB_LED14)
     78          #else
     79          #define  BSP_GPIOB_LEDS        (BSP_GPIOB_LED7 | BSP_GPIOB_LED8 | BSP_GPIOB_LED9 | BSP_GPIOB_LED10)
     80          #endif
     81          
     82                                                                          /* -------------------- GPIOC PINS -------------------- */
     83          #define  BSP_GPIOC_LCD_DB4                       DEF_BIT_00
     84          #define  BSP_GPIOC_LCD_DB5                       DEF_BIT_01
     85          #define  BSP_GPIOC_LCD_DB6                       DEF_BIT_02
     86          #define  BSP_GPIOC_LCD_DB7                       DEF_BIT_03
     87          #define  BSP_GPIOC_PB3                           DEF_BIT_04
     88          #define  BSP_GPIOC_POT                           DEF_BIT_05
     89          #define  BSP_GPIOC_LED15                         DEF_BIT_06
     90          #define  BSP_GPIOC_LED16                         DEF_BIT_07
     91          #define  BSP_GPIOC_LCD_RS                        DEF_BIT_08
     92          #define  BSP_GPIOC_LCD_RW                        DEF_BIT_09
     93          #define  BSP_GPIOC_USART3_TX                     DEF_BIT_10
     94          #define  BSP_GPIOC_USART3_RX                     DEF_BIT_11
     95          #define  BSP_GPIOC_LCD_E                         DEF_BIT_12
     96          #define  BSP_GPIOC_PB1                           DEF_BIT_13
     97          #define  BSP_GPIOC_LCD_DB      (BSP_GPIOC_LCD_DB4 | BSP_GPIOC_LCD_DB5 | BSP_GPIOC_LCD_DB6 | BSP_GPIOC_LCD_DB7)
     98          #define  BSP_GPIOC_LEDS        (BSP_GPIOC_LED15   | BSP_GPIOC_LED16)
     99          
    100          /*
    101          *********************************************************************************************************
    102          *                                           LOCAL CONSTANTS
    103          *********************************************************************************************************
    104          */
    105          
    106          
    107          /*
    108          *********************************************************************************************************
    109          *                                          LOCAL DATA TYPES
    110          *********************************************************************************************************
    111          */
    112          
    113          
    114          /*
    115          *********************************************************************************************************
    116          *                                            LOCAL TABLES
    117          *********************************************************************************************************
    118          */
    119          
    120          
    121          /*
    122          *********************************************************************************************************
    123          *                                       LOCAL GLOBAL VARIABLES
    124          *********************************************************************************************************
    125          */
    126          
    127          
    128          /*
    129          *********************************************************************************************************
    130          *                                      LOCAL FUNCTION PROTOTYPES
    131          *********************************************************************************************************
    132          */
    133          
    134          static  void  BSP_LED_Init      (void);
    135          static  void  BSP_PB_Init       (void);
    136          static  void  BSP_LCD_LightInit (void);
    137          static  void  BSP_ADCS_Init     (void);
    138          
    139          #ifdef DISP_MODULE_PRESENT
    140          static  void  BSP_DispE_High    (void);
    141          static  void  BSP_DispE_Low     (void);
    142          static  void  BSP_DispRW_Low    (void);
    143          #endif
    144          
    145          /*
    146          *********************************************************************************************************
    147          *                                     LOCAL CONFIGURATION ERRORS
    148          *********************************************************************************************************
    149          */
    150          
    151          
    152          /*
    153          *********************************************************************************************************
    154          *                                               BSP_Init()
    155          *
    156          * Description : Initialize the Board Support Package (BSP).
    157          *
    158          * Argument(s) : none.
    159          *
    160          * Return(s)   : none.
    161          *
    162          * Caller(s)   : Application.
    163          *
    164          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
    165          *********************************************************************************************************
    166          */
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void  BSP_Init (void)
    169          {
   \                     BSP_Init:
   \   00000000   80B5               PUSH     {R7,LR}
    170              RCC_DeInit();
   \   00000002   ........           BL       RCC_DeInit
    171              RCC_HSEConfig(RCC_HSE_ON);
   \   00000006   4FF48030           MOV      R0,#+65536
   \   0000000A   ........           BL       RCC_HSEConfig
    172              RCC_WaitForHSEStartUp();
   \   0000000E   ........           BL       RCC_WaitForHSEStartUp
    173          
    174          
    175              RCC_HCLKConfig(RCC_SYSCLK_Div1);
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   ........           BL       RCC_HCLKConfig
    176              RCC_PCLK2Config(RCC_HCLK_Div1);
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   ........           BL       RCC_PCLK2Config
    177              RCC_PCLK1Config(RCC_HCLK_Div2);
   \   0000001E   4FF48060           MOV      R0,#+1024
   \   00000022   ........           BL       RCC_PCLK1Config
    178              RCC_ADCCLKConfig(RCC_PCLK2_Div6);
   \   00000026   4FF40040           MOV      R0,#+32768
   \   0000002A   ........           BL       RCC_ADCCLKConfig
    179              FLASH_SetLatency(FLASH_Latency_2);
   \   0000002E   0220               MOVS     R0,#+2
   \   00000030   ........           BL       FLASH_SetLatency
    180              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
   \   00000034   1020               MOVS     R0,#+16
   \   00000036   ........           BL       FLASH_PrefetchBufferCmd
    181              RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
   \   0000003A   4FF4E011           MOV      R1,#+1835008
   \   0000003E   4FF48030           MOV      R0,#+65536
   \   00000042   ........           BL       RCC_PLLConfig
    182              RCC_PLLCmd(ENABLE);
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   ........           BL       RCC_PLLCmd
    183          
    184              while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
   \                     ??BSP_Init_0:
   \   0000004C   3920               MOVS     R0,#+57
   \   0000004E   ........           BL       RCC_GetFlagStatus
   \   00000052   0028               CMP      R0,#+0
   \   00000054   FAD0               BEQ.N    ??BSP_Init_0
    185                  ;
    186              }
    187          
    188              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
   \   00000056   0220               MOVS     R0,#+2
   \   00000058   ........           BL       RCC_SYSCLKConfig
    189          
    190              while (RCC_GetSYSCLKSource() != 0x08) {
   \                     ??BSP_Init_1:
   \   0000005C   ........           BL       RCC_GetSYSCLKSource
   \   00000060   0828               CMP      R0,#+8
   \   00000062   FBD1               BNE.N    ??BSP_Init_1
    191                  ;
    192              }
    193          
    194              BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
   \   00000064   ........           BL       BSP_LED_Init
    195              BSP_PB_Init();                                              /* Initialize the I/Os for the PB       controls.       */
   \   00000068   ........           BL       BSP_PB_Init
    196              BSP_LCD_LightInit();                                        /* Initialize the I/Os for the LCD backlight.           */
   \   0000006C   ........           BL       BSP_LCD_LightInit
    197              BSP_ADCS_Init();                                            /* Initialize the ADC  for the potentiometer.           */
   \   00000070   BDE80140           POP      {R0,LR}
   \   00000074   ....               B.N      BSP_ADCS_Init
    198          }
    199          
    200          
    201          /*
    202          *********************************************************************************************************
    203          *                                            BSP_CPU_ClkFreq()
    204          *
    205          * Description : Read CPU registers to determine the CPU clock frequency of the chip.
    206          *
    207          * Argument(s) : none.
    208          *
    209          * Return(s)   : The CPU clock frequency, in Hz.
    210          *
    211          * Caller(s)   : Application.
    212          *
    213          * Note(s)     : none.
    214          *********************************************************************************************************
    215          */
    216          

   \                                 In section .text, align 2, keep-with-next
    217          CPU_INT32U  BSP_CPU_ClkFreq (void)
    218          {
   \                     BSP_CPU_ClkFreq:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    219              RCC_ClocksTypeDef  rcc_clocks;
    220          
    221          
    222              RCC_GetClocksFreq(&rcc_clocks);
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ........           BL       RCC_GetClocksFreq
    223          
    224              return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
   \   0000000A   0198               LDR      R0,[SP, #+4]
   \   0000000C   05B0               ADD      SP,SP,#+20
   \   0000000E   00BD               POP      {PC}             ;; return
    225          }
    226          
    227          
    228          /*
    229          *********************************************************************************************************
    230          *********************************************************************************************************
    231          *                                         OS CORTEX-M3 FUNCTIONS
    232          *********************************************************************************************************
    233          *********************************************************************************************************
    234          */
    235          
    236          /*
    237          *********************************************************************************************************
    238          *                                         OS_CPU_SysTickClkFreq()
    239          *
    240          * Description : Get system tick clock frequency.
    241          *
    242          * Argument(s) : none.
    243          *
    244          * Return(s)   : Clock frequency (of system tick).
    245          *
    246          * Caller(s)   : BSP_Init().
    247          *
    248          * Note(s)     : none.
    249          *********************************************************************************************************
    250          */
    251          

   \                                 In section .text, align 2, keep-with-next
    252          INT32U  OS_CPU_SysTickClkFreq (void)
    253          {
    254              INT32U  freq;
    255          
    256          
    257              freq = BSP_CPU_ClkFreq();
    258              return (freq);
   \                     OS_CPU_SysTickClkFreq:
   \   00000000   ....               B.N      BSP_CPU_ClkFreq
    259          }
    260          
    261          
    262          /*
    263          *********************************************************************************************************
    264          *********************************************************************************************************
    265          *                                               PB FUNCTIONS
    266          *********************************************************************************************************
    267          *********************************************************************************************************
    268          */
    269          /*
    270          *********************************************************************************************************
    271          *                                              BSP_PB_Init()
    272          *
    273          * Description : Initialize the board's PB.
    274          *
    275          * Argument(s) : none.
    276          *
    277          * Return(s)   : none.
    278          *
    279          * Caller(s)   : BSP_Init().
    280          *
    281          * Note(s)     : none.
    282          *********************************************************************************************************
    283          */
    284          

   \                                 In section .text, align 2, keep-with-next
    285          static  void  BSP_PB_Init (void)
    286          {
   \                     BSP_PB_Init:
   \   00000000   80B5               PUSH     {R7,LR}
    287              GPIO_InitTypeDef  gpio_init;
    288          
    289          
    290              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0420               MOVS     R0,#+4
   \   00000006   ........           BL       RCC_APB2PeriphClockCmd
    291              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   0820               MOVS     R0,#+8
   \   0000000E   ........           BL       RCC_APB2PeriphClockCmd
    292              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   1020               MOVS     R0,#+16
   \   00000016   ........           BL       RCC_APB2PeriphClockCmd
    293          
    294              gpio_init.GPIO_Pin  = BSP_GPIOA_PB_WAKEUP;
   \   0000001A   0120               MOVS     R0,#+1
   \   0000001C   ADF80000           STRH     R0,[SP, #+0]
    295              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000020   0420               MOVS     R0,#+4
   \   00000022   8DF80300           STRB     R0,[SP, #+3]
    296              GPIO_Init(GPIOA, &gpio_init);
   \   00000026   00A9               ADD      R1,SP,#+0
   \   00000028   ........           LDR.W    R0,??DataTable43  ;; 0x40010800
   \   0000002C   ........           BL       GPIO_Init
    297          
    298              gpio_init.GPIO_Pin  = BSP_GPIOB_PB2;
   \   00000030   2020               MOVS     R0,#+32
   \   00000032   ADF80000           STRH     R0,[SP, #+0]
    299              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000036   0420               MOVS     R0,#+4
   \   00000038   8DF80300           STRB     R0,[SP, #+3]
    300              GPIO_Init(GPIOB, &gpio_init);
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   ........           LDR.W    R0,??DataTable50  ;; 0x40010c00
   \   00000042   ........           BL       GPIO_Init
    301          
    302              gpio_init.GPIO_Pin  = BSP_GPIOC_PB1 | BSP_GPIOC_PB3;
   \   00000046   42F21000           MOVW     R0,#+8208
   \   0000004A   ADF80000           STRH     R0,[SP, #+0]
    303              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000004E   0420               MOVS     R0,#+4
   \   00000050   8DF80300           STRB     R0,[SP, #+3]
    304              GPIO_Init(GPIOC, &gpio_init);
   \   00000054   00A9               ADD      R1,SP,#+0
   \   00000056   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   0000005A   ........           BL       GPIO_Init
    305          
    306          }
   \   0000005E   01BD               POP      {R0,PC}          ;; return
    307          
    308          
    309          /*
    310          *********************************************************************************************************
    311          *                                           BSP_PB_GetStatus()
    312          *
    313          * Description : Get the status of a push button on the board.
    314          *
    315          * Argument(s) : pb      The ID of the push button to probe
    316          *
    317          *                       1    probe the PB1    push button
    318          *                       2    probe the PB2    push button
    319          *                       3    probe the PB3    push button
    320          *                       4    probe the wakeup push button
    321          *
    322          * Return(s)   : DEF_FALSE   if the push button is pressed.
    323          *               DEF_TRUE    if the push button is not pressed.
    324          *
    325          * Caller(s)   : Application.
    326          *
    327          * Note(s)     : none.
    328          *********************************************************************************************************
    329          */
    330          

   \                                 In section .text, align 2, keep-with-next
    331          CPU_BOOLEAN  BSP_PB_GetStatus (CPU_INT08U pb)
    332          {
   \                     BSP_PB_GetStatus:
   \   00000000   10B5               PUSH     {R4,LR}
    333              CPU_BOOLEAN  status;
    334              CPU_INT32U   pin;
    335          
    336          
    337              status = DEF_FALSE;
   \   00000002   0024               MOVS     R4,#+0
    338          
    339              switch (pb) {
   \   00000004   0128               CMP      R0,#+1
   \   00000006   06D0               BEQ.N    ??BSP_PB_GetStatus_0
   \   00000008   0228               CMP      R0,#+2
   \   0000000A   0ED0               BEQ.N    ??BSP_PB_GetStatus_1
   \   0000000C   0328               CMP      R0,#+3
   \   0000000E   15D0               BEQ.N    ??BSP_PB_GetStatus_2
   \   00000010   0428               CMP      R0,#+4
   \   00000012   1CD0               BEQ.N    ??BSP_PB_GetStatus_3
   \   00000014   23E0               B.N      ??BSP_PB_GetStatus_4
    340                  case 1:
    341                       pin = GPIO_ReadInputDataBit(GPIOC, BSP_GPIOC_PB1);
   \                     ??BSP_PB_GetStatus_0:
   \   00000016   4FF40051           MOV      R1,#+8192
   \   0000001A   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   0000001E   ........           BL       GPIO_ReadInputDataBit
    342                       if (pin > 0) {
   \   00000022   0028               CMP      R0,#+0
   \   00000024   1BD0               BEQ.N    ??BSP_PB_GetStatus_4
    343                           status = DEF_TRUE;
   \   00000026   0124               MOVS     R4,#+1
   \   00000028   19E0               B.N      ??BSP_PB_GetStatus_4
    344                       }
    345                       break;
    346          
    347                  case 2:
    348                       pin = GPIO_ReadInputDataBit(GPIOB, BSP_GPIOB_PB2);
   \                     ??BSP_PB_GetStatus_1:
   \   0000002A   2021               MOVS     R1,#+32
   \   0000002C   ........           LDR.W    R0,??DataTable50  ;; 0x40010c00
   \   00000030   ........           BL       GPIO_ReadInputDataBit
    349                       if (pin > 0) {
   \   00000034   0028               CMP      R0,#+0
   \   00000036   12D0               BEQ.N    ??BSP_PB_GetStatus_4
    350                           status = DEF_TRUE;
   \   00000038   0124               MOVS     R4,#+1
   \   0000003A   10E0               B.N      ??BSP_PB_GetStatus_4
    351                       }
    352                       break;
    353          
    354                  case 3:
    355                       pin = GPIO_ReadInputDataBit(GPIOC, BSP_GPIOC_PB3);
   \                     ??BSP_PB_GetStatus_2:
   \   0000003C   1021               MOVS     R1,#+16
   \   0000003E   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   00000042   ........           BL       GPIO_ReadInputDataBit
    356                       if (pin > 0) {
   \   00000046   0028               CMP      R0,#+0
   \   00000048   09D0               BEQ.N    ??BSP_PB_GetStatus_4
    357                           status = DEF_TRUE;
   \   0000004A   0124               MOVS     R4,#+1
   \   0000004C   07E0               B.N      ??BSP_PB_GetStatus_4
    358                       }
    359                       break;
    360          
    361                  case 4:
    362                       pin = GPIO_ReadInputDataBit(GPIOA, BSP_GPIOA_PB_WAKEUP);
   \                     ??BSP_PB_GetStatus_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ........           LDR.W    R0,??DataTable43  ;; 0x40010800
   \   00000054   ........           BL       GPIO_ReadInputDataBit
    363                       if (pin > 0) {
   \   00000058   0028               CMP      R0,#+0
   \   0000005A   00D0               BEQ.N    ??BSP_PB_GetStatus_4
    364                           status = DEF_TRUE;
   \   0000005C   0124               MOVS     R4,#+1
    365                       }
    366                       break;
    367          
    368                  default:
    369                       break;
    370              }
    371          
    372              return (status);
   \                     ??BSP_PB_GetStatus_4:
   \   0000005E   2046               MOV      R0,R4
   \   00000060   10BD               POP      {R4,PC}          ;; return
    373          }
    374          
    375          
    376          /*
    377          *********************************************************************************************************
    378          *********************************************************************************************************
    379          *                                              LED FUNCTIONS
    380          *********************************************************************************************************
    381          *********************************************************************************************************
    382          */
    383          
    384          /*
    385          *********************************************************************************************************
    386          *                                             BSP_LED_Init()
    387          *
    388          * Description : Initialize the I/O for the LEDs
    389          *
    390          * Argument(s) : none.
    391          *
    392          * Return(s)   : none.
    393          *
    394          * Caller(s)   : BSP_Init().
    395          *
    396          * Note(s)     : none.
    397          *********************************************************************************************************
    398          */
    399          

   \                                 In section .text, align 2, keep-with-next
    400          static  void  BSP_LED_Init (void)
    401          {
   \                     BSP_LED_Init:
   \   00000000   80B5               PUSH     {R7,LR}
    402              GPIO_InitTypeDef  gpio_init;
    403          
    404          
    405              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0420               MOVS     R0,#+4
   \   00000006   ........           BL       RCC_APB2PeriphClockCmd
    406              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   0820               MOVS     R0,#+8
   \   0000000E   ........           BL       RCC_APB2PeriphClockCmd
    407              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   1020               MOVS     R0,#+16
   \   00000016   ........           BL       RCC_APB2PeriphClockCmd
    408          
    409              gpio_init.GPIO_Pin   = BSP_GPIOA_LEDS;
   \   0000001A   4FF4C060           MOV      R0,#+1536
   \   0000001E   ADF80000           STRH     R0,[SP, #+0]
    410              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000022   0320               MOVS     R0,#+3
   \   00000024   8DF80200           STRB     R0,[SP, #+2]
    411              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000028   1020               MOVS     R0,#+16
   \   0000002A   8DF80300           STRB     R0,[SP, #+3]
    412              GPIO_Init(GPIOA, &gpio_init);
   \   0000002E   00A9               ADD      R1,SP,#+0
   \   00000030   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000032   ........           BL       GPIO_Init
    413          
    414              gpio_init.GPIO_Pin   = BSP_GPIOB_LEDS;
   \   00000036   4FF6C040           MOVW     R0,#+64704
   \   0000003A   ADF80000           STRH     R0,[SP, #+0]
    415              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000003E   0320               MOVS     R0,#+3
   \   00000040   8DF80200           STRB     R0,[SP, #+2]
    416              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000044   1020               MOVS     R0,#+16
   \   00000046   8DF80300           STRB     R0,[SP, #+3]
    417              GPIO_Init(GPIOB, &gpio_init);
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ........           LDR.W    R0,??DataTable50  ;; 0x40010c00
   \   00000050   ........           BL       GPIO_Init
    418          
    419          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    420              gpio_init.GPIO_Pin   = BSP_GPIOC_LEDS;
   \   00000054   C020               MOVS     R0,#+192
   \   00000056   ADF80000           STRH     R0,[SP, #+0]
    421              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000005A   0320               MOVS     R0,#+3
   \   0000005C   8DF80200           STRB     R0,[SP, #+2]
    422              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000060   1020               MOVS     R0,#+16
   \   00000062   8DF80300           STRB     R0,[SP, #+3]
    423              GPIO_Init(GPIOC, &gpio_init);
   \   00000066   00A9               ADD      R1,SP,#+0
   \   00000068   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   0000006C   ........           BL       GPIO_Init
    424          #endif
    425          }
   \   00000070   01BD               POP      {R0,PC}          ;; return
    426          
    427          
    428          /*
    429          *********************************************************************************************************
    430          *                                             BSP_LED_On()
    431          *
    432          * Description : Turn ON any or all the LEDs on the board.
    433          *
    434          * Argument(s) : led     The ID of the LED to control:
    435          *
    436          *                       0    turns ON ALL the LEDs
    437          *                       1    turns ON user LED1  on the board
    438          *                       2    turns ON user LED2  on the board
    439          *                             .
    440          *                             .
    441          *                             .
    442          *                       16   turns ON user LED16 on the board
    443          *
    444          * Return(s)   : none.
    445          *
    446          * Caller(s)   : Application.
    447          *
    448          * Note(s)     : none.
    449          *********************************************************************************************************
    450          */
    451          

   \                                 In section .text, align 4, keep-with-next
    452          void  BSP_LED_On (CPU_INT08U led)
    453          {
   \                     BSP_LED_On:
   \   00000000   80B5               PUSH     {R7,LR}
    454              switch (led) {
   \   00000002   1028               CMP      R0,#+16
   \   00000004   6BD8               BHI.N    ??BSP_LED_On_1
   \   00000006   DFE800F0           TBB      [PC, R0]
   \                     ??BSP_LED_On_0:
   \   0000000A   096A6A6A           DC8      +9,+106,+106,+106
   \   0000000E   6A1A2128           DC8      +106,+26,+33,+40
   \   00000012   2E343B42           DC8      +46,+52,+59,+66
   \   00000016   4950575E           DC8      +73,+80,+87,+94
   \   0000001A   6500               DC8      +101,+0
    455                  case 0:
    456                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LEDS);
   \                     ??BSP_LED_On_2:
   \   0000001C   4FF4C061           MOV      R1,#+1536
   \   00000020   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000022   ........           BL       GPIO_ResetBits
    457                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LEDS);
   \   00000026   4FF6C041           MOVW     R1,#+64704
   \   0000002A   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   0000002C   ........           BL       GPIO_ResetBits
    458          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    459                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LEDS);
   \   00000030   C021               MOVS     R1,#+192
   \   00000032   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   00000036   BDE80440           POP      {R2,LR}
   \   0000003A   ........           B.W      GPIO_ResetBits
    460          #endif
    461                       break;
    462          
    463          #if (BSP_CFG_LED_SPI1_EN == DEF_ENABLED)
    464                  case 1:
    465                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LED1);
    466                       break;
    467          
    468                  case 2:
    469                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LED2);
    470                       break;
    471          
    472                  case 3:
    473                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LED3);
    474                       break;
    475          
    476                  case 4:
    477                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LED4);
    478                       break;
    479          #endif
    480          
    481                  case 5:
    482                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LED5);
   \                     ??BSP_LED_On_3:
   \   0000003E   4FF40071           MOV      R1,#+512
   \   00000042   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000044   BDE80440           POP      {R2,LR}
   \   00000048   ........           B.W      GPIO_ResetBits
    483                       break;
    484          
    485                  case 6:
    486                       GPIO_ResetBits(GPIOA, BSP_GPIOA_LED6);
   \                     ??BSP_LED_On_4:
   \   0000004C   4FF48061           MOV      R1,#+1024
   \   00000050   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000052   BDE80440           POP      {R2,LR}
   \   00000056   ........           B.W      GPIO_ResetBits
    487                       break;
    488          
    489                  case 7:
    490                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED7);
   \                     ??BSP_LED_On_5:
   \   0000005A   4021               MOVS     R1,#+64
   \   0000005C   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   0000005E   BDE80440           POP      {R2,LR}
   \   00000062   ........           B.W      GPIO_ResetBits
    491                       break;
    492          
    493                  case 8:
    494                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED8);
   \                     ??BSP_LED_On_6:
   \   00000066   8021               MOVS     R1,#+128
   \   00000068   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   0000006A   BDE80440           POP      {R2,LR}
   \   0000006E   ........           B.W      GPIO_ResetBits
    495                       break;
    496          
    497                  case 9:
    498                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED9);
   \                     ??BSP_LED_On_7:
   \   00000072   4FF48061           MOV      R1,#+1024
   \   00000076   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000078   BDE80440           POP      {R2,LR}
   \   0000007C   ........           B.W      GPIO_ResetBits
    499                       break;
    500          
    501                  case 10:
    502                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED10);
   \                     ??BSP_LED_On_8:
   \   00000080   4FF40061           MOV      R1,#+2048
   \   00000084   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000086   BDE80440           POP      {R2,LR}
   \   0000008A   ........           B.W      GPIO_ResetBits
    503                       break;
    504          
    505          #if (BSP_CFG_LED_SPI2_EN == DEF_ENABLED)
    506                  case 11:
    507                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED11);
   \                     ??BSP_LED_On_9:
   \   0000008E   4FF48051           MOV      R1,#+4096
   \   00000092   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000094   BDE80440           POP      {R2,LR}
   \   00000098   ........           B.W      GPIO_ResetBits
    508                       break;
    509          
    510                  case 12:
    511                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED12);
   \                     ??BSP_LED_On_10:
   \   0000009C   4FF40051           MOV      R1,#+8192
   \   000000A0   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   000000A2   BDE80440           POP      {R2,LR}
   \   000000A6   ........           B.W      GPIO_ResetBits
    512                       break;
    513          
    514                  case 13:
    515                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED13);
   \                     ??BSP_LED_On_11:
   \   000000AA   4FF48041           MOV      R1,#+16384
   \   000000AE   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   000000B0   BDE80440           POP      {R2,LR}
   \   000000B4   ........           B.W      GPIO_ResetBits
    516                       break;
    517          
    518                  case 14:
    519                       GPIO_ResetBits(GPIOB, BSP_GPIOB_LED14);
   \                     ??BSP_LED_On_12:
   \   000000B8   4FF40041           MOV      R1,#+32768
   \   000000BC   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   000000BE   BDE80440           POP      {R2,LR}
   \   000000C2   ........           B.W      GPIO_ResetBits
    520                       break;
    521          #endif
    522          
    523          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    524                  case 15:
    525                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED15);
   \                     ??BSP_LED_On_13:
   \   000000C6   4021               MOVS     R1,#+64
   \   000000C8   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   000000CC   BDE80440           POP      {R2,LR}
   \   000000D0   ........           B.W      GPIO_ResetBits
    526                       break;
    527          
    528                  case 16:
    529                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED16);
   \                     ??BSP_LED_On_14:
   \   000000D4   8021               MOVS     R1,#+128
   \   000000D6   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   000000DA   ........           BL       GPIO_ResetBits
    530                       break;
    531          #endif
    532          
    533                  default:
    534                       break;
    535              }
    536          }
   \                     ??BSP_LED_On_1:
   \   000000DE   01BD               POP      {R0,PC}          ;; return
    537          
    538          
    539          /*
    540          *********************************************************************************************************
    541          *                                              BSP_LED_Off()
    542          *
    543          * Description : Turn OFF any or all the LEDs on the board.
    544          *
    545          * Argument(s) : led     The ID of the LED to control:
    546          *
    547          *                       0    turns OFF ALL the LEDs
    548          *                       1    turns OFF user LED1  on the board
    549          *                       2    turns OFF user LED2  on the board
    550          *                             .
    551          *                             .
    552          *                             .
    553          *                       16   turns OFF user LED16 on the board
    554          *
    555          * Return(s)   : none.
    556          *
    557          * Caller(s)   : Application.
    558          *
    559          * Note(s)     : none.
    560          *********************************************************************************************************
    561          */
    562          

   \                                 In section .text, align 4, keep-with-next
    563          void  BSP_LED_Off (CPU_INT08U led)
    564          {
   \                     BSP_LED_Off:
   \   00000000   80B5               PUSH     {R7,LR}
    565              switch (led) {
   \   00000002   1028               CMP      R0,#+16
   \   00000004   69D8               BHI.N    ??BSP_LED_Off_1
   \   00000006   DFE800F0           TBB      [PC, R0]
   \                     ??BSP_LED_Off_0:
   \   0000000A   09686868           DC8      +9,+104,+104,+104
   \   0000000E   681A2128           DC8      +104,+26,+33,+40
   \   00000012   2E343B42           DC8      +46,+52,+59,+66
   \   00000016   4950575E           DC8      +73,+80,+87,+94
   \   0000001A   6400               DC8      +100,+0
    566                  case 0:
    567                       GPIO_SetBits(GPIOA, BSP_GPIOA_LEDS);
   \                     ??BSP_LED_Off_2:
   \   0000001C   4FF4C061           MOV      R1,#+1536
   \   00000020   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000022   ........           BL       GPIO_SetBits
    568                       GPIO_SetBits(GPIOB, BSP_GPIOB_LEDS);
   \   00000026   4FF6C041           MOVW     R1,#+64704
   \   0000002A   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   0000002C   ........           BL       GPIO_SetBits
    569          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    570                       GPIO_SetBits(GPIOC, BSP_GPIOC_LEDS);
   \   00000030   C021               MOVS     R1,#+192
   \   00000032   ........           LDR.W    R0,??DataTable60  ;; 0x40011000
   \   00000036   BDE80440           POP      {R2,LR}
   \   0000003A   ........           B.W      GPIO_SetBits
    571          #endif
    572                       break;
    573          
    574          #if (BSP_CFG_LED_SPI1_EN == DEF_ENABLED)
    575                  case 1:
    576                       GPIO_SetBits(GPIOA, BSP_GPIOA_LED1);
    577                       break;
    578          
    579                  case 2:
    580                       GPIO_SetBits(GPIOA, BSP_GPIOA_LED2);
    581                       break;
    582          
    583                  case 3:
    584                       GPIO_SetBits(GPIOA, BSP_GPIOA_LED3);
    585                       break;
    586          
    587                  case 4:
    588                       GPIO_SetBits(GPIOA, BSP_GPIOA_LED4);
    589                       break;
    590          #endif
    591          
    592                  case 5:
    593                       GPIO_SetBits(GPIOA, BSP_GPIOA_LED5);
   \                     ??BSP_LED_Off_3:
   \   0000003E   4FF40071           MOV      R1,#+512
   \   00000042   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000044   BDE80440           POP      {R2,LR}
   \   00000048   ........           B.W      GPIO_SetBits
    594                       break;
    595          
    596                  case 6:
    597                       GPIO_SetBits(GPIOA, BSP_GPIOA_LED6);
   \                     ??BSP_LED_Off_4:
   \   0000004C   4FF48061           MOV      R1,#+1024
   \   00000050   ....               LDR.N    R0,??DataTable43  ;; 0x40010800
   \   00000052   BDE80440           POP      {R2,LR}
   \   00000056   ........           B.W      GPIO_SetBits
    598                       break;
    599          
    600                  case 7:
    601                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED7);
   \                     ??BSP_LED_Off_5:
   \   0000005A   4021               MOVS     R1,#+64
   \   0000005C   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   0000005E   BDE80440           POP      {R2,LR}
   \   00000062   ........           B.W      GPIO_SetBits
    602                       break;
    603          
    604                  case 8:
    605                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED8);
   \                     ??BSP_LED_Off_6:
   \   00000066   8021               MOVS     R1,#+128
   \   00000068   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   0000006A   BDE80440           POP      {R2,LR}
   \   0000006E   ........           B.W      GPIO_SetBits
    606                       break;
    607          
    608                  case 9:
    609                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED9);
   \                     ??BSP_LED_Off_7:
   \   00000072   4FF48061           MOV      R1,#+1024
   \   00000076   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000078   BDE80440           POP      {R2,LR}
   \   0000007C   ........           B.W      GPIO_SetBits
    610                       break;
    611          
    612                  case 10:
    613                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED10);
   \                     ??BSP_LED_Off_8:
   \   00000080   4FF40061           MOV      R1,#+2048
   \   00000084   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000086   BDE80440           POP      {R2,LR}
   \   0000008A   ........           B.W      GPIO_SetBits
    614                       break;
    615          
    616          #if (BSP_CFG_LED_SPI2_EN == DEF_ENABLED)
    617                  case 11:
    618                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED11);
   \                     ??BSP_LED_Off_9:
   \   0000008E   4FF48051           MOV      R1,#+4096
   \   00000092   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000094   BDE80440           POP      {R2,LR}
   \   00000098   ........           B.W      GPIO_SetBits
    619                       break;
    620          
    621                  case 12:
    622                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED12);
   \                     ??BSP_LED_Off_10:
   \   0000009C   4FF40051           MOV      R1,#+8192
   \   000000A0   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   000000A2   BDE80440           POP      {R2,LR}
   \   000000A6   ........           B.W      GPIO_SetBits
    623                       break;
    624          
    625                  case 13:
    626                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED13);
   \                     ??BSP_LED_Off_11:
   \   000000AA   4FF48041           MOV      R1,#+16384
   \   000000AE   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   000000B0   BDE80440           POP      {R2,LR}
   \   000000B4   ........           B.W      GPIO_SetBits
    627                       break;
    628          
    629                  case 14:
    630                       GPIO_SetBits(GPIOB, BSP_GPIOB_LED14);
   \                     ??BSP_LED_Off_12:
   \   000000B8   4FF40041           MOV      R1,#+32768
   \   000000BC   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   000000BE   BDE80440           POP      {R2,LR}
   \   000000C2   ........           B.W      GPIO_SetBits
    631                       break;
    632          #endif
    633          
    634          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    635                  case 15:
    636                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED15);
   \                     ??BSP_LED_Off_13:
   \   000000C6   4021               MOVS     R1,#+64
   \   000000C8   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   000000CA   BDE80440           POP      {R2,LR}
   \   000000CE   ........           B.W      GPIO_SetBits
    637                       break;
    638          
    639                  case 16:
    640                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED16);
   \                     ??BSP_LED_Off_14:
   \   000000D2   8021               MOVS     R1,#+128
   \   000000D4   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   000000D6   ........           BL       GPIO_SetBits
    641                       break;
    642          #endif
    643          
    644                  default:
    645                       break;
    646              }
    647          }
   \                     ??BSP_LED_Off_1:
   \   000000DA   01BD               POP      {R0,PC}          ;; return
    648          
    649          
    650          /*
    651          *********************************************************************************************************
    652          *                                            BSP_LED_Toggle()
    653          *
    654          * Description : TOGGLE any or all the LEDs on the board.
    655          *
    656          * Argument(s) : led     The ID of the LED to control:
    657          *
    658          *                       0    TOGGLE ALL the LEDs
    659          *                       1    TOGGLE user LED1  on the board
    660          *                       2    TOGGLE user LED2  on the board
    661          *                             .
    662          *                             .
    663          *                             .
    664          *                       16   TOGGLE user LED16 on the board
    665          *
    666          * Return(s)   : none.
    667          *
    668          * Caller(s)   : Application.
    669          *
    670          * Note(s)     : none.
    671          *********************************************************************************************************
    672          */
    673          

   \                                 In section .text, align 4, keep-with-next
    674          void  BSP_LED_Toggle (CPU_INT08U led)
    675          {
   \                     BSP_LED_Toggle:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0646               MOV      R6,R0
    676              CPU_INT32U  pins;
    677          
    678              switch (led) {
   \   00000004   1028               CMP      R0,#+16
   \   00000006   00F29080           BHI.W    ??BSP_LED_Toggle_1
   \   0000000A   DFE800F0           TBB      [PC, R0]
   \                     ??BSP_LED_Toggle_0:
   \   0000000E   098E8E8E           DC8      +9,+142,+142,+142
   \   00000012   8E404055           DC8      +142,+64,+64,+85
   \   00000016   55656565           DC8      +85,+101,+101,+101
   \   0000001A   6565657A           DC8      +101,+101,+101,+122
   \   0000001E   7A00               DC8      +122,+0
    679                  case 0:
    680                       pins =  GPIO_ReadOutputData(GPIOA);
   \                     ??BSP_LED_Toggle_2:
   \   00000020   ....               LDR.N    R7,??DataTable43  ;; 0x40010800
   \   00000022   3846               MOV      R0,R7
   \   00000024   ........           BL       GPIO_ReadOutputData
    681                       pins ^= BSP_GPIOA_LEDS;
   \   00000028   80F4C064           EOR      R4,R0,#0x600
    682                       GPIO_SetBits(  GPIOA,   pins  & BSP_GPIOA_LEDS);
   \   0000002C   04F4C061           AND      R1,R4,#0x600
   \   00000030   3846               MOV      R0,R7
   \   00000032   ........           BL       GPIO_SetBits
    683                       GPIO_ResetBits(GPIOA, (~pins) & BSP_GPIOA_LEDS);
   \   00000036   E043               MVNS     R0,R4
   \   00000038   00F4C061           AND      R1,R0,#0x600
   \   0000003C   3846               MOV      R0,R7
   \   0000003E   ........           BL       GPIO_ResetBits
    684          
    685                       pins =  GPIO_ReadOutputData(GPIOB);
   \   00000042   ....               LDR.N    R4,??DataTable50  ;; 0x40010c00
   \   00000044   2046               MOV      R0,R4
   \   00000046   ........           BL       GPIO_ReadOutputData
    686                       pins ^= BSP_GPIOB_LEDS;
   \   0000004A   4FF6C045           MOVW     R5,#+64704
   \   0000004E   85EA0006           EOR      R6,R5,R0
    687                       GPIO_SetBits(  GPIOB,   pins  & BSP_GPIOB_LEDS);
   \   00000052   05EA0601           AND      R1,R5,R6
   \   00000056   2046               MOV      R0,R4
   \   00000058   ........           BL       GPIO_SetBits
    688                       GPIO_ResetBits(GPIOB, (~pins) & BSP_GPIOB_LEDS);
   \   0000005C   F043               MVNS     R0,R6
   \   0000005E   05EA0001           AND      R1,R5,R0
   \   00000062   2046               MOV      R0,R4
   \   00000064   ........           BL       GPIO_ResetBits
    689          
    690          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    691                       pins =  GPIO_ReadOutputData(GPIOA);
   \   00000068   3846               MOV      R0,R7
   \   0000006A   ........           BL       GPIO_ReadOutputData
    692                       pins ^= BSP_GPIOC_LEDS;
   \   0000006E   80F0C005           EOR      R5,R0,#0xC0
    693                       GPIO_SetBits(  GPIOC,   pins  & BSP_GPIOC_LEDS);
   \   00000072   ....               LDR.N    R4,??DataTable60  ;; 0x40011000
   \   00000074   05F0C001           AND      R1,R5,#0xC0
   \   00000078   2046               MOV      R0,R4
   \   0000007A   ........           BL       GPIO_SetBits
    694                       GPIO_ResetBits(GPIOC, (~pins) & BSP_GPIOC_LEDS);
   \   0000007E   E843               MVNS     R0,R5
   \   00000080   00F0C001           AND      R1,R0,#0xC0
   \   00000084   2046               MOV      R0,R4
   \   00000086   BDE8F440           POP      {R2,R4-R7,LR}
   \   0000008A   ........           B.W      GPIO_ResetBits
    695          #endif
    696                       break;
    697          
    698          #if (BSP_CFG_LED_SPI1_EN == DEF_ENABLED)
    699                  case 1:
    700                  case 2:
    701                  case 3:
    702                  case 4:
    703                      pins = GPIO_ReadOutputData(GPIOA);
    704                      if ((pins & (1 << (led + 3))) == 0) {
    705                           GPIO_SetBits(  GPIOA, (1 << (led + 3)));
    706                       } else {
    707                           GPIO_ResetBits(GPIOA, (1 << (led + 3)));
    708                       }
    709                      break;
    710          #endif
    711          
    712                  case 5:
    713                  case 6:
    714                      pins = GPIO_ReadOutputData(GPIOA);
   \                     ??BSP_LED_Toggle_3:
   \   0000008E   ....               LDR.N    R7,??DataTable43  ;; 0x40010800
   \   00000090   3846               MOV      R0,R7
   \   00000092   ........           BL       GPIO_ReadOutputData
   \   00000096   0546               MOV      R5,R0
    715                      if ((pins & (1 << (led + 4))) == 0) {
   \   00000098   0120               MOVS     R0,#+1
   \   0000009A   311D               ADDS     R1,R6,#+4
   \   0000009C   00FA01F1           LSL      R1,R0,R1
   \   000000A0   2942               TST      R1,R5
   \   000000A2   89B2               UXTH     R1,R1
   \   000000A4   3846               MOV      R0,R7
   \   000000A6   03D1               BNE.N    ??BSP_LED_Toggle_4
    716                           GPIO_SetBits(  GPIOA, (1 << (led + 4)));
   \   000000A8   BDE8F440           POP      {R2,R4-R7,LR}
   \   000000AC   ........           B.W      GPIO_SetBits
    717                       } else {
    718                           GPIO_ResetBits(GPIOA, (1 << (led + 4)));
   \                     ??BSP_LED_Toggle_4:
   \   000000B0   BDE8F440           POP      {R2,R4-R7,LR}
   \   000000B4   ........           B.W      GPIO_ResetBits
    719                       }
    720                      break;
    721          
    722                  case 7:
    723                  case 8:
    724                      pins = GPIO_ReadOutputData(GPIOB);
   \                     ??BSP_LED_Toggle_5:
   \   000000B8   ....               LDR.N    R4,??DataTable50  ;; 0x40010c00
   \   000000BA   2046               MOV      R0,R4
   \   000000BC   ........           BL       GPIO_ReadOutputData
    725                      if ((pins & (1 << (led - 1))) == 0) {
   \   000000C0   0121               MOVS     R1,#+1
   \   000000C2   721E               SUBS     R2,R6,#+1
   \   000000C4   9140               LSLS     R1,R1,R2
   \   000000C6   0142               TST      R1,R0
   \   000000C8   89B2               UXTH     R1,R1
   \   000000CA   2046               MOV      R0,R4
   \   000000CC   02D1               BNE.N    ??BSP_LED_Toggle_6
    726                           GPIO_SetBits(  GPIOB, (1 << (led - 1)));
   \   000000CE   ........           BL       GPIO_SetBits
   \   000000D2   01E0               B.N      ??BSP_LED_Toggle_7
    727                       } else {
    728                           GPIO_ResetBits(GPIOB, (1 << (led - 1)));
   \                     ??BSP_LED_Toggle_6:
   \   000000D4   ........           BL       GPIO_ResetBits
    729                       }
    730          
    731          
    732                  case 9:
    733                  case 10:
    734          #if (BSP_CFG_LED_SPI2_EN == DEF_ENABLED)
    735                  case 11:
    736                  case 12:
    737                  case 13:
    738                  case 14:
    739          #endif
    740                       pins = GPIO_ReadOutputData(GPIOB);
   \                     ??BSP_LED_Toggle_7:
   \   000000D8   ....               LDR.N    R4,??DataTable50  ;; 0x40010c00
   \   000000DA   2046               MOV      R0,R4
   \   000000DC   ........           BL       GPIO_ReadOutputData
   \   000000E0   0546               MOV      R5,R0
    741                       if ((pins & (1 << (led + 1))) == 0) {
   \   000000E2   0120               MOVS     R0,#+1
   \   000000E4   711C               ADDS     R1,R6,#+1
   \   000000E6   00FA01F1           LSL      R1,R0,R1
   \   000000EA   2942               TST      R1,R5
   \   000000EC   89B2               UXTH     R1,R1
   \   000000EE   2046               MOV      R0,R4
   \   000000F0   03D1               BNE.N    ??BSP_LED_Toggle_8
    742                           GPIO_SetBits(  GPIOB, (1 << (led + 1)));
   \   000000F2   BDE8F440           POP      {R2,R4-R7,LR}
   \   000000F6   ........           B.W      GPIO_SetBits
    743                       } else {
    744                           GPIO_ResetBits(GPIOB, (1 << (led + 1)));
   \                     ??BSP_LED_Toggle_8:
   \   000000FA   BDE8F440           POP      {R2,R4-R7,LR}
   \   000000FE   ........           B.W      GPIO_ResetBits
    745                       }
    746                      break;
    747          
    748          #if (BSP_CFG_LED_PIOC_EN == DEF_ENABLED)
    749                  case 15:
    750                  case 16:
    751                       pins = GPIO_ReadOutputData(GPIOC);
   \                     ??BSP_LED_Toggle_9:
   \   00000102   ....               LDR.N    R4,??DataTable60  ;; 0x40011000
   \   00000104   2046               MOV      R0,R4
   \   00000106   ........           BL       GPIO_ReadOutputData
   \   0000010A   0546               MOV      R5,R0
    752                       if ((pins & (1 << (led - 9))) == 0) {
   \   0000010C   0120               MOVS     R0,#+1
   \   0000010E   A6F10901           SUB      R1,R6,#+9
   \   00000112   00FA01F1           LSL      R1,R0,R1
   \   00000116   2942               TST      R1,R5
   \   00000118   89B2               UXTH     R1,R1
   \   0000011A   2046               MOV      R0,R4
   \   0000011C   03D1               BNE.N    ??BSP_LED_Toggle_10
    753                           GPIO_SetBits(  GPIOC, (1 << (led - 9)));
   \   0000011E   BDE8F440           POP      {R2,R4-R7,LR}
   \   00000122   ........           B.W      GPIO_SetBits
    754                       } else {
    755                           GPIO_ResetBits(GPIOC, (1 << (led - 9)));
   \                     ??BSP_LED_Toggle_10:
   \   00000126   ........           BL       GPIO_ResetBits
    756                       }
    757                      break;
    758          #endif
    759          
    760                  default:
    761                       break;
    762              }
    763          }
   \                     ??BSP_LED_Toggle_1:
   \   0000012A   F1BD               POP      {R0,R4-R7,PC}    ;; return
    764          
    765          
    766          /*
    767          *********************************************************************************************************
    768          *********************************************************************************************************
    769          *                                           LCD LIGHT FUNCTIONS
    770          *********************************************************************************************************
    771          *********************************************************************************************************
    772          */
    773          
    774          /*
    775          *********************************************************************************************************
    776          *                                           BSP_LCD_LightInit()
    777          *
    778          * Description : Initialize the LCD backlight.
    779          *
    780          * Argument(s) : none.
    781          *
    782          * Return(s)   : none.
    783          *
    784          * Caller(s)   : BSP_Init().
    785          *
    786          * Note(s)     : none.
    787          *********************************************************************************************************
    788          */
    789          

   \                                 In section .text, align 2, keep-with-next
    790          static  void  BSP_LCD_LightInit (void)
    791          {
   \                     BSP_LCD_LightInit:
   \   00000000   80B5               PUSH     {R7,LR}
    792              GPIO_InitTypeDef  gpio_init;
    793          
    794          
    795              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0820               MOVS     R0,#+8
   \   00000006   ........           BL       RCC_APB2PeriphClockCmd
    796          
    797              gpio_init.GPIO_Pin   = BSP_GPIOB_LCD_LIGHT;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   ADF80000           STRH     R0,[SP, #+0]
    798              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000010   0320               MOVS     R0,#+3
   \   00000012   8DF80200           STRB     R0,[SP, #+2]
    799              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000016   1020               MOVS     R0,#+16
   \   00000018   8DF80300           STRB     R0,[SP, #+3]
    800              GPIO_Init(GPIOB, &gpio_init);
   \   0000001C   00A9               ADD      R1,SP,#+0
   \   0000001E   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000020   ........           BL       GPIO_Init
    801          }
   \   00000024   01BD               POP      {R0,PC}          ;; return
    802          
    803          
    804          /*
    805          *********************************************************************************************************
    806          *                                            BSP_LCD_LightOn()
    807          *
    808          * Description : Turn on the LCD backlight.
    809          *
    810          * Argument(s) : none.
    811          *
    812          * Return(s)   : none.
    813          *
    814          * Caller(s)   : Application.
    815          *
    816          * Note(s)     : none.
    817          *********************************************************************************************************
    818          */
    819          

   \                                 In section .text, align 2, keep-with-next
    820          void  BSP_LCD_LightOn (void)
    821          {
    822              GPIO_ResetBits(GPIOB, BSP_GPIOB_LCD_LIGHT);
   \                     BSP_LCD_LightOn:
   \   00000000   0121               MOVS     R1,#+1
   \   00000002   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000004   ........           B.W      GPIO_ResetBits
    823          }
    824          
    825          
    826          /*
    827          *********************************************************************************************************
    828          *                                           BSP_LCD_LightOff()
    829          *
    830          * Description : Turn off the LCD backlight.
    831          *
    832          * Argument(s) : none.
    833          *
    834          * Return(s)   : none.
    835          *
    836          * Caller(s)   : Application.
    837          *
    838          * Note(s)     : none.
    839          *********************************************************************************************************
    840          */
    841          

   \                                 In section .text, align 2, keep-with-next
    842          void  BSP_LCD_LightOff (void)
    843          {
    844              GPIO_SetBits(GPIOB, BSP_GPIOB_LCD_LIGHT);
   \                     BSP_LCD_LightOff:
   \   00000000   0121               MOVS     R1,#+1
   \   00000002   ....               LDR.N    R0,??DataTable50  ;; 0x40010c00
   \   00000004   ........           B.W      GPIO_SetBits
    845          }
    846          
    847          
    848          /*
    849          *********************************************************************************************************
    850          *                                          BSP_LCD_LightToggle()
    851          *
    852          * Description : Toggle the LCD backlight
    853          *
    854          * Arguments   : none.
    855          *
    856          * Return(s)   : none.
    857          *
    858          * Caller(s)   : Application.
    859          *
    860          * Note(s)     : none.
    861          *********************************************************************************************************
    862          */
    863          

   \                                 In section .text, align 2, keep-with-next
    864          void  BSP_LCD_LightToggle (void)
    865          {
   \                     BSP_LCD_LightToggle:
   \   00000000   10B5               PUSH     {R4,LR}
    866              CPU_INT32U  pins;
    867          
    868          
    869              pins = GPIO_ReadOutputData(GPIOB);
   \   00000002   ....               LDR.N    R4,??DataTable50  ;; 0x40010c00
   \   00000004   2046               MOV      R0,R4
   \   00000006   ........           BL       GPIO_ReadOutputData
    870              if ((pins & BSP_GPIOB_LCD_LIGHT) == 0) {
   \   0000000A   10F0010F           TST      R0,#0x1
   \   0000000E   05D1               BNE.N    ??BSP_LCD_LightToggle_0
    871                  GPIO_SetBits(  GPIOB, BSP_GPIOB_LCD_LIGHT);
   \   00000010   0121               MOVS     R1,#+1
   \   00000012   2046               MOV      R0,R4
   \   00000014   BDE81040           POP      {R4,LR}
   \   00000018   ........           B.W      GPIO_SetBits
    872              } else {
    873                  GPIO_ResetBits(GPIOB, BSP_GPIOB_LCD_LIGHT);
   \                     ??BSP_LCD_LightToggle_0:
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   2046               MOV      R0,R4
   \   00000020   BDE81040           POP      {R4,LR}
   \   00000024   ........           B.W      GPIO_ResetBits
    874              }
    875          }
    876          
    877          
    878          /*
    879          *********************************************************************************************************
    880          *********************************************************************************************************
    881          *                                              ADC FUNCTIONS
    882          *********************************************************************************************************
    883          *********************************************************************************************************
    884          */
    885          
    886          /*
    887          *********************************************************************************************************
    888          *                                             BSP_ADCS_Init()
    889          *
    890          * Description : Initialize the board's ADC
    891          *
    892          * Argument(s) : none.
    893          *
    894          * Return(s)   : none.
    895          *
    896          * Caller(s)   : BSP_Init().
    897          *
    898          * Note(s)     : none.
    899          *********************************************************************************************************
    900          */
    901          

   \                                 In section .text, align 2, keep-with-next
    902          static  void  BSP_ADCS_Init (void)
    903          {
   \                     BSP_ADCS_Init:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   86B0               SUB      SP,SP,#+24
    904              ADC_InitTypeDef   adc_init;
    905              GPIO_InitTypeDef  gpio_init;
    906          
    907          
    908              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   4FF40070           MOV      R0,#+512
   \   0000000A   ........           BL       RCC_APB2PeriphClockCmd
    909              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   1020               MOVS     R0,#+16
   \   00000012   ........           BL       RCC_APB2PeriphClockCmd
    910          
    911              gpio_init.GPIO_Pin  = GPIO_Pin_5;
   \   00000016   2020               MOVS     R0,#+32
   \   00000018   ADF80000           STRH     R0,[SP, #+0]
    912              gpio_init.GPIO_Mode = GPIO_Mode_AIN;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   8DF80300           STRB     R0,[SP, #+3]
    913              GPIO_Init(GPIOC, &gpio_init);
   \   00000022   00A9               ADD      R1,SP,#+0
   \   00000024   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   00000026   ........           BL       GPIO_Init
    914          
    915              adc_init.ADC_Mode               = ADC_Mode_Independent;
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   0190               STR      R0,[SP, #+4]
    916              adc_init.ADC_ScanConvMode       = DISABLE;
   \   0000002E   8DF80800           STRB     R0,[SP, #+8]
    917              adc_init.ADC_ContinuousConvMode = ENABLE;
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   8DF80900           STRB     R0,[SP, #+9]
    918              adc_init.ADC_ExternalTrigConv   = ADC_ExternalTrigConv_None;
   \   00000038   4FF46020           MOV      R0,#+917504
   \   0000003C   0390               STR      R0,[SP, #+12]
    919              adc_init.ADC_DataAlign          = ADC_DataAlign_Right;
   \   0000003E   0020               MOVS     R0,#+0
   \   00000040   0490               STR      R0,[SP, #+16]
    920              adc_init.ADC_NbrOfChannel       = 1;
   \   00000042   0120               MOVS     R0,#+1
   \   00000044   8DF81400           STRB     R0,[SP, #+20]
    921              ADC_Init(ADC1, &adc_init);
   \   00000048   ....               LDR.N    R4,??DataTable53  ;; 0x40012400
   \   0000004A   01A9               ADD      R1,SP,#+4
   \   0000004C   2046               MOV      R0,R4
   \   0000004E   ........           BL       ADC_Init
    922          
    923              ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 1, ADC_SampleTime_13Cycles5);
   \   00000052   0223               MOVS     R3,#+2
   \   00000054   0122               MOVS     R2,#+1
   \   00000056   0F21               MOVS     R1,#+15
   \   00000058   2046               MOV      R0,R4
   \   0000005A   ........           BL       ADC_RegularChannelConfig
    924              ADC_Cmd(ADC1, ENABLE);
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   2046               MOV      R0,R4
   \   00000062   ........           BL       ADC_Cmd
    925              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   00000066   0121               MOVS     R1,#+1
   \   00000068   2046               MOV      R0,R4
   \   0000006A   ........           BL       ADC_SoftwareStartConvCmd
    926          }
   \   0000006E   06B0               ADD      SP,SP,#+24
   \   00000070   10BD               POP      {R4,PC}          ;; return
    927          
    928          
    929          /*
    930          *********************************************************************************************************
    931          *                                           BSP_ADC_GetStatus()
    932          *
    933          * Description : This function initializes the board's ADC
    934          *
    935          * Argument(s) : adc             ID of the ADC to probe.  For this board, the only legitimate value is 1.
    936          *
    937          * Return(s)   : The numerator of the binary fraction representing the result of the latest ADC conversion.
    938          *               This value will be a 12-bit value between 0x0000 and 0x0FFF, inclusive.
    939          *
    940          * Caller(s)   : Application.
    941          *
    942          * Note(s)     : none.
    943          *********************************************************************************************************
    944          */
    945          

   \                                 In section .text, align 2, keep-with-next
    946          CPU_INT16U  BSP_ADC_GetStatus (CPU_INT08U  adc)
    947          {
   \                     BSP_ADC_GetStatus:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   0146               MOV      R1,R0
    948              CPU_INT16U  result;
    949          
    950          
    951              result = 0;
   \   00000004   0020               MOVS     R0,#+0
    952          
    953              if (adc == 1) {
   \   00000006   0129               CMP      R1,#+1
   \   00000008   02D1               BNE.N    ??BSP_ADC_GetStatus_0
    954                  result = ADC_GetConversionValue(ADC1);
   \   0000000A   ....               LDR.N    R0,??DataTable53  ;; 0x40012400
   \   0000000C   ........           BL       ADC_GetConversionValue
    955              }
    956          
    957              return (result);
   \                     ??BSP_ADC_GetStatus_0:
   \   00000010   02BD               POP      {R1,PC}          ;; return
    958          }
    959          
    960          
    961          /*
    962          *********************************************************************************************************
    963          *********************************************************************************************************
    964          *                                              LCD FUNCTIONS
    965          *********************************************************************************************************
    966          *********************************************************************************************************
    967          */
    968          
    969          /*
    970          *********************************************************************************************************
    971          *                                              DispDataWr()
    972          *
    973          * Description : Send a single byte to the display device.
    974          *
    975          * Arguments   : data            Byte to send to the display device.
    976          *
    977          * Returns     : none.
    978          *
    979          * Caller(s)   : uC/LCD
    980          *
    981          * Notes       : none.
    982          *********************************************************************************************************
    983          */
    984          
    985          #ifdef DISP_MODULE_PRESENT

   \                                 In section .text, align 2, keep-with-next
    986          void  DispDataWr (CPU_INT08U data)
    987          {
   \                     DispDataWr:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0546               MOV      R5,R0
    988              CPU_INT32U  value;
    989          
    990          
    991              BSP_DispRW_Low();                                           /* Set R/W write LOW to write to the LCD module         */
   \   00000004   ........           BL       BSP_DispRW_Low
    992          
    993              BSP_DispE_High();                                           /* Write the UPPER nibble to the LCD module             */
   \   00000008   ........           BL       BSP_DispE_High
   \   0000000C   2C09               LSRS     R4,R5,#+4
   \   0000000E   ....               LDR.N    R6,??DataTable60  ;; 0x40011000
   \   00000010   2146               MOV      R1,R4
   \   00000012   3046               MOV      R0,R6
    994          
    995              value =  ((data >> 4) & 0x0000000F);
    996              GPIO_SetBits(GPIOC, value);
   \   00000014   ........           BL       GPIO_SetBits
    997              value = (~(data >> 4) & 0x0000000F);
    998              GPIO_ResetBits(GPIOC, value);
   \   00000018   E043               MVNS     R0,R4
   \   0000001A   00F00F01           AND      R1,R0,#0xF
   \   0000001E   3046               MOV      R0,R6
   \   00000020   ........           BL       GPIO_ResetBits
    999          
   1000              DispDly_uS(1000);
   \   00000024   4FF47A70           MOV      R0,#+1000
   \   00000028   ........           BL       DispDly_uS
   1001              BSP_DispE_Low();
   \   0000002C   ........           BL       BSP_DispE_Low
   1002          
   1003              DispDly_uS(1000);                                           /* Write the LOWER nibble to the LCD module             */
   \   00000030   4FF47A70           MOV      R0,#+1000
   \   00000034   ........           BL       DispDly_uS
   1004              BSP_DispE_High();
   \   00000038   ........           BL       BSP_DispE_High
   1005          
   1006              value =  (data & 0x0000000F);
   1007              GPIO_SetBits(GPIOC, value);
   \   0000003C   05F00F01           AND      R1,R5,#0xF
   \   00000040   3046               MOV      R0,R6
   \   00000042   ........           BL       GPIO_SetBits
   1008              value = (~data & 0x0000000F);
   1009              GPIO_ResetBits(GPIOC, value);
   \   00000046   E843               MVNS     R0,R5
   \   00000048   00F00F01           AND      R1,R0,#0xF
   \   0000004C   3046               MOV      R0,R6
   \   0000004E   ........           BL       GPIO_ResetBits
   1010          
   1011              DispDly_uS(1000);
   \   00000052   4FF47A70           MOV      R0,#+1000
   \   00000056   ........           BL       DispDly_uS
   1012              BSP_DispE_Low();
   \   0000005A   BDE87040           POP      {R4-R6,LR}
   \   0000005E   ....               B.N      BSP_DispE_Low
   1013          }
   1014          
   1015          #if (DISP_BUS_WIDTH == 4)

   \                                 In section .text, align 2, keep-with-next
   1016          void  DispDataWrOneNibble (CPU_INT08U data)
   1017          {
   \                     DispDataWrOneNibble:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
   1018              CPU_INT32U  value;
   1019          
   1020          
   1021              BSP_DispRW_Low();                                           /* Set R/W write LOW to write to the LCD module         */
   \   00000004   ........           BL       BSP_DispRW_Low
   1022          
   1023              BSP_DispE_High();                                           /* Write the UPPER nibble to the LCD module             */
   \   00000008   ........           BL       BSP_DispE_High
   \   0000000C   2409               LSRS     R4,R4,#+4
   \   0000000E   ....               LDR.N    R5,??DataTable60  ;; 0x40011000
   \   00000010   2146               MOV      R1,R4
   \   00000012   2846               MOV      R0,R5
   1024          
   1025              value =  ((data >> 4) & 0x0F);
   1026              GPIO_SetBits(GPIOC, value);
   \   00000014   ........           BL       GPIO_SetBits
   1027              value = (~(data >> 4) & 0x0F);
   1028              GPIO_ResetBits(GPIOC, value);
   \   00000018   E043               MVNS     R0,R4
   \   0000001A   00F00F01           AND      R1,R0,#0xF
   \   0000001E   2846               MOV      R0,R5
   \   00000020   ........           BL       GPIO_ResetBits
   1029          
   1030              DispDly_uS(1000);
   \   00000024   4FF47A70           MOV      R0,#+1000
   \   00000028   ........           BL       DispDly_uS
   1031              BSP_DispE_Low();
   \   0000002C   BDE83140           POP      {R0,R4,R5,LR}
   \   00000030   ....               B.N      BSP_DispE_Low
   1032          }
   1033          #endif
   1034          
   1035          #endif
   1036          
   1037          
   1038          /*
   1039          *********************************************************************************************************
   1040          *                                              DispDly_uS()
   1041          *
   1042          * Description : Delay for the specified number of microseconds.
   1043          *
   1044          * Argument(s) : us          Number of microseconds
   1045          *
   1046          * Return(s)   : none.
   1047          *
   1048          * Caller(s)   : uC/LCD
   1049          *
   1050          * Notes       : none.
   1051          *********************************************************************************************************
   1052          */
   1053          
   1054          #ifdef DISP_MODULE_PRESENT

   \                                 In section .text, align 2, keep-with-next
   1055          void  DispDly_uS (CPU_INT32U us)
   1056          {
   \                     DispDly_uS:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0446               MOV      R4,R0
   1057              CPU_INT32U  us_per_tick;
   1058              CPU_INT32U  ticks;
   1059          
   1060          
   1061              us_per_tick = BSP_CPU_ClkFreq() / OS_TICKS_PER_SEC;
   \   00000004   ........           BL       BSP_CPU_ClkFreq
   \   00000008   4FF47A71           MOV      R1,#+1000
   \   0000000C   B0FBF1F0           UDIV     R0,R0,R1
   1062              ticks       = us / us_per_tick + 2;
   1063              OSTimeDly(ticks);
   \   00000010   B4FBF0F0           UDIV     R0,R4,R0
   \   00000014   801C               ADDS     R0,R0,#+2
   \   00000016   80B2               UXTH     R0,R0
   \   00000018   BDE81040           POP      {R4,LR}
   \   0000001C   ........           B.W      OSTimeDly
   1064          }
   1065          #endif
   1066          
   1067          
   1068          /*
   1069          *********************************************************************************************************
   1070          *                                             DispInitPort()
   1071          *
   1072          * Description : Initialize the I/O ports used by the display driver.
   1073          *
   1074          * Arguments   : none.
   1075          *
   1076          * Returns     : none.
   1077          *
   1078          * Caller(s)   : DispInit().
   1079          *
   1080          * Notes       : none.
   1081          *********************************************************************************************************
   1082          */
   1083          
   1084          #ifdef DISP_MODULE_PRESENT

   \                                 In section .text, align 2, keep-with-next
   1085          void  DispInitPort (void)
   1086          {
   \                     DispInitPort:
   \   00000000   80B5               PUSH     {R7,LR}
   1087              GPIO_InitTypeDef  gpio_init;
   1088          
   1089          
   1090              gpio_init.GPIO_Pin   = BSP_GPIOC_LCD_DB4 | BSP_GPIOC_LCD_DB5 | BSP_GPIOC_LCD_DB6 | BSP_GPIOC_LCD_DB7
   1091                                   | BSP_GPIOC_LCD_RS  | BSP_GPIOC_LCD_RW  | BSP_GPIOC_LCD_E;
   \   00000002   41F20F30           MOVW     R0,#+4879
   \   00000006   ADF80000           STRH     R0,[SP, #+0]
   1092              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000A   0320               MOVS     R0,#+3
   \   0000000C   8DF80200           STRB     R0,[SP, #+2]
   1093              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000010   1020               MOVS     R0,#+16
   \   00000012   8DF80300           STRB     R0,[SP, #+3]
   1094              GPIO_Init(GPIOC, &gpio_init);
   \   00000016   00A9               ADD      R1,SP,#+0
   \   00000018   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   0000001A   ........           BL       GPIO_Init
   1095          }
   \   0000001E   01BD               POP      {R0,PC}          ;; return
   1096          #endif
   1097          
   1098          
   1099          /*
   1100          *********************************************************************************************************
   1101          *                                               DispSel()
   1102          *
   1103          * Description : Change the Register Select control line to the LCD controller.
   1104          *
   1105          * Argument(s) : sel             Indicates whether command or data register should be selected:
   1106          *
   1107          *                                   DISP_SEL_CMD_REG    Select command register.
   1108          *                                   DISP_SEL_DATA_REG   Select data    register.
   1109          *
   1110          *
   1111          * Return(s)   : none.
   1112          *
   1113          * Caller(s)   : uC/LCD
   1114          *
   1115          * Notes       : none.
   1116          *********************************************************************************************************
   1117          */
   1118          
   1119          #ifdef DISP_MODULE_PRESENT

   \                                 In section .text, align 2, keep-with-next
   1120          void  DispSel (CPU_INT08U sel)
   1121          {
   1122              if (sel == DISP_SEL_CMD_REG) {
   \                     DispSel:
   \   00000000   ....               LDR.N    R2,??DataTable60  ;; 0x40011000
   \   00000002   0028               CMP      R0,#+0
   \   00000004   4FF48071           MOV      R1,#+256
   \   00000008   1046               MOV      R0,R2
   \   0000000A   01D1               BNE.N    ??DispSel_0
   1123                  GPIO_ResetBits(GPIOC, BSP_GPIOC_LCD_RS);                /* Select the command register (RS low)                     */
   \   0000000C   ........           B.W      GPIO_ResetBits
   1124              } else {
   1125                  GPIO_SetBits(GPIOC, BSP_GPIOC_LCD_RS);                  /* Select the data    register (RS high)                    */
   \                     ??DispSel_0:
   \   00000010   ........           B.W      GPIO_SetBits
   1126              }
   1127          }
   1128          #endif
   1129          
   1130          
   1131          /*
   1132          *********************************************************************************************************
   1133          *                                      DISPLAY CONTROL LINE FUNCTIONS
   1134          *********************************************************************************************************
   1135          */
   1136          
   1137          #ifdef DISP_MODULE_PRESENT

   \                                 In section .text, align 2, keep-with-next
   1138          static  void  BSP_DispE_High (void)
   1139          {
   1140              GPIO_SetBits(GPIOC, BSP_GPIOC_LCD_E);
   \                     BSP_DispE_High:
   \   00000000   4FF48051           MOV      R1,#+4096
   \   00000004   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   00000006   ........           B.W      GPIO_SetBits
   1141          }
   1142          
   1143          

   \                                 In section .text, align 2, keep-with-next
   1144          static  void  BSP_DispE_Low (void)
   1145          {
   1146              GPIO_ResetBits(GPIOC, BSP_GPIOC_LCD_E);
   \                     BSP_DispE_Low:
   \   00000000   4FF48051           MOV      R1,#+4096
   \   00000004   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   00000006   ........           B.W      GPIO_ResetBits
   1147          }
   1148          
   1149          

   \                                 In section .text, align 2, keep-with-next
   1150          static  void  BSP_DispRW_Low (void)
   1151          {
   1152              GPIO_ResetBits(GPIOC, BSP_GPIOC_LCD_RW);
   \                     BSP_DispRW_Low:
   \   00000000   4FF40071           MOV      R1,#+512
   \   00000004   ....               LDR.N    R0,??DataTable60  ;; 0x40011000
   \   00000006   ........           B.W      GPIO_ResetBits
   1153          }
   1154          #endif
   1155          
   1156          
   1157          /*
   1158          *********************************************************************************************************
   1159          *********************************************************************************************************
   1160          *                                           OS PROBE FUNCTIONS
   1161          *********************************************************************************************************
   1162          *********************************************************************************************************
   1163          */
   1164          
   1165          /*
   1166          *********************************************************************************************************
   1167          *                                           OSProbe_TmrInit()
   1168          *
   1169          * Description : Select & initialize a timer for use with the uC/Probe Plug-In for uC/OS-II.
   1170          *
   1171          * Argument(s) : none.
   1172          *
   1173          * Return(s)   : none.
   1174          *
   1175          * Caller(s)   : OSProbe_Init().
   1176          *
   1177          * Note(s)     : none.
   1178          *********************************************************************************************************
   1179          */
   1180          
   1181          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
   1182               (OS_PROBE_HOOKS_EN == 1))

   \                                 In section .text, align 2, keep-with-next
   1183          void  OSProbe_TmrInit (void)
   1184          {
   \                     OSProbe_TmrInit:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
   1185              TIM_TimeBaseInitTypeDef  tim_init;
   1186          
   1187          
   1188              tim_init.TIM_Period        = 0xFFFF;
   \   00000002   4FF6FF70           MOVW     R0,#+65535
   \   00000006   ADF80400           STRH     R0,[SP, #+4]
   1189              tim_init.TIM_Prescaler     = 0x00;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0090               STR      R0,[SP, #+0]
   1190              tim_init.TIM_ClockDivision = 0x0;
   \   0000000E   ADF80600           STRH     R0,[SP, #+6]
   1191              tim_init.TIM_CounterMode   = TIM_CounterMode_Up;
   1192          
   1193          #if (OS_PROBE_TIMER_SEL == 2)
   1194              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   0846               MOV      R0,R1
   \   00000016   ........           BL       RCC_APB1PeriphClockCmd
   1195          
   1196              TIM_TimeBaseInit(TIM2, &tim_init);
   \   0000001A   00A9               ADD      R1,SP,#+0
   \   0000001C   4FF08040           MOV      R0,#+1073741824
   \   00000020   ........           BL       TIM_TimeBaseInit
   1197              TIM_SetCounter(TIM2, 0);
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   4FF08040           MOV      R0,#+1073741824
   \   0000002A   ........           BL       TIM_SetCounter
   1198              TIM_PrescalerConfig(TIM2, 256, TIM_PSCReloadMode_Immediate);
   \   0000002E   0122               MOVS     R2,#+1
   \   00000030   4FF48071           MOV      R1,#+256
   \   00000034   4FF08040           MOV      R0,#+1073741824
   \   00000038   ........           BL       TIM_PrescalerConfig
   1199              TIM_Cmd(TIM2, ENABLE);
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   4FF08040           MOV      R0,#+1073741824
   \   00000042   ........           BL       TIM_Cmd
   1200          #elif (OS_PROBE_TIMER_SEL == 3)
   1201              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   1202          
   1203              TIM_TimeBaseInit(TIM3, &tim_init);
   1204              TIM_SetCounter(TIM3, 0);
   1205              TIM_PrescalerConfig(TIM3, 256, TIM_PSCReloadMode_Immediate);
   1206              TIM_Cmd(TIM3, ENABLE);
   1207          #elif (OS_PROBE_TIMER_SEL == 4)
   1208              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
   1209          
   1210              TIM_TimeBaseInit(TIM4, &tim_init);
   1211              TIM_SetCounter(TIM4, 0);
   1212              TIM_PrescalerConfig(TIM4, 256, TIM_PSCReloadMode_Immediate);
   1213              TIM_Cmd(TIM4, ENABLE);
   1214          #endif
   1215          }
   \   00000046   07BD               POP      {R0-R2,PC}       ;; return
   1216          #endif
   1217          
   1218          
   1219          /*
   1220          *********************************************************************************************************
   1221          *                                            OSProbe_TmrRd()
   1222          *
   1223          * Description : Read the current counts of a 16-bit free running timer.
   1224          *
   1225          * Argument(s) : none.
   1226          *
   1227          * Return(s)   : The 16-bit counts of the timer in a 32-bit variable.
   1228          *
   1229          * Caller(s)   : OSProbe_TimeGetCycles().
   1230          *
   1231          * Note(s)     : none.
   1232          *********************************************************************************************************
   1233          */
   1234          
   1235          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
   1236               (OS_PROBE_HOOKS_EN == 1))

   \                                 In section .text, align 2, keep-with-next
   1237          CPU_INT32U  OSProbe_TmrRd (void)
   1238          {
   1239          #if (OS_PROBE_TIMER_SEL == 2)
   1240          
   1241              return ((CPU_INT32U)TIM_GetCounter(TIM2));
   \                     OSProbe_TmrRd:
   \   00000000   4FF08040           MOV      R0,#+1073741824
   \   00000004   ........           B.W      TIM_GetCounter
   1242          
   1243          #elif (OS_PROBE_TIMER_SEL == 3)
   1244          
   1245              return ((CPU_INT32U)TIM_GetCounter(TIM3));
   1246          
   1247          #elif (OS_PROBE_TIMER_SEL == 4)
   1248          
   1249              return ((CPU_INT32U)TIM_GetCounter(TIM4));
   1250          
   1251          #endif
   1252          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   00080140           DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   000C0140           DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \   00000000   00240140           DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60:
   \   00000000   00100140           DC32     0x40011000
   1253          #endif

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     BSP_ADCS_Init             32
     BSP_ADC_GetStatus          8
     BSP_CPU_ClkFreq           24
     BSP_DispE_High             8
     BSP_DispE_Low              8
     BSP_DispRW_Low             8
     BSP_Init                   8
     BSP_LCD_LightInit          8
     BSP_LCD_LightOff           8
     BSP_LCD_LightOn            8
     BSP_LCD_LightToggle        8
     BSP_LED_Init               8
     BSP_LED_Off                8
     BSP_LED_On                 8
     BSP_LED_Toggle            24
     BSP_PB_GetStatus           8
     BSP_PB_Init                8
     DispDataWr                16
     DispDataWrOneNibble       16
     DispDly_uS                 8
     DispInitPort               8
     DispSel                    8
     OSProbe_TmrInit           16
     OSProbe_TmrRd              8
     OS_CPU_SysTickClkFreq      8


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     BSP_Init               118
     BSP_CPU_ClkFreq         16
     OS_CPU_SysTickClkFreq    2
     BSP_PB_Init             96
     BSP_PB_GetStatus        98
     BSP_LED_Init           114
     BSP_LED_On             224
     BSP_LED_Off            220
     BSP_LED_Toggle         300
     BSP_LCD_LightInit       38
     BSP_LCD_LightOn          8
     BSP_LCD_LightOff         8
     BSP_LCD_LightToggle     40
     BSP_ADCS_Init          114
     BSP_ADC_GetStatus       18
     DispDataWr              96
     DispDataWrOneNibble     50
     DispDly_uS              32
     DispInitPort            32
     DispSel                 20
     BSP_DispE_High          10
     BSP_DispE_Low           10
     BSP_DispRW_Low          10
     OSProbe_TmrInit         72
     OSProbe_TmrRd            8
     ??DataTable43            4
     ??DataTable50            4
     ??DataTable53            4
     ??DataTable60            4

 
 1 770 bytes in section .text
 
 1 770 bytes of CODE memory

Errors: none
Warnings: none
