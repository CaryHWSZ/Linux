###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     28/Dec/2014  20:59:03 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_task.c                                 #
#    Command line =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_task.c -lCN                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\ -o   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\       #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "F:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\S #
#                    oftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\ -I      #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\BSP\ -I       #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\C #
#                    PU\ST\STM32\inc\ -I C:\Users\Administrator\Desktop\uCOS- #
#                    II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe- #
#                    LCD\..\..\..\..\..\uC-CPU\ -I                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-CPU\ARM-Cortex-M3\IAR\ -I                              #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-LCD\Source\ -I C:\Users\Administrator\Desktop\uCOS-II\ #
#                    Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD #
#                    \..\..\..\..\..\uC-LIB\ -I C:\Users\Administrator\Deskto #
#                    p\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS #
#                    -Probe-LCD\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Ge #
#                    neric\IAR\ -I C:\Users\Administrator\Desktop\uCOS-II\Mic #
#                    rium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\.. #
#                    \..\..\..\..\uCOS-II\Source\ -I                          #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM #
#                    32\ -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\So #
#                    ftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\ #
#                    ..\..\uC-Probe\Target\Communication\Generic\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Plugins\uCOS-II\ -I "F:\Program Files     #
#                    (x86)\IAR Systems\Embedded Workbench 5.4\arm\INC\" -Om   #
#    List file    =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\os_ta #
#                    sk.lst                                                   #
#    Object file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\os_tas #
#                    k.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\uCOS-II\Source\os_task.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TASK MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TASK.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          /*$PAGE*/
     29          /*
     30          *********************************************************************************************************
     31          *                                        CHANGE PRIORITY OF A TASK
     32          *
     33          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     34          *              priority MUST be available.
     35          *
     36          * Arguments  : oldp     is the old priority
     37          *
     38          *              newp     is the new priority
     39          *
     40          * Returns    : OS_ERR_NONE            is the call was successful
     41          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
     42          *                                     (i.e. >= OS_LOWEST_PRIO)
     43          *              OS_ERR_PRIO_EXIST      if the new priority already exist.
     44          *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
     45          *                                     not exist.
     46          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
     47          *********************************************************************************************************
     48          */
     49          
     50          #if OS_TASK_CHANGE_PRIO_EN > 0

   \                                 In section .text, align 2, keep-with-next
     51          INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
     52          {
   \                     OSTaskChangePrio:
   \   00000000   2DE9F24F           PUSH     {R1,R4-R11,LR}
   \   00000004   82B0               SUB      SP,SP,#+8
   \   00000006   0446               MOV      R4,R0
     53          #if (OS_EVENT_EN)
     54              OS_EVENT  *pevent;
     55          #if (OS_EVENT_MULTI_EN > 0)
     56              OS_EVENT **pevents;
     57          #endif
     58          #endif
     59              OS_TCB    *ptcb;
     60              INT8U      y_new;
     61              INT8U      x_new;
     62              INT8U      y_old;
     63          #if OS_LOWEST_PRIO <= 63
     64              INT8U      bity_new;
     65              INT8U      bitx_new;
     66              INT8U      bity_old;
     67              INT8U      bitx_old;
     68          #else
     69              INT16U     bity_new;
     70              INT16U     bitx_new;
     71              INT16U     bity_old;
     72              INT16U     bitx_old;
     73          #endif
     74          #if OS_CRITICAL_METHOD == 3
     75              OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
     76          #endif
     77          
     78          
     79          /*$PAGE*/
     80          #if OS_ARG_CHK_EN > 0
     81              if (oldprio >= OS_LOWEST_PRIO) {
   \   00000008   1F2C               CMP      R4,#+31
   \   0000000A   04D3               BCC.N    ??OSTaskChangePrio_0
     82                  if (oldprio != OS_PRIO_SELF) {
   \   0000000C   FF2C               CMP      R4,#+255
   \   0000000E   02D0               BEQ.N    ??OSTaskChangePrio_0
     83                      return (OS_ERR_PRIO_INVALID);
   \                     ??OSTaskChangePrio_1:
   \   00000010   2A20               MOVS     R0,#+42
   \   00000012   BDE8FE8F           POP      {R1-R11,PC}
     84                  }
     85              }
     86              if (newprio >= OS_LOWEST_PRIO) {
   \                     ??OSTaskChangePrio_0:
   \   00000016   0846               MOV      R0,R1
   \   00000018   1F28               CMP      R0,#+31
   \   0000001A   F9D2               BCS.N    ??OSTaskChangePrio_1
     87                  return (OS_ERR_PRIO_INVALID);
     88              }
     89          #endif
     90              OS_ENTER_CRITICAL();
   \   0000001C   ........           BL       OS_CPU_SR_Save
     91              if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
   \   00000020   9DF80810           LDRB     R1,[SP, #+8]
   \   00000024   ........           LDR.W    R7,??DataTable36  ;; OSTCBPrioTbl
   \   00000028   57F82120           LDR      R2,[R7, R1, LSL #+2]
   \   0000002C   002A               CMP      R2,#+0
   \   0000002E   04D0               BEQ.N    ??OSTaskChangePrio_2
     92                  OS_EXIT_CRITICAL();
   \   00000030   ........           BL       OS_CPU_SR_Restore
     93                  return (OS_ERR_PRIO_EXIST);
   \   00000034   2820               MOVS     R0,#+40
   \   00000036   BDE8FE8F           POP      {R1-R11,PC}
     94              }
     95              if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
   \                     ??OSTaskChangePrio_2:
   \   0000003A   FF2C               CMP      R4,#+255
   \   0000003C   04D1               BNE.N    ??OSTaskChangePrio_3
     96                  oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
   \   0000003E   ........           LDR.W    R2,??DataTable35  ;; OSTCBCur
   \   00000042   1268               LDR      R2,[R2, #+0]
   \   00000044   92F83240           LDRB     R4,[R2, #+50]
     97              }
     98              ptcb = OSTCBPrioTbl[oldprio];
   \                     ??OSTaskChangePrio_3:
   \   00000048   57F82420           LDR      R2,[R7, R4, LSL #+2]
     99              if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
   \   0000004C   002A               CMP      R2,#+0
   \   0000004E   04D1               BNE.N    ??OSTaskChangePrio_4
    100                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000050   ........           BL       OS_CPU_SR_Restore
    101                  return (OS_ERR_PRIO);
   \   00000054   2920               MOVS     R0,#+41
   \   00000056   BDE8FE8F           POP      {R1-R11,PC}
    102              }
    103              if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
   \                     ??OSTaskChangePrio_4:
   \   0000005A   012A               CMP      R2,#+1
   \   0000005C   04D1               BNE.N    ??OSTaskChangePrio_5
    104                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   0000005E   ........           BL       OS_CPU_SR_Restore
    105                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000062   4320               MOVS     R0,#+67
   \   00000064   BDE8FE8F           POP      {R1-R11,PC}
    106              }
    107          #if OS_LOWEST_PRIO <= 63
    108              y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
   \                     ??OSTaskChangePrio_5:
   \   00000068   0B46               MOV      R3,R1
   \   0000006A   DB08               LSRS     R3,R3,#+3
    109              x_new                 = (INT8U)(newprio & 0x07);
   \   0000006C   0D46               MOV      R5,R1
   \   0000006E   05F00705           AND      R5,R5,#0x7
   \   00000072   0095               STR      R5,[SP, #+0]
    110              bity_new              = (INT8U)(1 << y_new);
   \   00000074   0125               MOVS     R5,#+1
   \   00000076   9D40               LSLS     R5,R5,R3
   \   00000078   EDB2               UXTB     R5,R5
    111              bitx_new              = (INT8U)(1 << x_new);
   \   0000007A   0126               MOVS     R6,#+1
   \   0000007C   DDF800C0           LDR      R12,[SP, #+0]
   \   00000080   06FA0CF6           LSL      R6,R6,R12
   \   00000084   F6B2               UXTB     R6,R6
    112          #else
    113              y_new                 = (INT8U)((newprio >> 4) & 0x0F);
    114              x_new                 = (INT8U)( newprio & 0x0F);
    115              bity_new              = (INT16U)(1 << y_new);
    116              bitx_new              = (INT16U)(1 << x_new);
    117          #endif
    118          
    119              OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
   \   00000086   4FF0000C           MOV      R12,#+0
   \   0000008A   47F824C0           STR      R12,[R7, R4, LSL #+2]
    120              OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
   \   0000008E   47F82120           STR      R2,[R7, R1, LSL #+2]
    121              y_old                 =  ptcb->OSTCBY;
   \   00000092   02F13204           ADD      R4,R2,#+50
   \   00000096   A178               LDRB     R1,[R4, #+2]
    122              bity_old              =  ptcb->OSTCBBitY;
   \   00000098   2779               LDRB     R7,[R4, #+4]
    123              bitx_old              =  ptcb->OSTCBBitX;
   \   0000009A   94F803C0           LDRB     R12,[R4, #+3]
    124              if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
   \   0000009E   ........           LDR.W    R8,??DataTable33  ;; OSRdyTbl
   \   000000A2   11F80890           LDRB     R9,[R1, R8]
   \   000000A6   E246               MOV      R10,R12
   \   000000A8   19EA0A0F           TST      R9,R10
   \   000000AC   1DD0               BEQ.N    ??OSTaskChangePrio_6
   \   000000AE   6FEA0C0E           MVN      LR,R12
   \   000000B2   1EEA0909           ANDS     R9,LR,R9
   \   000000B6   01F80890           STRB     R9,[R1, R8]
    125                   OSRdyTbl[y_old] &= ~bitx_old;
    126                   if (OSRdyTbl[y_old] == 0) {
   \   000000BA   ........           LDR.W    LR,??DataTable34  ;; OSRdyGrp
   \   000000BE   07D1               BNE.N    ??OSTaskChangePrio_7
    127                       OSRdyGrp &= ~bity_old;
   \   000000C0   9EF80090           LDRB     R9,[LR, #+0]
   \   000000C4   6FEA070A           MVN      R10,R7
   \   000000C8   0AEA0909           AND      R9,R10,R9
   \   000000CC   8EF80090           STRB     R9,[LR, #+0]
    128                   }
    129                   OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
   \                     ??OSTaskChangePrio_7:
   \   000000D0   9EF80090           LDRB     R9,[LR, #+0]
   \   000000D4   45EA0909           ORR      R9,R5,R9
   \   000000D8   8EF80090           STRB     R9,[LR, #+0]
    130                   OSRdyTbl[y_new] |= bitx_new;
   \   000000DC   9E46               MOV      LR,R3
   \   000000DE   1EF80890           LDRB     R9,[LR, R8]
   \   000000E2   46EA0909           ORR      R9,R6,R9
   \   000000E6   0EF80890           STRB     R9,[LR, R8]
    131              }
    132          
    133          #if (OS_EVENT_EN)
    134              pevent = ptcb->OSTCBEventPtr;
   \                     ??OSTaskChangePrio_6:
   \   000000EA   D2F81C80           LDR      R8,[R2, #+28]
    135              if (pevent != (OS_EVENT *)0) {
   \   000000EE   B8F1000F           CMP      R8,#+0
   \   000000F2   24D0               BEQ.N    ??OSTaskChangePrio_8
    136                  pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
   \   000000F4   01EB080E           ADD      LR,R1,R8
   \   000000F8   9EF80B90           LDRB     R9,[LR, #+11]
   \   000000FC   6FEA0C0A           MVN      R10,R12
   \   00000100   0AEA0909           AND      R9,R10,R9
   \   00000104   8EF80B90           STRB     R9,[LR, #+11]
    137                  if (pevent->OSEventTbl[y_old] == 0) {
   \   00000108   9EF80BE0           LDRB     LR,[LR, #+11]
   \   0000010C   BEF1000F           CMP      LR,#+0
   \   00000110   07D1               BNE.N    ??OSTaskChangePrio_9
    138                      pevent->OSEventGrp    &= ~bity_old;
   \   00000112   98F80AE0           LDRB     LR,[R8, #+10]
   \   00000116   6FEA0709           MVN      R9,R7
   \   0000011A   09EA0E0E           AND      LR,R9,LR
   \   0000011E   88F80AE0           STRB     LR,[R8, #+10]
    139                  }
    140                  pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
   \                     ??OSTaskChangePrio_9:
   \   00000122   98F80AE0           LDRB     LR,[R8, #+10]
   \   00000126   45EA0E0E           ORR      LR,R5,LR
   \   0000012A   88F80AE0           STRB     LR,[R8, #+10]
    141                  pevent->OSEventTbl[y_new] |= bitx_new;
   \   0000012E   9E46               MOV      LR,R3
   \   00000130   C644               ADD      LR,LR,R8
   \   00000132   9EF80B80           LDRB     R8,[LR, #+11]
   \   00000136   46EA0808           ORR      R8,R6,R8
   \   0000013A   8EF80B80           STRB     R8,[LR, #+11]
    142              }
    143          #if (OS_EVENT_MULTI_EN > 0)
    144              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
   \                     ??OSTaskChangePrio_8:
   \   0000013E   D2F820E0           LDR      LR,[R2, #+32]
   \   00000142   BEF1000F           CMP      LR,#+0
   \   00000146   2DD0               BEQ.N    ??OSTaskChangePrio_10
    145                  pevents =  ptcb->OSTCBEventMultiPtr;
   \   00000148   F146               MOV      R9,LR
    146                  pevent  = *pevents;
   \   0000014A   D9F80080           LDR      R8,[R9, #+0]
   \   0000014E   6FEA0C0B           MVN      R11,R12
   \   00000152   24E0               B.N      ??OSTaskChangePrio_11
    147                  while (pevent != (OS_EVENT *)0) {
    148                      pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
   \                     ??OSTaskChangePrio_12:
   \   00000154   01EB080E           ADD      LR,R1,R8
   \   00000158   9EF80BA0           LDRB     R10,[LR, #+11]
   \   0000015C   0BEA0A0A           AND      R10,R11,R10
   \   00000160   8EF80BA0           STRB     R10,[LR, #+11]
    149                      if (pevent->OSEventTbl[y_old] == 0) {
   \   00000164   9EF80BE0           LDRB     LR,[LR, #+11]
   \   00000168   BEF1000F           CMP      LR,#+0
   \   0000016C   07D1               BNE.N    ??OSTaskChangePrio_13
    150                          pevent->OSEventGrp    &= ~bity_old;
   \   0000016E   98F80AE0           LDRB     LR,[R8, #+10]
   \   00000172   6FEA070A           MVN      R10,R7
   \   00000176   0AEA0E0E           AND      LR,R10,LR
   \   0000017A   88F80AE0           STRB     LR,[R8, #+10]
    151                      }
    152                      pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
   \                     ??OSTaskChangePrio_13:
   \   0000017E   98F80AE0           LDRB     LR,[R8, #+10]
   \   00000182   45EA0E0E           ORR      LR,R5,LR
   \   00000186   88F80AE0           STRB     LR,[R8, #+10]
    153                      pevent->OSEventTbl[y_new] |= bitx_new;
   \   0000018A   9E46               MOV      LR,R3
   \   0000018C   C644               ADD      LR,LR,R8
   \   0000018E   9EF80B80           LDRB     R8,[LR, #+11]
   \   00000192   46EA0808           ORR      R8,R6,R8
   \   00000196   8EF80B80           STRB     R8,[LR, #+11]
    154                      pevents++;
    155                      pevent                     = *pevents;
   \   0000019A   59F8048F           LDR      R8,[R9, #+4]!
    156                  }
   \                     ??OSTaskChangePrio_11:
   \   0000019E   B8F1000F           CMP      R8,#+0
   \   000001A2   D7D1               BNE.N    ??OSTaskChangePrio_12
    157              }
    158          #endif
    159          #endif
    160          
    161              ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
   \                     ??OSTaskChangePrio_10:
   \   000001A4   9DF80810           LDRB     R1,[SP, #+8]
   \   000001A8   82F83210           STRB     R1,[R2, #+50]
    162              ptcb->OSTCBY    = y_new;
   \   000001AC   A370               STRB     R3,[R4, #+2]
    163              ptcb->OSTCBX    = x_new;
   \   000001AE   0099               LDR      R1,[SP, #+0]
   \   000001B0   6170               STRB     R1,[R4, #+1]
    164              ptcb->OSTCBBitY = bity_new;
   \   000001B2   2571               STRB     R5,[R4, #+4]
    165              ptcb->OSTCBBitX = bitx_new;
   \   000001B4   E670               STRB     R6,[R4, #+3]
    166              OS_EXIT_CRITICAL();
   \   000001B6   ........           BL       OS_CPU_SR_Restore
    167              if (OSRunning == OS_TRUE) {
   \   000001BA   ........           LDR.W    R0,??DataTable28  ;; OSRunning
   \   000001BE   0078               LDRB     R0,[R0, #+0]
   \   000001C0   0128               CMP      R0,#+1
   \   000001C2   01D1               BNE.N    ??OSTaskChangePrio_14
    168                  OS_Sched();                                         /* Find new highest priority task          */
   \   000001C4   ........           BL       OS_Sched
    169              }
    170              return (OS_ERR_NONE);
   \                     ??OSTaskChangePrio_14:
   \   000001C8   0020               MOVS     R0,#+0
   \   000001CA   BDE8FE8F           POP      {R1-R11,PC}      ;; return
    171          }
    172          #endif
    173          /*$PAGE*/
    174          /*
    175          *********************************************************************************************************
    176          *                                            CREATE A TASK
    177          *
    178          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    179          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    180          *              created by an ISR.
    181          *
    182          * Arguments  : task     is a pointer to the task's code
    183          *
    184          *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
    185          *                       the task when the task first executes.  Where the task is concerned it thinks
    186          *                       it was invoked and passed the argument 'p_arg' as follows:
    187          *
    188          *                           void Task (void *p_arg)
    189          *                           {
    190          *                               for (;;) {
    191          *                                   Task code;
    192          *                               }
    193          *                           }
    194          *
    195          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
    196          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    197          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
    198          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
    199          *                       lowest memory location of the stack and the stack will grow with increasing
    200          *                       memory locations.
    201          *
    202          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
    203          *                       lower the number, the higher the priority.
    204          *
    205          * Returns    : OS_ERR_NONE             if the function was successful.
    206          *              OS_PRIO_EXIT            if the task priority already exist
    207          *                                      (each task MUST have a unique priority).
    208          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    209          *                                      (i.e. >= OS_LOWEST_PRIO)
    210          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    211          *********************************************************************************************************
    212          */
    213          
    214          #if OS_TASK_CREATE_EN > 0

   \                                 In section .text, align 2, keep-with-next
    215          INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
    216          {
   \                     OSTaskCreate:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   8846               MOV      R8,R1
   \   00000008   9146               MOV      R9,R2
   \   0000000A   1D46               MOV      R5,R3
    217              OS_STK    *psp;
    218              INT8U      err;
    219          #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    220              OS_CPU_SR  cpu_sr = 0;
    221          #endif
    222          
    223          
    224          
    225          #if OS_ARG_CHK_EN > 0
    226              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
   \   0000000C   202D               CMP      R5,#+32
   \   0000000E   02D3               BCC.N    ??OSTaskCreate_0
    227                  return (OS_ERR_PRIO_INVALID);
   \   00000010   2A20               MOVS     R0,#+42
   \   00000012   BDE8F283           POP      {R1,R4-R9,PC}
    228              }
    229          #endif
    230              OS_ENTER_CRITICAL();
   \                     ??OSTaskCreate_0:
   \   00000016   ........           BL       OS_CPU_SR_Save
    231              if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
   \   0000001A   ........           LDR.W    R1,??DataTable22  ;; OSIntNesting
   \   0000001E   0978               LDRB     R1,[R1, #+0]
   \   00000020   0029               CMP      R1,#+0
   \   00000022   04D0               BEQ.N    ??OSTaskCreate_1
    232                  OS_EXIT_CRITICAL();
   \   00000024   ........           BL       OS_CPU_SR_Restore
    233                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000028   3C20               MOVS     R0,#+60
   \   0000002A   BDE8F283           POP      {R1,R4-R9,PC}
    234              }
    235              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreate_1:
   \   0000002E   2E46               MOV      R6,R5
   \   00000030   ........           LDR.W    R7,??DataTable36  ;; OSTCBPrioTbl
   \   00000034   57F82610           LDR      R1,[R7, R6, LSL #+2]
   \   00000038   0029               CMP      R1,#+0
   \   0000003A   2AD1               BNE.N    ??OSTaskCreate_2
    236                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   47F82610           STR      R1,[R7, R6, LSL #+2]
    237                                                       /* ... the same thing until task is created.              */
    238                  OS_EXIT_CRITICAL();
   \   00000042   ........           BL       OS_CPU_SR_Restore
    239                  psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
   \   00000046   0023               MOVS     R3,#+0
   \   00000048   4A46               MOV      R2,R9
   \   0000004A   4146               MOV      R1,R8
   \   0000004C   2046               MOV      R0,R4
   \   0000004E   ........           BL       OSTaskStkInit
   \   00000052   0446               MOV      R4,R0
    240                  err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   01B5               PUSH     {R0,LR}
   \   00000058   0146               MOV      R1,R0
   \   0000005A   03B4               PUSH     {R0,R1}
   \   0000005C   0346               MOV      R3,R0
   \   0000005E   0246               MOV      R2,R0
   \   00000060   2146               MOV      R1,R4
   \   00000062   2846               MOV      R0,R5
   \   00000064   ........           BL       OS_TCBInit
   \   00000068   04B0               ADD      SP,SP,#+16
   \   0000006A   0400               MOVS     R4,R0
    241                  if (err == OS_ERR_NONE) {
   \   0000006C   07D1               BNE.N    ??OSTaskCreate_3
    242                      if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
   \   0000006E   ........           LDR.W    R0,??DataTable28  ;; OSRunning
   \   00000072   0078               LDRB     R0,[R0, #+0]
   \   00000074   0128               CMP      R0,#+1
   \   00000076   09D1               BNE.N    ??OSTaskCreate_4
    243                          OS_Sched();
   \   00000078   ........           BL       OS_Sched
   \   0000007C   06E0               B.N      ??OSTaskCreate_4
    244                      }
    245                  } else {
    246                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreate_3:
   \   0000007E   ........           BL       OS_CPU_SR_Save
    247                      OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
   \   00000082   0021               MOVS     R1,#+0
   \   00000084   47F82610           STR      R1,[R7, R6, LSL #+2]
    248                      OS_EXIT_CRITICAL();
   \   00000088   ........           BL       OS_CPU_SR_Restore
    249                  }
    250                  return (err);
   \                     ??OSTaskCreate_4:
   \   0000008C   2046               MOV      R0,R4
   \   0000008E   BDE8F283           POP      {R1,R4-R9,PC}
    251              }
    252              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreate_2:
   \   00000092   ........           BL       OS_CPU_SR_Restore
    253              return (OS_ERR_PRIO_EXIST);
   \   00000096   2820               MOVS     R0,#+40
   \   00000098   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
    254          }
    255          #endif
    256          /*$PAGE*/
    257          /*
    258          *********************************************************************************************************
    259          *                                     CREATE A TASK (Extended Version)
    260          *
    261          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    262          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    263          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
    264          *              additional information about a task to be specified.
    265          *
    266          * Arguments  : task      is a pointer to the task's code
    267          *
    268          *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
    269          *                        the task when the task first executes.  Where the task is concerned it thinks
    270          *                        it was invoked and passed the argument 'p_arg' as follows:
    271          *
    272          *                            void Task (void *p_arg)
    273          *                            {
    274          *                                for (;;) {
    275          *                                    Task code;
    276          *                                }
    277          *                            }
    278          *
    279          *              ptos      is a pointer to the task's top of stack.  If the configuration constant
    280          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    281          *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
    282          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
    283          *                        lowest memory location of the stack and the stack will grow with increasing
    284          *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
    285          *
    286          *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
    287          *                        lower the number, the higher the priority.
    288          *
    289          *              id        is the task's ID (0..65535)
    290          *
    291          *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
    292          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    293          *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
    294          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
    295          *                        HIGHEST memory location of the stack and the stack will grow with increasing
    296          *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
    297          *
    298          *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
    299          *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
    300          *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    301          *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
    302          *                        available on the stack.
    303          *
    304          *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
    305          *                        For example, this user memory can hold the contents of floating-point registers
    306          *                        during a context switch, the time each task takes to execute, the number of times
    307          *                        the task has been switched-in, etc.
    308          *
    309          *              opt       contains additional information (or options) about the behavior of the task.  The
    310          *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
    311          *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
    312          *
    313          *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
    314          *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
    315          *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
    316          *                                                 during a context switch.
    317          *
    318          * Returns    : OS_ERR_NONE             if the function was successful.
    319          *              OS_PRIO_EXIT            if the task priority already exist
    320          *                                      (each task MUST have a unique priority).
    321          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    322          *                                      (i.e. > OS_LOWEST_PRIO)
    323          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    324          *********************************************************************************************************
    325          */
    326          /*$PAGE*/
    327          #if OS_TASK_CREATE_EXT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    328          INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
    329                                  void    *p_arg,
    330                                  OS_STK  *ptos,
    331                                  INT8U    prio,
    332                                  INT16U   id,
    333                                  OS_STK  *pbos,
    334                                  INT32U   stk_size,
    335                                  void    *pext,
    336                                  INT16U   opt)
    337          {
   \                     OSTaskCreateExt:
   \   00000000   2DE9F74F           PUSH     {R0-R2,R4-R11,LR}
   \   00000004   1C46               MOV      R4,R3
   \   00000006   DDF830B0           LDR      R11,[SP, #+48]
   \   0000000A   DDF83490           LDR      R9,[SP, #+52]
   \   0000000E   0E9D               LDR      R5,[SP, #+56]
   \   00000010   DDF83CA0           LDR      R10,[SP, #+60]
   \   00000014   DDF84080           LDR      R8,[SP, #+64]
    338              OS_STK    *psp;
    339              INT8U      err;
    340          #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    341              OS_CPU_SR  cpu_sr = 0;
    342          #endif
    343          
    344          
    345          
    346          #if OS_ARG_CHK_EN > 0
    347              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
   \   00000018   202C               CMP      R4,#+32
   \   0000001A   02D3               BCC.N    ??OSTaskCreateExt_0
    348                  return (OS_ERR_PRIO_INVALID);
   \   0000001C   2A20               MOVS     R0,#+42
   \   0000001E   BDE8FE8F           POP      {R1-R11,PC}
    349              }
    350          #endif
    351              OS_ENTER_CRITICAL();
   \                     ??OSTaskCreateExt_0:
   \   00000022   ........           BL       OS_CPU_SR_Save
    352              if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
   \   00000026   ....               LDR.N    R1,??DataTable22  ;; OSIntNesting
   \   00000028   0978               LDRB     R1,[R1, #+0]
   \   0000002A   0029               CMP      R1,#+0
   \   0000002C   04D0               BEQ.N    ??OSTaskCreateExt_1
    353                  OS_EXIT_CRITICAL();
   \   0000002E   ........           BL       OS_CPU_SR_Restore
    354                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000032   3C20               MOVS     R0,#+60
   \   00000034   BDE8FE8F           POP      {R1-R11,PC}
    355              }
    356              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreateExt_1:
   \   00000038   2646               MOV      R6,R4
   \   0000003A   ........           LDR.W    R7,??DataTable36  ;; OSTCBPrioTbl
   \   0000003E   57F82610           LDR      R1,[R7, R6, LSL #+2]
   \   00000042   0029               CMP      R1,#+0
   \   00000044   35D1               BNE.N    ??OSTaskCreateExt_2
    357                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   47F82610           STR      R1,[R7, R6, LSL #+2]
    358                                                       /* ... the same thing until task is created.              */
    359                  OS_EXIT_CRITICAL();
   \   0000004C   ........           BL       OS_CPU_SR_Restore
    360          
    361          #if (OS_TASK_STAT_STK_CHK_EN > 0)
    362                  OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
   \   00000050   4246               MOV      R2,R8
   \   00000052   92B2               UXTH     R2,R2
   \   00000054   2946               MOV      R1,R5
   \   00000056   4846               MOV      R0,R9
   \   00000058   ........           BL       OS_TaskStkClr
    363          #endif
    364          
    365                  psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
   \   0000005C   4346               MOV      R3,R8
   \   0000005E   9BB2               UXTH     R3,R3
   \   00000060   029A               LDR      R2,[SP, #+8]
   \   00000062   0199               LDR      R1,[SP, #+4]
   \   00000064   0098               LDR      R0,[SP, #+0]
   \   00000066   ........           BL       OSTaskStkInit
   \   0000006A   8446               MOV      R12,R0
    366                  err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
   \   0000006C   1FFA88F8           UXTH     R8,R8
   \   00000070   2DE90041           PUSH     {R8,LR}
   \   00000074   5146               MOV      R1,R10
   \   00000076   2846               MOV      R0,R5
   \   00000078   03B4               PUSH     {R0,R1}
   \   0000007A   5B46               MOV      R3,R11
   \   0000007C   9BB2               UXTH     R3,R3
   \   0000007E   4A46               MOV      R2,R9
   \   00000080   6146               MOV      R1,R12
   \   00000082   2046               MOV      R0,R4
   \   00000084   ........           BL       OS_TCBInit
   \   00000088   04B0               ADD      SP,SP,#+16
   \   0000008A   0400               MOVS     R4,R0
    367                  if (err == OS_ERR_NONE) {
   \   0000008C   07D1               BNE.N    ??OSTaskCreateExt_3
    368                      if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
   \   0000008E   ........           LDR.W    R0,??DataTable28  ;; OSRunning
   \   00000092   0078               LDRB     R0,[R0, #+0]
   \   00000094   0128               CMP      R0,#+1
   \   00000096   09D1               BNE.N    ??OSTaskCreateExt_4
    369                          OS_Sched();
   \   00000098   ........           BL       OS_Sched
   \   0000009C   06E0               B.N      ??OSTaskCreateExt_4
    370                      }
    371                  } else {
    372                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreateExt_3:
   \   0000009E   ........           BL       OS_CPU_SR_Save
    373                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
   \   000000A2   0021               MOVS     R1,#+0
   \   000000A4   47F82610           STR      R1,[R7, R6, LSL #+2]
    374                      OS_EXIT_CRITICAL();
   \   000000A8   ........           BL       OS_CPU_SR_Restore
    375                  }
    376                  return (err);
   \                     ??OSTaskCreateExt_4:
   \   000000AC   2046               MOV      R0,R4
   \   000000AE   BDE8FE8F           POP      {R1-R11,PC}
    377              }
    378              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreateExt_2:
   \   000000B2   ........           BL       OS_CPU_SR_Restore
    379              return (OS_ERR_PRIO_EXIST);
   \   000000B6   2820               MOVS     R0,#+40
   \   000000B8   BDE8FE8F           POP      {R1-R11,PC}      ;; return
    380          }
    381          #endif
    382          /*$PAGE*/
    383          /*
    384          *********************************************************************************************************
    385          *                                            DELETE A TASK
    386          *
    387          * Description: This function allows you to delete a task.  The calling task can delete itself by
    388          *              its own priority number.  The deleted task is returned to the dormant state and can be
    389          *              re-activated by creating the deleted task again.
    390          *
    391          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
    392          *                      the current task without knowing its priority level by setting 'prio' to
    393          *                      OS_PRIO_SELF.
    394          *
    395          * Returns    : OS_ERR_NONE             if the call is successful
    396          *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
    397          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    398          *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    399          *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.   
    400          *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
    401          *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
    402          *
    403          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
    404          *                    a) by making it not ready
    405          *                    b) by removing it from any wait lists
    406          *                    c) by preventing OSTimeTick() from making the task ready to run.
    407          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
    408          *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
    409          *                 the next instruction following the enable interrupt instruction is ignored.
    410          *              3) An ISR cannot delete a task.
    411          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
    412          *                 task is being deleted, the current task would not be able to be rescheduled because it
    413          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
    414          *                 from being schedule.  This means that an ISR would return to the current task which is
    415          *                 being deleted.  The rest of the deletion would thus be able to be completed.
    416          *********************************************************************************************************
    417          */
    418          
    419          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 4, keep-with-next
    420          INT8U  OSTaskDel (INT8U prio)
    421          {
   \                     OSTaskDel:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   8046               MOV      R8,R0
    422          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    423              OS_FLAG_NODE *pnode;
    424          #endif
    425              OS_TCB       *ptcb;
    426          #if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    427              OS_CPU_SR     cpu_sr = 0;
    428          #endif
    429          
    430          
    431          
    432              if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
   \   00000006   ....               LDR.N    R0,??DataTable22  ;; OSIntNesting
   \   00000008   0078               LDRB     R0,[R0, #+0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   02D0               BEQ.N    ??OSTaskDel_0
    433                  return (OS_ERR_TASK_DEL_ISR);
   \   0000000E   4020               MOVS     R0,#+64
   \   00000010   BDE8F283           POP      {R1,R4-R9,PC}
    434              }
    435              if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
   \                     ??OSTaskDel_0:
   \   00000014   B8F11F0F           CMP      R8,#+31
   \   00000018   02D1               BNE.N    ??OSTaskDel_1
    436                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000001A   3E20               MOVS     R0,#+62
   \   0000001C   BDE8F283           POP      {R1,R4-R9,PC}
    437              }
    438          #if OS_ARG_CHK_EN > 0
    439              if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
   \                     ??OSTaskDel_1:
   \   00000020   05D3               BCC.N    ??OSTaskDel_2
    440                  if (prio != OS_PRIO_SELF) {
   \   00000022   B8F1FF0F           CMP      R8,#+255
   \   00000026   02D0               BEQ.N    ??OSTaskDel_2
    441                      return (OS_ERR_PRIO_INVALID);
   \   00000028   2A20               MOVS     R0,#+42
   \   0000002A   BDE8F283           POP      {R1,R4-R9,PC}
    442                  }
    443              }
    444          #endif
    445          
    446          /*$PAGE*/
    447              OS_ENTER_CRITICAL();
   \                     ??OSTaskDel_2:
   \   0000002E   ........           BL       OS_CPU_SR_Save
   \   00000032   0446               MOV      R4,R0
    448              if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
   \   00000034   B8F1FF0F           CMP      R8,#+255
   \   00000038   04D1               BNE.N    ??OSTaskDel_3
    449                  prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
   \   0000003A   ........           LDR.W    R0,??DataTable35  ;; OSTCBCur
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   90F83280           LDRB     R8,[R0, #+50]
    450              }
    451              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskDel_3:
   \   00000044   ........           LDR.W    R5,??DataTable36  ;; OSTCBPrioTbl
   \   00000048   55F82860           LDR      R6,[R5, R8, LSL #+2]
    452              if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
   \   0000004C   002E               CMP      R6,#+0
   \   0000004E   05D1               BNE.N    ??OSTaskDel_4
    453                  OS_EXIT_CRITICAL();
   \   00000050   2046               MOV      R0,R4
   \   00000052   ........           BL       OS_CPU_SR_Restore
    454                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000056   4320               MOVS     R0,#+67
   \   00000058   BDE8F283           POP      {R1,R4-R9,PC}
    455              }
    456              if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
   \                     ??OSTaskDel_4:
   \   0000005C   012E               CMP      R6,#+1
   \   0000005E   05D1               BNE.N    ??OSTaskDel_5
    457                  OS_EXIT_CRITICAL();
   \   00000060   2046               MOV      R0,R4
   \   00000062   ........           BL       OS_CPU_SR_Restore
    458                  return (OS_ERR_TASK_DEL);
   \   00000066   3D20               MOVS     R0,#+61
   \   00000068   BDE8F283           POP      {R1,R4-R9,PC}
    459              }
    460          
    461              OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
   \                     ??OSTaskDel_5:
   \   0000006C   06F13007           ADD      R7,R6,#+48
   \   00000070   ........           LDR.W    R0,??DataTable33  ;; OSRdyTbl
   \   00000074   3979               LDRB     R1,[R7, #+4]
   \   00000076   095C               LDRB     R1,[R1, R0]
   \   00000078   7A79               LDRB     R2,[R7, #+5]
   \   0000007A   D243               MVNS     R2,R2
   \   0000007C   1140               ANDS     R1,R2,R1
   \   0000007E   3A79               LDRB     R2,[R7, #+4]
   \   00000080   1154               STRB     R1,[R2, R0]
    462              if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
   \   00000082   3979               LDRB     R1,[R7, #+4]
   \   00000084   085C               LDRB     R0,[R1, R0]
   \   00000086   0028               CMP      R0,#+0
   \   00000088   06D1               BNE.N    ??OSTaskDel_6
    463                  OSRdyGrp           &= ~ptcb->OSTCBBitY;
   \   0000008A   ........           LDR.W    R0,??DataTable34  ;; OSRdyGrp
   \   0000008E   0178               LDRB     R1,[R0, #+0]
   \   00000090   BA79               LDRB     R2,[R7, #+6]
   \   00000092   D243               MVNS     R2,R2
   \   00000094   1140               ANDS     R1,R2,R1
   \   00000096   0170               STRB     R1,[R0, #+0]
    464              }
    465              
    466          #if (OS_EVENT_EN)
    467              if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
   \                     ??OSTaskDel_6:
   \   00000098   F069               LDR      R0,[R6, #+28]
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   03D0               BEQ.N    ??OSTaskDel_7
    468                  OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
   \   0000009E   0146               MOV      R1,R0
   \   000000A0   3046               MOV      R0,R6
   \   000000A2   ........           BL       OS_EventTaskRemove
    469              }
    470          #if (OS_EVENT_MULTI_EN > 0)
    471              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
   \                     ??OSTaskDel_7:
   \   000000A6   306A               LDR      R0,[R6, #+32]
   \   000000A8   0028               CMP      R0,#+0
   \   000000AA   03D0               BEQ.N    ??OSTaskDel_8
    472                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   000000AC   0146               MOV      R1,R0
   \   000000AE   3046               MOV      R0,R6
   \   000000B0   ........           BL       OS_EventTaskRemoveMulti
    473              }
    474          #endif
    475          #endif
    476          
    477          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    478              pnode = ptcb->OSTCBFlagNode;
   \                     ??OSTaskDel_8:
   \   000000B4   B06A               LDR      R0,[R6, #+40]
    479              if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
   \   000000B6   0028               CMP      R0,#+0
   \   000000B8   01D0               BEQ.N    ??OSTaskDel_9
    480                  OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
   \   000000BA   ........           BL       OS_FlagUnlink
    481              }
    482          #endif
    483          
    484              ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
   \                     ??OSTaskDel_9:
   \   000000BE   0020               MOVS     R0,#+0
   \   000000C0   F085               STRH     R0,[R6, #+46]
    485              ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
   \   000000C2   86F83000           STRB     R0,[R6, #+48]
    486              ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \   000000C6   7870               STRB     R0,[R7, #+1]
    487              if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
   \   000000C8   DFF88890           LDR.W    R9,??OSTaskDel_10  ;; OSLockNesting
   \   000000CC   99F80000           LDRB     R0,[R9, #+0]
   \   000000D0   FF28               CMP      R0,#+255
   \   000000D2   02D0               BEQ.N    ??OSTaskDel_11
    488                  OSLockNesting++;
   \   000000D4   401C               ADDS     R0,R0,#+1
   \   000000D6   89F80000           STRB     R0,[R9, #+0]
    489              }
    490              OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
   \                     ??OSTaskDel_11:
   \   000000DA   2046               MOV      R0,R4
   \   000000DC   ........           BL       OS_CPU_SR_Restore
    491              OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
   \   000000E0   ........           BL       OS_Dummy
    492              OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
   \   000000E4   ........           BL       OS_CPU_SR_Save
   \   000000E8   0446               MOV      R4,R0
    493              if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
   \   000000EA   99F80000           LDRB     R0,[R9, #+0]
   \   000000EE   0028               CMP      R0,#+0
   \   000000F0   02D0               BEQ.N    ??OSTaskDel_12
    494                  OSLockNesting--;
   \   000000F2   401E               SUBS     R0,R0,#+1
   \   000000F4   89F80000           STRB     R0,[R9, #+0]
    495              }
    496              OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
   \                     ??OSTaskDel_12:
   \   000000F8   3046               MOV      R0,R6
   \   000000FA   ........           BL       OSTaskDelHook
    497              OSTaskCtr--;                                        /* One less task being managed                 */
   \   000000FE   1648               LDR.N    R0,??OSTaskDel_10+0x4  ;; OSTaskCtr
   \   00000100   0178               LDRB     R1,[R0, #+0]
   \   00000102   491E               SUBS     R1,R1,#+1
   \   00000104   0170               STRB     R1,[R0, #+0]
    498              OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
   \   00000106   0020               MOVS     R0,#+0
   \   00000108   45F82800           STR      R0,[R5, R8, LSL #+2]
    499              if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
   \   0000010C   B069               LDR      R0,[R6, #+24]
   \   0000010E   0028               CMP      R0,#+0
   \   00000110   06D1               BNE.N    ??OSTaskDel_13
    500                  ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
   \   00000112   7069               LDR      R0,[R6, #+20]
   \   00000114   0021               MOVS     R1,#+0
   \   00000116   8161               STR      R1,[R0, #+24]
    501                  OSTCBList                  = ptcb->OSTCBNext;
   \   00000118   7069               LDR      R0,[R6, #+20]
   \   0000011A   1049               LDR.N    R1,??OSTaskDel_10+0x8  ;; OSTCBList
   \   0000011C   0860               STR      R0,[R1, #+0]
   \   0000011E   04E0               B.N      ??OSTaskDel_14
    502              } else {
    503                  ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
   \                     ??OSTaskDel_13:
   \   00000120   7169               LDR      R1,[R6, #+20]
   \   00000122   4161               STR      R1,[R0, #+20]
    504                  ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
   \   00000124   7069               LDR      R0,[R6, #+20]
   \   00000126   B169               LDR      R1,[R6, #+24]
   \   00000128   8161               STR      R1,[R0, #+24]
    505              }
    506              ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
   \                     ??OSTaskDel_14:
   \   0000012A   0D48               LDR.N    R0,??OSTaskDel_10+0xC  ;; OSTCBFreeList
   \   0000012C   0168               LDR      R1,[R0, #+0]
   \   0000012E   7161               STR      R1,[R6, #+20]
    507              OSTCBFreeList     = ptcb;
   \   00000130   0660               STR      R6,[R0, #+0]
    508          #if OS_TASK_NAME_SIZE > 1
    509              ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
   \   00000132   3F20               MOVS     R0,#+63
   \   00000134   3877               STRB     R0,[R7, #+28]
    510              ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000136   0020               MOVS     R0,#+0
   \   00000138   7877               STRB     R0,[R7, #+29]
    511          #endif
    512              OS_EXIT_CRITICAL();
   \   0000013A   2046               MOV      R0,R4
   \   0000013C   ........           BL       OS_CPU_SR_Restore
    513              if (OSRunning == OS_TRUE) {
   \   00000140   ....               LDR.N    R0,??DataTable28  ;; OSRunning
   \   00000142   0078               LDRB     R0,[R0, #+0]
   \   00000144   0128               CMP      R0,#+1
   \   00000146   01D1               BNE.N    ??OSTaskDel_15
    514                  OS_Sched();                                     /* Find new highest priority task              */
   \   00000148   ........           BL       OS_Sched
    515              }
    516              return (OS_ERR_NONE);
   \                     ??OSTaskDel_15:
   \   0000014C   0020               MOVS     R0,#+0
   \   0000014E   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
   \   00000152   00BF               Nop      
   \                     ??OSTaskDel_10:
   \   00000154   ........           DC32     OSLockNesting
   \   00000158   ........           DC32     OSTaskCtr
   \   0000015C   ........           DC32     OSTCBList
   \   00000160   ........           DC32     OSTCBFreeList
    517          }
    518          #endif
    519          /*$PAGE*/
    520          /*
    521          *********************************************************************************************************
    522          *                                    REQUEST THAT A TASK DELETE ITSELF
    523          *
    524          * Description: This function is used to:
    525          *                   a) notify a task to delete itself.
    526          *                   b) to see if a task requested that the current task delete itself.
    527          *              This function is a little tricky to understand.  Basically, you have a task that needs
    528          *              to be deleted however, this task has resources that it has allocated (memory buffers,
    529          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
    530          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
    531          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
    532          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
    533          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
    534          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
    535          *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
    536          *              this:
    537          *
    538          *                   void Task(void *p_arg)
    539          *                   {
    540          *                       .
    541          *                       .
    542          *                       while (1) {
    543          *                           OSTimeDly(1);
    544          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
    545          *                               Release any owned resources;
    546          *                               De-allocate any dynamic memory;
    547          *                               OSTaskDel(OS_PRIO_SELF);
    548          *                           }
    549          *                       }
    550          *                   }
    551          *
    552          * Arguments  : prio    is the priority of the task to request the delete from
    553          *
    554          * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
    555          *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
    556          *                                     the request has been executed.
    557          *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
    558          *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
    559          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    560          *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    561          *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
    562          *                                     deleted.
    563          *********************************************************************************************************
    564          */
    565          /*$PAGE*/
    566          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    567          INT8U  OSTaskDelReq (INT8U prio)
    568          {
   \                     OSTaskDelReq:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0446               MOV      R4,R0
    569              INT8U      stat;
    570              OS_TCB    *ptcb;
    571          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    572              OS_CPU_SR  cpu_sr = 0;
    573          #endif
    574          
    575          
    576          
    577              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
   \   00000004   1F2C               CMP      R4,#+31
   \   00000006   01D1               BNE.N    ??OSTaskDelReq_0
    578                  return (OS_ERR_TASK_DEL_IDLE);
   \   00000008   3E20               MOVS     R0,#+62
   \   0000000A   10BD               POP      {R4,PC}
    579              }
    580          #if OS_ARG_CHK_EN > 0
    581              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
   \                     ??OSTaskDelReq_0:
   \   0000000C   03D3               BCC.N    ??OSTaskDelReq_1
    582                  if (prio != OS_PRIO_SELF) {
   \   0000000E   FF2C               CMP      R4,#+255
   \   00000010   01D0               BEQ.N    ??OSTaskDelReq_1
    583                      return (OS_ERR_PRIO_INVALID);
   \   00000012   2A20               MOVS     R0,#+42
   \   00000014   10BD               POP      {R4,PC}
    584                  }
    585              }
    586          #endif
    587              if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
   \                     ??OSTaskDelReq_1:
   \   00000016   FF2C               CMP      R4,#+255
   \   00000018   09D1               BNE.N    ??OSTaskDelReq_2
    588                  OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
   \   0000001A   ........           BL       OS_CPU_SR_Save
    589                  stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
   \   0000001E   ....               LDR.N    R1,??DataTable35  ;; OSTCBCur
   \   00000020   0968               LDR      R1,[R1, #+0]
   \   00000022   91F83740           LDRB     R4,[R1, #+55]
    590                  OS_EXIT_CRITICAL();
   \   00000026   ........           BL       OS_CPU_SR_Restore
    591                  return (stat);
   \   0000002A   2046               MOV      R0,R4
   \   0000002C   10BD               POP      {R4,PC}
    592              }
    593              OS_ENTER_CRITICAL();
   \                     ??OSTaskDelReq_2:
   \   0000002E   ........           BL       OS_CPU_SR_Save
    594              ptcb = OSTCBPrioTbl[prio];
   \   00000032   ....               LDR.N    R1,??DataTable36  ;; OSTCBPrioTbl
   \   00000034   51F82410           LDR      R1,[R1, R4, LSL #+2]
    595              if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
   \   00000038   0029               CMP      R1,#+0
   \   0000003A   03D1               BNE.N    ??OSTaskDelReq_3
    596                  OS_EXIT_CRITICAL();
   \   0000003C   ........           BL       OS_CPU_SR_Restore
    597                  return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
   \   00000040   4320               MOVS     R0,#+67
   \   00000042   10BD               POP      {R4,PC}
    598              }
    599              if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
   \                     ??OSTaskDelReq_3:
   \   00000044   0129               CMP      R1,#+1
   \   00000046   03D1               BNE.N    ??OSTaskDelReq_4
    600                  OS_EXIT_CRITICAL();
   \   00000048   ........           BL       OS_CPU_SR_Restore
    601                  return (OS_ERR_TASK_DEL);
   \   0000004C   3D20               MOVS     R0,#+61
   \   0000004E   10BD               POP      {R4,PC}
    602              }
    603              ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
   \                     ??OSTaskDelReq_4:
   \   00000050   3F22               MOVS     R2,#+63
   \   00000052   81F83720           STRB     R2,[R1, #+55]
    604              OS_EXIT_CRITICAL();
   \   00000056   ........           BL       OS_CPU_SR_Restore
    605              return (OS_ERR_NONE);
   \   0000005A   0020               MOVS     R0,#+0
   \   0000005C   10BD               POP      {R4,PC}          ;; return
    606          }
    607          #endif
    608          /*$PAGE*/
    609          /*
    610          *********************************************************************************************************
    611          *                                        GET THE NAME OF A TASK
    612          *
    613          * Description: This function is called to obtain the name of a task.
    614          *
    615          * Arguments  : prio      is the priority of the task that you want to obtain the name from.
    616          *
    617          *              pname     is a pointer to an ASCII string that will receive the name of the task.  The
    618          *                        string must be able to hold at least OS_TASK_NAME_SIZE characters.
    619          *
    620          *              perr      is a pointer to an error code that can contain one of the following values:
    621          *
    622          *                        OS_ERR_NONE                if the requested task is resumed
    623          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    624          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    625          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    626          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    627          *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
    628          *                        
    629          *
    630          * Returns    : The length of the string or 0 if the task does not exist.
    631          *********************************************************************************************************
    632          */
    633          
    634          #if OS_TASK_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    635          INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
    636          {
   \                     OSTaskNameGet:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0646               MOV      R6,R0
   \   00000004   0D46               MOV      R5,R1
   \   00000006   1400               MOVS     R4,R2
    637              OS_TCB    *ptcb;
    638              INT8U      len;
    639          #if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    640              OS_CPU_SR  cpu_sr = 0;
    641          #endif
    642          
    643          
    644          
    645          #if OS_ARG_CHK_EN > 0
    646              if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
   \   00000008   01D1               BNE.N    ??OSTaskNameGet_0
    647                  return (0);
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   F2BD               POP      {R1,R4-R7,PC}
    648              }
    649              if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
   \                     ??OSTaskNameGet_0:
   \   0000000E   202E               CMP      R6,#+32
   \   00000010   05D3               BCC.N    ??OSTaskNameGet_1
    650                  if (prio != OS_PRIO_SELF) {
   \   00000012   FF2E               CMP      R6,#+255
   \   00000014   03D0               BEQ.N    ??OSTaskNameGet_1
    651                      *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
   \   00000016   2A20               MOVS     R0,#+42
   \   00000018   2070               STRB     R0,[R4, #+0]
    652                      return (0);
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   F2BD               POP      {R1,R4-R7,PC}
    653                  }
    654              }
    655              if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
   \                     ??OSTaskNameGet_1:
   \   0000001E   002D               CMP      R5,#+0
   \   00000020   03D1               BNE.N    ??OSTaskNameGet_2
    656                  *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
   \   00000022   0C20               MOVS     R0,#+12
   \   00000024   2070               STRB     R0,[R4, #+0]
    657                  return (0);
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   F2BD               POP      {R1,R4-R7,PC}
    658              }
    659          #endif
    660              if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
   \                     ??OSTaskNameGet_2:
   \   0000002A   ....               LDR.N    R0,??DataTable22  ;; OSIntNesting
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??OSTaskNameGet_3
    661                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000032   1120               MOVS     R0,#+17
   \   00000034   2070               STRB     R0,[R4, #+0]
    662                  return (0);
   \   00000036   0020               MOVS     R0,#+0
   \   00000038   F2BD               POP      {R1,R4-R7,PC}
    663              }
    664              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameGet_3:
   \   0000003A   ........           BL       OS_CPU_SR_Save
   \   0000003E   0746               MOV      R7,R0
    665              if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
   \   00000040   FF2E               CMP      R6,#+255
   \   00000042   03D1               BNE.N    ??OSTaskNameGet_4
    666                  prio = OSTCBCur->OSTCBPrio;
   \   00000044   ....               LDR.N    R0,??DataTable35  ;; OSTCBCur
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   90F83260           LDRB     R6,[R0, #+50]
    667              }
    668              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameGet_4:
   \   0000004C   ....               LDR.N    R0,??DataTable36  ;; OSTCBPrioTbl
   \   0000004E   50F82600           LDR      R0,[R0, R6, LSL #+2]
    669              if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
   \   00000052   0028               CMP      R0,#+0
   \   00000054   06D1               BNE.N    ??OSTaskNameGet_5
    670                  OS_EXIT_CRITICAL();                              /* No                                         */
   \                     ??OSTaskNameGet_6:
   \   00000056   3846               MOV      R0,R7
   \   00000058   ........           BL       OS_CPU_SR_Restore
    671                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000005C   4320               MOVS     R0,#+67
   \   0000005E   2070               STRB     R0,[R4, #+0]
    672                  return (0);
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   F2BD               POP      {R1,R4-R7,PC}
    673              }
    674              if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
   \                     ??OSTaskNameGet_5:
   \   00000064   0128               CMP      R0,#+1
   \   00000066   F6D0               BEQ.N    ??OSTaskNameGet_6
    675                  OS_EXIT_CRITICAL();                              /* Yes                                        */
    676                  *perr = OS_ERR_TASK_NOT_EXIST;
    677                  return (0);
    678              }
    679              len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
   \   00000068   00F14C01           ADD      R1,R0,#+76
   \   0000006C   2846               MOV      R0,R5
   \   0000006E   ........           BL       OS_StrCopy
   \   00000072   0546               MOV      R5,R0
    680              OS_EXIT_CRITICAL();
   \   00000074   3846               MOV      R0,R7
   \   00000076   ........           BL       OS_CPU_SR_Restore
    681              *perr = OS_ERR_NONE;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   2070               STRB     R0,[R4, #+0]
    682              return (len);
   \   0000007E   2846               MOV      R0,R5
   \   00000080   F2BD               POP      {R1,R4-R7,PC}    ;; return
    683          }
    684          #endif
    685          
    686          /*$PAGE*/
    687          /*
    688          *********************************************************************************************************
    689          *                                        ASSIGN A NAME TO A TASK
    690          *
    691          * Description: This function is used to set the name of a task.
    692          *
    693          * Arguments  : prio      is the priority of the task that you want the assign a name to.
    694          *
    695          *              pname     is a pointer to an ASCII string that contains the name of the task.  The ASCII
    696          *                        string must be NUL terminated.
    697          *
    698          *              perr       is a pointer to an error code that can contain one of the following values:
    699          *
    700          *                        OS_ERR_NONE                if the requested task is resumed
    701          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    702          *                        OS_ERR_TASK_NAME_TOO_LONG  if the name you are giving to the task exceeds the
    703          *                                                   storage capacity of a task name as specified by
    704          *                                                   OS_TASK_NAME_SIZE.
    705          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    706          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    707          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    708          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    709          *
    710          * Returns    : None
    711          *********************************************************************************************************
    712          */
    713          #if OS_TASK_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    714          void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
    715          {
   \                     OSTaskNameSet:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0646               MOV      R6,R0
   \   00000004   0C46               MOV      R4,R1
   \   00000006   1500               MOVS     R5,R2
    716              INT8U      len;
    717              OS_TCB    *ptcb;
    718          #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    719              OS_CPU_SR  cpu_sr = 0;
    720          #endif
    721          
    722          
    723          
    724          #if OS_ARG_CHK_EN > 0
    725              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
   \   00000008   3DD0               BEQ.N    ??OSTaskNameSet_0
    726                  return;
    727              }
    728              if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
   \   0000000A   202E               CMP      R6,#+32
   \   0000000C   04D3               BCC.N    ??OSTaskNameSet_1
    729                  if (prio != OS_PRIO_SELF) {
   \   0000000E   FF2E               CMP      R6,#+255
   \   00000010   02D0               BEQ.N    ??OSTaskNameSet_1
    730                      *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
   \   00000012   2A20               MOVS     R0,#+42
   \   00000014   2870               STRB     R0,[R5, #+0]
    731                      return;
   \   00000016   F1BD               POP      {R0,R4-R7,PC}
    732                  }
    733              }
    734              if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
   \                     ??OSTaskNameSet_1:
   \   00000018   002C               CMP      R4,#+0
   \   0000001A   02D1               BNE.N    ??OSTaskNameSet_2
    735                  *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
   \   0000001C   0C20               MOVS     R0,#+12
   \   0000001E   2870               STRB     R0,[R5, #+0]
    736                  return;
   \   00000020   F1BD               POP      {R0,R4-R7,PC}
    737              }
    738          #endif
    739              if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
   \                     ??OSTaskNameSet_2:
   \   00000022   ....               LDR.N    R0,??DataTable22  ;; OSIntNesting
   \   00000024   0078               LDRB     R0,[R0, #+0]
   \   00000026   0028               CMP      R0,#+0
   \   00000028   02D0               BEQ.N    ??OSTaskNameSet_3
    740                  *perr = OS_ERR_NAME_SET_ISR;
   \   0000002A   1220               MOVS     R0,#+18
   \   0000002C   2870               STRB     R0,[R5, #+0]
    741                  return;
   \   0000002E   F1BD               POP      {R0,R4-R7,PC}
    742              }
    743              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameSet_3:
   \   00000030   ........           BL       OS_CPU_SR_Save
   \   00000034   0746               MOV      R7,R0
    744              if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
   \   00000036   FF2E               CMP      R6,#+255
   \   00000038   03D1               BNE.N    ??OSTaskNameSet_4
    745                  prio = OSTCBCur->OSTCBPrio;
   \   0000003A   ....               LDR.N    R0,??DataTable35  ;; OSTCBCur
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   90F83260           LDRB     R6,[R0, #+50]
    746              }
    747              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameSet_4:
   \   00000042   ....               LDR.N    R0,??DataTable36  ;; OSTCBPrioTbl
   \   00000044   50F82660           LDR      R6,[R0, R6, LSL #+2]
    748              if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
   \   00000048   002E               CMP      R6,#+0
   \   0000004A   05D1               BNE.N    ??OSTaskNameSet_5
    749                  OS_EXIT_CRITICAL();                          /* No                                             */
   \                     ??OSTaskNameSet_6:
   \   0000004C   3846               MOV      R0,R7
   \   0000004E   ........           BL       OS_CPU_SR_Restore
    750                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   00000052   4320               MOVS     R0,#+67
   \   00000054   2870               STRB     R0,[R5, #+0]
    751                  return;
   \   00000056   F1BD               POP      {R0,R4-R7,PC}
    752              }
    753              if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
   \                     ??OSTaskNameSet_5:
   \   00000058   012E               CMP      R6,#+1
   \   0000005A   F7D0               BEQ.N    ??OSTaskNameSet_6
    754                  OS_EXIT_CRITICAL();                          /* Yes                                            */
    755                  *perr = OS_ERR_TASK_NOT_EXIST;
    756                  return;
    757              }
    758              len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
   \   0000005C   2046               MOV      R0,R4
   \   0000005E   ........           BL       OS_StrLen
    759              if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
   \   00000062   1028               CMP      R0,#+16
   \   00000064   05D3               BCC.N    ??OSTaskNameSet_7
    760                  OS_EXIT_CRITICAL();
   \   00000066   3846               MOV      R0,R7
   \   00000068   ........           BL       OS_CPU_SR_Restore
    761                  *perr = OS_ERR_TASK_NAME_TOO_LONG;
   \   0000006C   4120               MOVS     R0,#+65
   \   0000006E   2870               STRB     R0,[R5, #+0]
    762                  return;
   \   00000070   F1BD               POP      {R0,R4-R7,PC}
    763              }
    764              (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
   \                     ??OSTaskNameSet_7:
   \   00000072   2146               MOV      R1,R4
   \   00000074   06F14C00           ADD      R0,R6,#+76
   \   00000078   ........           BL       OS_StrCopy
    765              OS_EXIT_CRITICAL();
   \   0000007C   3846               MOV      R0,R7
   \   0000007E   ........           BL       OS_CPU_SR_Restore
    766              *perr = OS_ERR_NONE;
   \   00000082   0020               MOVS     R0,#+0
   \   00000084   2870               STRB     R0,[R5, #+0]
    767          }
   \                     ??OSTaskNameSet_0:
   \   00000086   F1BD               POP      {R0,R4-R7,PC}    ;; return
    768          #endif
    769          
    770          /*$PAGE*/
    771          /*
    772          *********************************************************************************************************
    773          *                                        RESUME A SUSPENDED TASK
    774          *
    775          * Description: This function is called to resume a previously suspended task.  This is the only call that
    776          *              will remove an explicit task suspension.
    777          *
    778          * Arguments  : prio     is the priority of the task to resume.
    779          *
    780          * Returns    : OS_ERR_NONE                if the requested task is resumed
    781          *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
    782          *                                         (i.e. >= OS_LOWEST_PRIO)
    783          *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
    784          *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
    785          *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
    786          *********************************************************************************************************
    787          */
    788          
    789          #if OS_TASK_SUSPEND_EN > 0

   \                                 In section .text, align 2, keep-with-next
    790          INT8U  OSTaskResume (INT8U prio)
    791          {
   \                     OSTaskResume:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0446               MOV      R4,R0
    792              OS_TCB    *ptcb;
    793          #if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    794              OS_CPU_SR  cpu_sr = 0;
    795          #endif
    796          
    797          
    798          
    799          #if OS_ARG_CHK_EN > 0
    800              if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
   \   00000004   1F2C               CMP      R4,#+31
   \   00000006   01D3               BCC.N    ??OSTaskResume_0
    801                  return (OS_ERR_PRIO_INVALID);
   \   00000008   2A20               MOVS     R0,#+42
   \   0000000A   10BD               POP      {R4,PC}
    802              }
    803          #endif
    804              OS_ENTER_CRITICAL();
   \                     ??OSTaskResume_0:
   \   0000000C   ........           BL       OS_CPU_SR_Save
    805              ptcb = OSTCBPrioTbl[prio];
   \   00000010   ....               LDR.N    R1,??DataTable36  ;; OSTCBPrioTbl
   \   00000012   51F82420           LDR      R2,[R1, R4, LSL #+2]
    806              if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
   \   00000016   002A               CMP      R2,#+0
   \   00000018   03D1               BNE.N    ??OSTaskResume_1
    807                  OS_EXIT_CRITICAL();
   \   0000001A   ........           BL       OS_CPU_SR_Restore
    808                  return (OS_ERR_TASK_RESUME_PRIO);
   \   0000001E   4620               MOVS     R0,#+70
   \   00000020   10BD               POP      {R4,PC}
    809              }
    810              if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
   \                     ??OSTaskResume_1:
   \   00000022   012A               CMP      R2,#+1
   \   00000024   03D1               BNE.N    ??OSTaskResume_2
    811                  OS_EXIT_CRITICAL();
   \   00000026   ........           BL       OS_CPU_SR_Restore
    812                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000002A   4320               MOVS     R0,#+67
   \   0000002C   10BD               POP      {R4,PC}
    813              }
    814              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
   \                     ??OSTaskResume_2:
   \   0000002E   02F12E01           ADD      R1,R2,#+46
   \   00000032   8B78               LDRB     R3,[R1, #+2]
   \   00000034   13F0080F           TST      R3,#0x8
   \   00000038   20D0               BEQ.N    ??OSTaskResume_3
    815                  ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
   \   0000003A   23F00803           BIC      R3,R3,#0x8
   \   0000003E   8B70               STRB     R3,[R1, #+2]
    816                  if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
   \   00000040   002B               CMP      R3,#+0
   \   00000042   17D1               BNE.N    ??OSTaskResume_4
    817                      if (ptcb->OSTCBDly == 0) {
   \   00000044   D28D               LDRH     R2,[R2, #+46]
   \   00000046   002A               CMP      R2,#+0
   \   00000048   14D1               BNE.N    ??OSTaskResume_4
    818                          OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
   \   0000004A   ....               LDR.N    R2,??DataTable34  ;; OSRdyGrp
   \   0000004C   1378               LDRB     R3,[R2, #+0]
   \   0000004E   0C7A               LDRB     R4,[R1, #+8]
   \   00000050   2343               ORRS     R3,R4,R3
   \   00000052   1370               STRB     R3,[R2, #+0]
    819                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000054   ....               LDR.N    R2,??DataTable33  ;; OSRdyTbl
   \   00000056   8B79               LDRB     R3,[R1, #+6]
   \   00000058   9B5C               LDRB     R3,[R3, R2]
   \   0000005A   CC79               LDRB     R4,[R1, #+7]
   \   0000005C   2343               ORRS     R3,R4,R3
   \   0000005E   8979               LDRB     R1,[R1, #+6]
   \   00000060   8B54               STRB     R3,[R1, R2]
    820                          OS_EXIT_CRITICAL();
   \   00000062   ........           BL       OS_CPU_SR_Restore
    821                          if (OSRunning == OS_TRUE) {
   \   00000066   ....               LDR.N    R0,??DataTable28  ;; OSRunning
   \   00000068   0078               LDRB     R0,[R0, #+0]
   \   0000006A   0128               CMP      R0,#+1
   \   0000006C   04D1               BNE.N    ??OSTaskResume_5
    822                              OS_Sched();                               /* Find new highest priority task        */
   \   0000006E   ........           BL       OS_Sched
   \   00000072   01E0               B.N      ??OSTaskResume_5
    823                          }
    824                      } else {
    825                          OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_4:
   \   00000074   ........           BL       OS_CPU_SR_Restore
    826                      }
    827                  } else {                                              /* Must be pending on event              */
    828                      OS_EXIT_CRITICAL();
    829                  }
    830                  return (OS_ERR_NONE);
   \                     ??OSTaskResume_5:
   \   00000078   0020               MOVS     R0,#+0
   \   0000007A   10BD               POP      {R4,PC}
    831              }
    832              OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_3:
   \   0000007C   ........           BL       OS_CPU_SR_Restore
    833              return (OS_ERR_TASK_NOT_SUSPENDED);
   \   00000080   4420               MOVS     R0,#+68
   \   00000082   10BD               POP      {R4,PC}          ;; return
    834          }
    835          #endif
    836          /*$PAGE*/
    837          /*
    838          *********************************************************************************************************
    839          *                                             STACK CHECKING
    840          *
    841          * Description: This function is called to check the amount of free memory left on the specified task's
    842          *              stack.
    843          *
    844          * Arguments  : prio          is the task priority
    845          *
    846          *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
    847          *
    848          * Returns    : OS_ERR_NONE            upon success
    849          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    850          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    851          *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
    852          *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
    853          *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
    854          *********************************************************************************************************
    855          */
    856          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
    857          INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
    858          {
   \                     OSTaskStkChk:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
    859              OS_TCB    *ptcb;
    860              OS_STK    *pchk;
    861              INT32U     nfree;
    862              INT32U     size;
    863          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    864              OS_CPU_SR  cpu_sr = 0;
    865          #endif
    866          
    867          
    868          
    869          #if OS_ARG_CHK_EN > 0
    870              if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
   \   00000006   202D               CMP      R5,#+32
   \   00000008   03D3               BCC.N    ??OSTaskStkChk_0
    871                  if (prio != OS_PRIO_SELF) {
   \   0000000A   FF2D               CMP      R5,#+255
   \   0000000C   01D0               BEQ.N    ??OSTaskStkChk_0
    872                      return (OS_ERR_PRIO_INVALID);
   \   0000000E   2A20               MOVS     R0,#+42
   \   00000010   F2BD               POP      {R1,R4-R7,PC}
    873                  }
    874              }
    875              if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
   \                     ??OSTaskStkChk_0:
   \   00000012   002C               CMP      R4,#+0
   \   00000014   01D1               BNE.N    ??OSTaskStkChk_1
    876                  return (OS_ERR_PDATA_NULL);
   \   00000016   0920               MOVS     R0,#+9
   \   00000018   F2BD               POP      {R1,R4-R7,PC}
    877              }
    878          #endif
    879              p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
   \                     ??OSTaskStkChk_1:
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   2060               STR      R0,[R4, #+0]
    880              p_stk_data->OSUsed = 0;
   \   0000001E   6060               STR      R0,[R4, #+4]
    881              OS_ENTER_CRITICAL();
   \   00000020   ........           BL       OS_CPU_SR_Save
    882              if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
   \   00000024   FF2D               CMP      R5,#+255
   \   00000026   03D1               BNE.N    ??OSTaskStkChk_2
    883                  prio = OSTCBCur->OSTCBPrio;
   \   00000028   ....               LDR.N    R1,??DataTable35  ;; OSTCBCur
   \   0000002A   0968               LDR      R1,[R1, #+0]
   \   0000002C   91F83250           LDRB     R5,[R1, #+50]
    884              }
    885              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskStkChk_2:
   \   00000030   ....               LDR.N    R1,??DataTable36  ;; OSTCBPrioTbl
   \   00000032   51F82510           LDR      R1,[R1, R5, LSL #+2]
    886              if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
   \   00000036   0029               CMP      R1,#+0
   \   00000038   03D1               BNE.N    ??OSTaskStkChk_3
    887                  OS_EXIT_CRITICAL();
   \                     ??OSTaskStkChk_4:
   \   0000003A   ........           BL       OS_CPU_SR_Restore
    888                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000003E   4320               MOVS     R0,#+67
   \   00000040   F2BD               POP      {R1,R4-R7,PC}
    889              }
    890              if (ptcb == OS_TCB_RESERVED) {
   \                     ??OSTaskStkChk_3:
   \   00000042   0129               CMP      R1,#+1
   \   00000044   F9D0               BEQ.N    ??OSTaskStkChk_4
    891                  OS_EXIT_CRITICAL();
    892                  return (OS_ERR_TASK_NOT_EXIST);
    893              }
    894              if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
   \   00000046   0A8A               LDRH     R2,[R1, #+16]
   \   00000048   12F0010F           TST      R2,#0x1
   \   0000004C   03D1               BNE.N    ??OSTaskStkChk_5
    895                  OS_EXIT_CRITICAL();
   \   0000004E   ........           BL       OS_CPU_SR_Restore
    896                  return (OS_ERR_TASK_OPT);
   \   00000052   4520               MOVS     R0,#+69
   \   00000054   F2BD               POP      {R1,R4-R7,PC}
    897              }
    898              nfree = 0;
   \                     ??OSTaskStkChk_5:
   \   00000056   0025               MOVS     R5,#+0
    899              size  = ptcb->OSTCBStkSize;
   \   00000058   CE68               LDR      R6,[R1, #+12]
    900              pchk  = ptcb->OSTCBStkBottom;
   \   0000005A   8F68               LDR      R7,[R1, #+8]
    901              OS_EXIT_CRITICAL();
   \   0000005C   ........           BL       OS_CPU_SR_Restore
   \   00000060   00E0               B.N      ??OSTaskStkChk_6
    902          #if OS_STK_GROWTH == 1
    903              while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    904                  nfree++;
   \                     ??OSTaskStkChk_7:
   \   00000062   6D1C               ADDS     R5,R5,#+1
    905              }
   \                     ??OSTaskStkChk_6:
   \   00000064   57F8040B           LDR      R0,[R7], #+4
   \   00000068   0028               CMP      R0,#+0
   \   0000006A   FAD0               BEQ.N    ??OSTaskStkChk_7
    906          #else
    907              while (*pchk-- == (OS_STK)0) {
    908                  nfree++;
    909              }
    910          #endif
    911              p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
   \   0000006C   A800               LSLS     R0,R5,#+2
   \   0000006E   2060               STR      R0,[R4, #+0]
    912              p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
   \   00000070   701B               SUBS     R0,R6,R5
   \   00000072   8000               LSLS     R0,R0,#+2
   \   00000074   6060               STR      R0,[R4, #+4]
    913              return (OS_ERR_NONE);
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   F2BD               POP      {R1,R4-R7,PC}    ;; return
    914          }
    915          #endif
    916          /*$PAGE*/
    917          /*
    918          *********************************************************************************************************
    919          *                                            SUSPEND A TASK
    920          *
    921          * Description: This function is called to suspend a task.  The task can be the calling task if the
    922          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
    923          *
    924          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
    925          *                       calling task will suspend itself and rescheduling will occur.
    926          *
    927          * Returns    : OS_ERR_NONE               if the requested task is suspended
    928          *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
    929          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    930          *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    931          *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
    932          *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
    933          *
    934          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
    935          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
    936          *              running when the event arrives.
    937          *********************************************************************************************************
    938          */
    939          
    940          #if OS_TASK_SUSPEND_EN > 0

   \                                 In section .text, align 2, keep-with-next
    941          INT8U  OSTaskSuspend (INT8U prio)
    942          {
   \                     OSTaskSuspend:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0546               MOV      R5,R0
    943              BOOLEAN    self;
    944              OS_TCB    *ptcb;
    945              INT8U      y;
    946          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    947              OS_CPU_SR  cpu_sr = 0;
    948          #endif
    949          
    950          
    951          
    952          #if OS_ARG_CHK_EN > 0
    953              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
   \   00000004   1F2D               CMP      R5,#+31
   \   00000006   01D1               BNE.N    ??OSTaskSuspend_0
    954                  return (OS_ERR_TASK_SUSPEND_IDLE);
   \   00000008   4720               MOVS     R0,#+71
   \   0000000A   F2BD               POP      {R1,R4-R7,PC}
    955              }
    956              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
   \                     ??OSTaskSuspend_0:
   \   0000000C   03D3               BCC.N    ??OSTaskSuspend_1
    957                  if (prio != OS_PRIO_SELF) {
   \   0000000E   FF2D               CMP      R5,#+255
   \   00000010   01D0               BEQ.N    ??OSTaskSuspend_1
    958                      return (OS_ERR_PRIO_INVALID);
   \   00000012   2A20               MOVS     R0,#+42
   \   00000014   F2BD               POP      {R1,R4-R7,PC}
    959                  }
    960              }
    961          #endif
    962              OS_ENTER_CRITICAL();
   \                     ??OSTaskSuspend_1:
   \   00000016   ........           BL       OS_CPU_SR_Save
    963              if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
   \   0000001A   ....               LDR.N    R1,??DataTable35  ;; OSTCBCur
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   FF2D               CMP      R5,#+255
   \   00000020   03D1               BNE.N    ??OSTaskSuspend_2
    964                  prio = OSTCBCur->OSTCBPrio;
   \   00000022   91F83250           LDRB     R5,[R1, #+50]
    965                  self = OS_TRUE;
   \   00000026   0124               MOVS     R4,#+1
   \   00000028   06E0               B.N      ??OSTaskSuspend_3
    966              } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
   \                     ??OSTaskSuspend_2:
   \   0000002A   91F83210           LDRB     R1,[R1, #+50]
   \   0000002E   8D42               CMP      R5,R1
   \   00000030   01D1               BNE.N    ??OSTaskSuspend_4
    967                  self = OS_TRUE;
   \   00000032   0124               MOVS     R4,#+1
   \   00000034   00E0               B.N      ??OSTaskSuspend_3
    968              } else {
    969                  self = OS_FALSE;                                        /* No suspending another task          */
   \                     ??OSTaskSuspend_4:
   \   00000036   0024               MOVS     R4,#+0
    970              }
    971              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskSuspend_3:
   \   00000038   ....               LDR.N    R1,??DataTable36  ;; OSTCBPrioTbl
   \   0000003A   51F82510           LDR      R1,[R1, R5, LSL #+2]
    972              if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
   \   0000003E   0029               CMP      R1,#+0
   \   00000040   03D1               BNE.N    ??OSTaskSuspend_5
    973                  OS_EXIT_CRITICAL();
   \   00000042   ........           BL       OS_CPU_SR_Restore
    974                  return (OS_ERR_TASK_SUSPEND_PRIO);
   \   00000046   4820               MOVS     R0,#+72
   \   00000048   F2BD               POP      {R1,R4-R7,PC}
    975              }
    976              if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
   \                     ??OSTaskSuspend_5:
   \   0000004A   0129               CMP      R1,#+1
   \   0000004C   03D1               BNE.N    ??OSTaskSuspend_6
    977                  OS_EXIT_CRITICAL();
   \   0000004E   ........           BL       OS_CPU_SR_Restore
    978                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000052   4320               MOVS     R0,#+67
   \   00000054   F2BD               POP      {R1,R4-R7,PC}
    979              }
    980              y            = ptcb->OSTCBY;
   \                     ??OSTaskSuspend_6:
   \   00000056   01F13002           ADD      R2,R1,#+48
   \   0000005A   1379               LDRB     R3,[R2, #+4]
    981              OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
   \   0000005C   ....               LDR.N    R5,??DataTable33  ;; OSRdyTbl
   \   0000005E   5E5D               LDRB     R6,[R3, R5]
   \   00000060   5779               LDRB     R7,[R2, #+5]
   \   00000062   FF43               MVNS     R7,R7
   \   00000064   3E40               ANDS     R6,R7,R6
   \   00000066   5E55               STRB     R6,[R3, R5]
    982              if (OSRdyTbl[y] == 0) {
   \   00000068   05D1               BNE.N    ??OSTaskSuspend_7
    983                  OSRdyGrp &= ~ptcb->OSTCBBitY;
   \   0000006A   ....               LDR.N    R3,??DataTable34  ;; OSRdyGrp
   \   0000006C   1D78               LDRB     R5,[R3, #+0]
   \   0000006E   9279               LDRB     R2,[R2, #+6]
   \   00000070   D243               MVNS     R2,R2
   \   00000072   2A40               ANDS     R2,R2,R5
   \   00000074   1A70               STRB     R2,[R3, #+0]
    984              }
    985              ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
   \                     ??OSTaskSuspend_7:
   \   00000076   91F83020           LDRB     R2,[R1, #+48]
   \   0000007A   42F00802           ORR      R2,R2,#0x8
   \   0000007E   81F83020           STRB     R2,[R1, #+48]
    986              OS_EXIT_CRITICAL();
   \   00000082   ........           BL       OS_CPU_SR_Restore
    987              if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
   \   00000086   012C               CMP      R4,#+1
   \   00000088   01D1               BNE.N    ??OSTaskSuspend_8
    988                  OS_Sched();                                             /* Find new highest priority task      */
   \   0000008A   ........           BL       OS_Sched
    989              }
    990              return (OS_ERR_NONE);
   \                     ??OSTaskSuspend_8:
   \   0000008E   0020               MOVS     R0,#+0
   \   00000090   F2BD               POP      {R1,R4-R7,PC}    ;; return
    991          }
    992          #endif
    993          /*$PAGE*/
    994          /*
    995          *********************************************************************************************************
    996          *                                            QUERY A TASK
    997          *
    998          * Description: This function is called to obtain a copy of the desired task's TCB.
    999          *
   1000          * Arguments  : prio         is the priority of the task to obtain information from.
   1001          *
   1002          *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
   1003          *
   1004          * Returns    : OS_ERR_NONE            if the requested task is suspended
   1005          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
   1006          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
   1007          *              OS_ERR_PRIO            if the desired task has not been created
   1008          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
   1009          *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
   1010          *********************************************************************************************************
   1011          */
   1012          
   1013          #if OS_TASK_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1014          INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
   1015          {
   \                     OSTaskQuery:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0646               MOV      R6,R0
   \   00000004   0C46               MOV      R4,R1
   1016              OS_TCB    *ptcb;
   1017          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1018              OS_CPU_SR  cpu_sr = 0;
   1019          #endif
   1020          
   1021          
   1022          
   1023          #if OS_ARG_CHK_EN > 0
   1024              if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
   \   00000006   202E               CMP      R6,#+32
   \   00000008   03D3               BCC.N    ??OSTaskQuery_0
   1025                  if (prio != OS_PRIO_SELF) {
   \   0000000A   FF2E               CMP      R6,#+255
   \   0000000C   01D0               BEQ.N    ??OSTaskQuery_0
   1026                      return (OS_ERR_PRIO_INVALID);
   \   0000000E   2A20               MOVS     R0,#+42
   \   00000010   70BD               POP      {R4-R6,PC}
   1027                  }
   1028              }
   1029              if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
   \                     ??OSTaskQuery_0:
   \   00000012   002C               CMP      R4,#+0
   \   00000014   01D1               BNE.N    ??OSTaskQuery_1
   1030                  return (OS_ERR_PDATA_NULL);
   \   00000016   0920               MOVS     R0,#+9
   \   00000018   70BD               POP      {R4-R6,PC}
   1031              }
   1032          #endif
   1033              OS_ENTER_CRITICAL();
   \                     ??OSTaskQuery_1:
   \   0000001A   ........           BL       OS_CPU_SR_Save
   \   0000001E   0546               MOV      R5,R0
   1034              if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
   \   00000020   FF2E               CMP      R6,#+255
   \   00000022   03D1               BNE.N    ??OSTaskQuery_2
   1035                  prio = OSTCBCur->OSTCBPrio;
   \   00000024   ....               LDR.N    R0,??DataTable35  ;; OSTCBCur
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   90F83260           LDRB     R6,[R0, #+50]
   1036              }
   1037              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskQuery_2:
   \   0000002C   ....               LDR.N    R0,??DataTable36  ;; OSTCBPrioTbl
   \   0000002E   50F82610           LDR      R1,[R0, R6, LSL #+2]
   1038              if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
   \   00000032   0029               CMP      R1,#+0
   \   00000034   04D1               BNE.N    ??OSTaskQuery_3
   1039                  OS_EXIT_CRITICAL();
   \   00000036   2846               MOV      R0,R5
   \   00000038   ........           BL       OS_CPU_SR_Restore
   1040                  return (OS_ERR_PRIO);
   \   0000003C   2920               MOVS     R0,#+41
   \   0000003E   70BD               POP      {R4-R6,PC}
   1041              }
   1042              if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
   \                     ??OSTaskQuery_3:
   \   00000040   0129               CMP      R1,#+1
   \   00000042   04D1               BNE.N    ??OSTaskQuery_4
   1043                  OS_EXIT_CRITICAL();
   \   00000044   2846               MOV      R0,R5
   \   00000046   ........           BL       OS_CPU_SR_Restore
   1044                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000004A   4320               MOVS     R0,#+67
   \   0000004C   70BD               POP      {R4-R6,PC}
   1045              }
   1046                                                           /* Copy TCB into user storage area                    */
   1047              OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
   \                     ??OSTaskQuery_4:
   \   0000004E   5C22               MOVS     R2,#+92
   \   00000050   2046               MOV      R0,R4
   \   00000052   ........           BL       OS_MemCopy
   1048              OS_EXIT_CRITICAL();
   \   00000056   2846               MOV      R0,R5
   \   00000058   ........           BL       OS_CPU_SR_Restore
   1049              return (OS_ERR_NONE);
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   70BD               POP      {R4-R6,PC}       ;; return
   1050          }
   1051          #endif
   1052          /*$PAGE*/
   1053          /*
   1054          *********************************************************************************************************
   1055          *                                        CLEAR TASK STACK
   1056          *
   1057          * Description: This function is used to clear the stack of a task (i.e. write all zeros)
   1058          *
   1059          * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
   1060          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
   1061          *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
   1062          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
   1063          *                       highest memory location of the stack and the stack will grow with increasing
   1064          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
   1065          *
   1066          *              size     is the number of 'stack elements' to clear.
   1067          *
   1068          *              opt      contains additional information (or options) about the behavior of the task.  The
   1069          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
   1070          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
   1071          *
   1072          * Returns    : none
   1073          *********************************************************************************************************
   1074          */
   1075          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1076          void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
   1077          {
   1078              if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
   \                     OS_TaskStkClr:
   \   00000000   02F00302           AND      R2,R2,#0x3
   \   00000004   032A               CMP      R2,#+3
   \   00000006   06D1               BNE.N    ??OS_TaskStkClr_0
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   0029               CMP      R1,#+0
   \   0000000C   02E0               B.N      ??OS_TaskStkClr_1
   1079                  if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
   1080          #if OS_STK_GROWTH == 1
   1081                      while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
   1082                          size--;
   \                     ??OS_TaskStkClr_2:
   \   0000000E   491E               SUBS     R1,R1,#+1
   1083                          *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
   \   00000010   40F8042B           STR      R2,[R0], #+4
   1084                      }
   \                     ??OS_TaskStkClr_1:
   \   00000014   FBD1               BNE.N    ??OS_TaskStkClr_2
   1085          #else
   1086                      while (size > 0) {                         /* Stack grows from LOW to HIGH memory          */
   1087                          size--;
   1088                          *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
   1089                      }
   1090          #endif
   1091                  }
   1092              }
   1093          }
   \                     ??OS_TaskStkClr_0:
   \   00000016   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   ........           DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   ........           DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   ........           DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   ........           DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   ........           DC32     OSTCBPrioTbl
   1094          
   1095          #endif

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     OSTaskChangePrio     48
     OSTaskCreate         48
     OSTaskCreateExt      64
     OSTaskDel            32
     OSTaskDelReq          8
     OSTaskNameGet        24
     OSTaskNameSet        24
     OSTaskQuery          16
     OSTaskResume          8
     OSTaskStkChk         24
     OSTaskSuspend        24
     OS_TaskStkClr         0


   Section sizes:

     Function/Label   Bytes
     --------------   -----
     OSTaskChangePrio  462
     OSTaskCreate      156
     OSTaskCreateExt   188
     OSTaskDel         356
     OSTaskDelReq       94
     OSTaskNameGet     130
     OSTaskNameSet     136
     OSTaskResume      132
     OSTaskStkChk      122
     OSTaskSuspend     146
     OSTaskQuery        96
     OS_TaskStkClr      24
     ??DataTable22       4
     ??DataTable28       4
     ??DataTable33       4
     ??DataTable34       4
     ??DataTable35       4
     ??DataTable36       4

 
 2 066 bytes in section .text
 
 2 066 bytes of CODE memory

Errors: none
Warnings: none
