###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     28/Dec/2014  20:59:00 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_core.c                                 #
#    Command line =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_core.c -lCN                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\ -o   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\       #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "F:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\S #
#                    oftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\ -I      #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\BSP\ -I       #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\C #
#                    PU\ST\STM32\inc\ -I C:\Users\Administrator\Desktop\uCOS- #
#                    II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe- #
#                    LCD\..\..\..\..\..\uC-CPU\ -I                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-CPU\ARM-Cortex-M3\IAR\ -I                              #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-LCD\Source\ -I C:\Users\Administrator\Desktop\uCOS-II\ #
#                    Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD #
#                    \..\..\..\..\..\uC-LIB\ -I C:\Users\Administrator\Deskto #
#                    p\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS #
#                    -Probe-LCD\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Ge #
#                    neric\IAR\ -I C:\Users\Administrator\Desktop\uCOS-II\Mic #
#                    rium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\.. #
#                    \..\..\..\..\uCOS-II\Source\ -I                          #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM #
#                    32\ -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\So #
#                    ftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\ #
#                    ..\..\uC-Probe\Target\Communication\Generic\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Plugins\uCOS-II\ -I "F:\Program Files     #
#                    (x86)\IAR Systems\Embedded Workbench 5.4\arm\INC\" -Om   #
#    List file    =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\os_co #
#                    re.lst                                                   #
#    Object file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\os_cor #
#                    e.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          #include <ucos_ii.h>

   \                                 In section .bss, align 4
   \   INT8U __data OSCPUUsage
   \                     OSCPUUsage:
   \   00000000                      DS8 1
   \   BOOLEAN __data OSStatRdy
   \                     OSStatRdy:
   \   00000001                      DS8 1
   \   INT8U __data OSIntNesting
   \                     OSIntNesting:
   \   00000002                      DS8 1
   \   INT8U __data OSLockNesting
   \                     OSLockNesting:
   \   00000003                      DS8 1
   \   INT8U __data OSPrioCur
   \                     OSPrioCur:
   \   00000004                      DS8 1
   \   INT8U __data OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   00000005                      DS8 1
   \   INT8U __data OSRdyGrp
   \                     OSRdyGrp:
   \   00000006                      DS8 1
   \   BOOLEAN __data OSRunning
   \                     OSRunning:
   \   00000007                      DS8 1
   \   INT8U __data OSTaskCtr
   \                     OSTaskCtr:
   \   00000008                      DS8 1
   \   INT8U __data OSTickStepState
   \                     OSTickStepState:
   \   00000009                      DS8 1
   \   0000000A                      DS8 2
   \   INT8U __data OSRdyTbl[4]
   \                     OSRdyTbl:
   \   0000000C                      DS8 4
   \   INT32U __data OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   00000010                      DS8 4
   \   INT32U __data OSIdleCtrMax
   \                     OSIdleCtrMax:
   \   00000014                      DS8 4
   \   INT32U __data OSIdleCtrRun
   \                     OSIdleCtrRun:
   \   00000018                      DS8 4
   \   INT32U volatile __data OSIdleCtr
   \                     OSIdleCtr:
   \   0000001C                      DS8 4
   \   struct os_tcb *__data OSTCBCur
   \                     OSTCBCur:
   \   00000020                      DS8 4
   \   struct os_tcb *__data OSTCBFreeList
   \                     OSTCBFreeList:
   \   00000024                      DS8 4
   \   struct os_tcb *__data OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   00000028                      DS8 4
   \   struct os_tcb *__data OSTCBList
   \                     OSTCBList:
   \   0000002C                      DS8 4
   \   INT32U volatile __data OSTime
   \                     OSTime:
   \   00000030                      DS8 4
   \   OS_TCB __data OSTCBTbl[18U]
   \                     OSTCBTbl:
   \   00000034                      DS8 1656

   \                                 In section .bss, align 4
   \   struct os_event *__data OSEventFreeList
   \                     OSEventFreeList:
   \   00000000                      DS8 4
   \   OS_EVENT __data OSEventTbl[10]
   \                     OSEventTbl:
   \   00000004                      DS8 320

   \                                 In section .bss, align 4
   \   OS_FLAG_GRP __data OSFlagTbl[5]
   \                     OSFlagTbl:
   \   00000000                      DS8 140

   \                                 In section .bss, align 4
   \   struct os_flag_grp *__data OSFlagFreeList
   \                     OSFlagFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   OS_STK __data OSTaskStatStk[128]
   \                     OSTaskStatStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   OS_STK __data OSTaskIdleStk[128]
   \                     OSTaskIdleStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   struct os_tcb *__data OSTCBPrioTbl[32]
   \                     OSTCBPrioTbl:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
   \   struct os_mem *__data OSMemFreeList
   \                     OSMemFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   OS_MEM __data OSMemTbl[5]
   \                     OSMemTbl:
   \   00000000                      DS8 180

   \                                 In section .bss, align 4
   \   OS_Q *__data OSQFreeList
   \                     OSQFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   OS_Q __data OSQTbl[4]
   \                     OSQTbl:
   \   00000000                      DS8 96

   \                                 In section .bss, align 2
   \   INT16U __data OSTmrFree
   \                     OSTmrFree:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \   INT16U __data OSTmrUsed
   \                     OSTmrUsed:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   INT32U __data OSTmrTime
   \                     OSTmrTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   struct os_event *__data OSTmrSem
   \                     OSTmrSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   struct os_event *__data OSTmrSemSignal
   \                     OSTmrSemSignal:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   OS_TMR __data OSTmrTbl[16]
   \                     OSTmrTbl:
   \   00000000                      DS8 832

   \                                 In section .bss, align 4
   \   struct os_tmr *__data OSTmrFreeList
   \                     OSTmrFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   OS_STK __data OSTmrTaskStk[128]
   \                     OSTmrTaskStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   OS_TMR_WHEEL __data OSTmrWheelTbl[8]
   \                     OSTmrWheelTbl:
   \   00000000                      DS8 64
     27          #endif
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                       PRIORITY RESOLUTION TABLE
     32          *
     33          * Note: Index into table is bit pattern to resolve highest priority
     34          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     35          *********************************************************************************************************
     36          */
     37          

   \                                 In section .rodata, align 4
     38          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   00000000   000001000200       DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              010003000100
   \              020001000400
   \              0100020001  
   \   00000017   000300010002       DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              000100050001
   \              000200010003
   \              0001000200  
   \   0000002E   010004000100       DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              020001000300
   \              010002000100
   \              0600010002  
   \   00000045   000100030001       DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              000200010004
   \              000100020001
   \              0003000100  
   \   0000005C   020001000500       DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              010002000100
   \              030001000200
   \              0100040001  
   \   00000073   000200010003       DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              000100020001
   \              000700010002
   \              0001000300  
   \   0000008A   010002000100       DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              040001000200
   \              010003000100
   \              0200010005  
   \   000000A1   000100020001       DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              000300010002
   \              000100040001
   \              0002000100  
   \   000000B8   030001000200       DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              010006000100
   \              020001000300
   \              0100020001  
   \   000000CF   000400010002       DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              000100030001
   \              000200010005
   \              0001000200  
   \   000000E6   010003000100       DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              020001000400
   \              010002000100
   \              0300010002  
   \   000000FD   000100             DC8 0, 1, 0
     39              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
     40              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
     41              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
     42              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
     43              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
     44              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
     45              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
     46              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
     47              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
     48              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
     49              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
     50              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
     51              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
     52              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
     53              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
     54              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0        /* 0xF0 to 0xFF                             */
     55          };
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                       FUNCTION PROTOTYPES
     61          *********************************************************************************************************
     62          */
     63          
     64          static  void  OS_InitEventList(void);
     65          
     66          static  void  OS_InitMisc(void);
     67          
     68          static  void  OS_InitRdyList(void);
     69          
     70          static  void  OS_InitTaskIdle(void);
     71          
     72          #if OS_TASK_STAT_EN > 0
     73          static  void  OS_InitTaskStat(void);
     74          #endif
     75          
     76          static  void  OS_InitTCBList(void);
     77          
     78          static  void  OS_SchedNew(void);
     79          
     80          /*$PAGE*/
     81          /*
     82          *********************************************************************************************************
     83          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     84          *
     85          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     86          *
     87          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     88          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     89          *                        type is irrelevant.
     90          *
     91          *              pname     is a pointer to an ASCII string that will receive the name of the semaphore,
     92          *                        mutex, mailbox or queue.  The string must be able to hold at least
     93          *                        OS_EVENT_NAME_SIZE characters.
     94          *
     95          *              perr      is a pointer to an error code that can contain one of the following values:
     96          *
     97          *                        OS_ERR_NONE                if the name was copied to 'pname'
     98          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
     99          *                                                   control block type.
    100          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    101          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    102          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    103          *
    104          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    105          *********************************************************************************************************
    106          */
    107          
    108          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    109          INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    110          {
   \                     OSEventNameGet:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0E46               MOV      R6,R1
   \   00000006   1400               MOVS     R4,R2
    111              INT8U      len;
    112          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    113              OS_CPU_SR  cpu_sr = 0;
    114          #endif
    115          
    116          
    117          
    118          #if OS_ARG_CHK_EN > 0
    119              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
   \   00000008   01D1               BNE.N    ??OSEventNameGet_0
    120                  return (0);
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   F2BD               POP      {R1,R4-R7,PC}
    121              }
    122              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
   \                     ??OSEventNameGet_0:
   \   0000000E   002D               CMP      R5,#+0
   \   00000010   03D1               BNE.N    ??OSEventNameGet_1
    123                  *perr = OS_ERR_PEVENT_NULL;
   \   00000012   0420               MOVS     R0,#+4
   \   00000014   2070               STRB     R0,[R4, #+0]
    124                  return (0);
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   F2BD               POP      {R1,R4-R7,PC}
    125              }
    126              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
   \                     ??OSEventNameGet_1:
   \   0000001A   002E               CMP      R6,#+0
   \   0000001C   03D1               BNE.N    ??OSEventNameGet_2
    127                  *perr = OS_ERR_PNAME_NULL;
   \   0000001E   0C20               MOVS     R0,#+12
   \   00000020   2070               STRB     R0,[R4, #+0]
    128                  return (0);
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   F2BD               POP      {R1,R4-R7,PC}
    129              }
    130          #endif
    131              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \                     ??OSEventNameGet_2:
   \   00000026   ........           LDR.W    R0,??DataTable28  ;; OSCPUUsage
   \   0000002A   8078               LDRB     R0,[R0, #+2]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   03D0               BEQ.N    ??OSEventNameGet_3
    132                  *perr  = OS_ERR_NAME_GET_ISR;
   \   00000030   1120               MOVS     R0,#+17
   \   00000032   2070               STRB     R0,[R4, #+0]
    133                  return (0);
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   F2BD               POP      {R1,R4-R7,PC}
    134              }
    135              switch (pevent->OSEventType) {
   \                     ??OSEventNameGet_3:
   \   00000038   2878               LDRB     R0,[R5, #+0]
   \   0000003A   401E               SUBS     R0,R0,#+1
   \   0000003C   0328               CMP      R0,#+3
   \   0000003E   0FD8               BHI.N    ??OSEventNameGet_4
    136                  case OS_EVENT_TYPE_SEM:
    137                  case OS_EVENT_TYPE_MUTEX:
    138                  case OS_EVENT_TYPE_MBOX:
    139                  case OS_EVENT_TYPE_Q:
    140                       break;
    141          
    142                  default:
    143                       *perr = OS_ERR_EVENT_TYPE;
    144                       return (0);
    145              }
    146              OS_ENTER_CRITICAL();
   \   00000040   ........           BL       OS_CPU_SR_Save
   \   00000044   0746               MOV      R7,R0
    147              len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
   \   00000046   05F10F01           ADD      R1,R5,#+15
   \   0000004A   3046               MOV      R0,R6
   \   0000004C   ........           BL       OS_StrCopy
   \   00000050   0546               MOV      R5,R0
    148              OS_EXIT_CRITICAL();
   \   00000052   3846               MOV      R0,R7
   \   00000054   ........           BL       OS_CPU_SR_Restore
    149              *perr = OS_ERR_NONE;
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   2070               STRB     R0,[R4, #+0]
    150              return (len);
   \   0000005C   2846               MOV      R0,R5
   \   0000005E   F2BD               POP      {R1,R4-R7,PC}
   \                     ??OSEventNameGet_4:
   \   00000060   0120               MOVS     R0,#+1
   \   00000062   2070               STRB     R0,[R4, #+0]
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   F2BD               POP      {R1,R4-R7,PC}    ;; return
    151          }
    152          #endif
    153          
    154          /*$PAGE*/
    155          /*
    156          *********************************************************************************************************
    157          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    158          *
    159          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    160          *
    161          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    162          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    163          *                        matter the actual type.
    164          *
    165          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    166          *                        mutex, mailbox or queue.  The string must be able to hold at least
    167          *                        OS_EVENT_NAME_SIZE characters.
    168          *
    169          *              perr      is a pointer to an error code that can contain one of the following values:
    170          *
    171          *                        OS_ERR_NONE                if the requested task is resumed
    172          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    173          *                                                   control block type.
    174          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    175          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    176          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    177          *
    178          * Returns    : None
    179          *********************************************************************************************************
    180          */
    181          
    182          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    183          void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    184          {
   \                     OSEventNameSet:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0646               MOV      R6,R0
   \   00000004   0C46               MOV      R4,R1
   \   00000006   1500               MOVS     R5,R2
    185              INT8U      len;
    186          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    187              OS_CPU_SR  cpu_sr = 0;
    188          #endif
    189          
    190          
    191          
    192          #if OS_ARG_CHK_EN > 0
    193              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
   \   00000008   30D0               BEQ.N    ??OSEventNameSet_0
    194                  return;
    195              }
    196              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
   \   0000000A   002E               CMP      R6,#+0
   \   0000000C   02D1               BNE.N    ??OSEventNameSet_1
    197                  *perr = OS_ERR_PEVENT_NULL;
   \   0000000E   0420               MOVS     R0,#+4
   \   00000010   2870               STRB     R0,[R5, #+0]
    198                  return;
   \   00000012   F1BD               POP      {R0,R4-R7,PC}
    199              }
    200              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
   \                     ??OSEventNameSet_1:
   \   00000014   002C               CMP      R4,#+0
   \   00000016   02D1               BNE.N    ??OSEventNameSet_2
    201                  *perr = OS_ERR_PNAME_NULL;
   \   00000018   0C20               MOVS     R0,#+12
   \   0000001A   2870               STRB     R0,[R5, #+0]
    202                  return;
   \   0000001C   F1BD               POP      {R0,R4-R7,PC}
    203              }
    204          #endif
    205              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \                     ??OSEventNameSet_2:
   \   0000001E   ........           LDR.W    R0,??DataTable28  ;; OSCPUUsage
   \   00000022   8078               LDRB     R0,[R0, #+2]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   02D0               BEQ.N    ??OSEventNameSet_3
    206                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000028   1220               MOVS     R0,#+18
   \   0000002A   2870               STRB     R0,[R5, #+0]
    207                  return;
   \   0000002C   F1BD               POP      {R0,R4-R7,PC}
    208              }
    209              switch (pevent->OSEventType) {
   \                     ??OSEventNameSet_3:
   \   0000002E   3078               LDRB     R0,[R6, #+0]
   \   00000030   401E               SUBS     R0,R0,#+1
   \   00000032   0328               CMP      R0,#+3
   \   00000034   0DD8               BHI.N    ??OSEventNameSet_4
    210                  case OS_EVENT_TYPE_SEM:
    211                  case OS_EVENT_TYPE_MUTEX:
    212                  case OS_EVENT_TYPE_MBOX:
    213                  case OS_EVENT_TYPE_Q:
    214                       break;
    215          
    216                  default:
    217                       *perr = OS_ERR_EVENT_TYPE;
    218                       return;
    219              }
    220              OS_ENTER_CRITICAL();
   \   00000036   ........           BL       OS_CPU_SR_Save
   \   0000003A   0746               MOV      R7,R0
    221              len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
   \   0000003C   2046               MOV      R0,R4
   \   0000003E   ........           BL       OS_StrLen
    222              if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
   \   00000042   1028               CMP      R0,#+16
   \   00000044   08D3               BCC.N    ??OSEventNameSet_5
    223                  OS_EXIT_CRITICAL();
   \   00000046   3846               MOV      R0,R7
   \   00000048   ........           BL       OS_CPU_SR_Restore
    224                  *perr = OS_ERR_EVENT_NAME_TOO_LONG;
   \   0000004C   0B20               MOVS     R0,#+11
   \   0000004E   2870               STRB     R0,[R5, #+0]
    225                  return;
   \   00000050   F1BD               POP      {R0,R4-R7,PC}
    226              }
   \                     ??OSEventNameSet_4:
   \   00000052   0120               MOVS     R0,#+1
   \   00000054   2870               STRB     R0,[R5, #+0]
   \   00000056   F1BD               POP      {R0,R4-R7,PC}
    227              (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
   \                     ??OSEventNameSet_5:
   \   00000058   2146               MOV      R1,R4
   \   0000005A   06F10F00           ADD      R0,R6,#+15
   \   0000005E   ........           BL       OS_StrCopy
    228              OS_EXIT_CRITICAL();
   \   00000062   3846               MOV      R0,R7
   \   00000064   ........           BL       OS_CPU_SR_Restore
    229              *perr = OS_ERR_NONE;
   \   00000068   0020               MOVS     R0,#+0
   \   0000006A   2870               STRB     R0,[R5, #+0]
    230          }
   \                     ??OSEventNameSet_0:
   \   0000006C   F1BD               POP      {R0,R4-R7,PC}    ;; return
    231          #endif
    232          
    233          /*$PAGE*/
    234          /*
    235          *********************************************************************************************************
    236          *                                      PEND ON MULTIPLE EVENTS
    237          *
    238          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    239          *              pend call, then all available events are returned as ready.  If the task must pend on the
    240          *              multiple events, then only the first posted or aborted event is returned as ready.
    241          *
    242          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    243          *
    244          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    245          *                            or ready.  The size of the array MUST be greater than or equal to the size
    246          *                            of the 'pevents_pend' array, including terminating NULL.
    247          *
    248          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    249          *                            events.  The size of the array MUST be greater than or equal to the size of
    250          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    251          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    252          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    253          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    254          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    255          *
    256          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    257          *                            wait for the resources up to the amount of time specified by this argument.
    258          *                            If you specify 0, however, your task will wait forever for the specified
    259          *                            events or, until the resources becomes available (or the events occur).
    260          *
    261          *              perr          is a pointer to where an error message will be deposited.  Possible error
    262          *                            messages are:
    263          *
    264          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    265          *                                                or, the events you are waiting for occurred; check the
    266          *                                                'pevents_rdy' array for which events are available.
    267          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    268          *                                                'pevents_rdy' array for which events were aborted.
    269          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    270          *                                                'timeout'.
    271          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a 
    272          *                                                NULL pointer.
    273          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores, 
    274          *                                                mailboxes, and/or queues.
    275          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    276          *                                                would lead to a suspension.
    277          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    278          *
    279          * Returns    : >  0          the number of events returned as ready or aborted.
    280          *              == 0          if no events are returned as ready because of timeout or upon error.
    281          *
    282          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs : 
    283          *
    284          *                        semaphores, mailboxes, queues
    285          *
    286          *                 b. Return ALL available events and messages, if any
    287          *
    288          *                 c. Add    current task priority as pending to   each events's wait list
    289          *                      Performed in OS_EventTaskWaitMulti()
    290          *
    291          *                 d. Wait on any of multiple events
    292          *
    293          *                 e. Remove current task priority as pending from each events's wait list
    294          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    295          *
    296          *                 f. Return any event posted or aborted, if any
    297          *                      else
    298          *                    Return timeout
    299          *
    300          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in 
    301          *                 case of any error(s).
    302          *********************************************************************************************************
    303          */
    304          /*$PAGE*/
    305          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
    306          INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
    307          {
   \                     OSEventPendMulti:
   \   00000000   2DE9F84F           PUSH     {R3-R11,LR}
   \   00000004   8346               MOV      R11,R0
   \   00000006   0D46               MOV      R5,R1
   \   00000008   1446               MOV      R4,R2
   \   0000000A   0A9E               LDR      R6,[SP, #+40]
    308              OS_EVENT  **pevents;
    309              OS_EVENT   *pevent;
    310          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    311              OS_Q       *pq;
    312          #endif
    313              BOOLEAN     events_rdy;
    314              INT16U      events_rdy_nbr;
    315              INT8U       events_stat;
    316          #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    317              OS_CPU_SR   cpu_sr = 0;
    318          #endif
    319          
    320          
    321          
    322          #if (OS_ARG_CHK_EN > 0)
    323              if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
   \   0000000C   002E               CMP      R6,#+0
   \   0000000E   02D1               BNE.N    ??OSEventPendMulti_0
    324                  return (0);
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   BDE8F28F           POP      {R1,R4-R11,PC}
    325              }
    326              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
   \                     ??OSEventPendMulti_0:
   \   00000016   BBF1000F           CMP      R11,#+0
   \   0000001A   04D1               BNE.N    ??OSEventPendMulti_1
    327                 *perr =  OS_ERR_PEVENT_NULL;
   \                     ??OSEventPendMulti_2:
   \   0000001C   0420               MOVS     R0,#+4
   \   0000001E   3070               STRB     R0,[R6, #+0]
    328                  return (0);
   \   00000020   0020               MOVS     R0,#+0
   \   00000022   BDE8F28F           POP      {R1,R4-R11,PC}
    329              }
    330              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
   \                     ??OSEventPendMulti_1:
   \   00000026   002D               CMP      R5,#+0
   \   00000028   F8D0               BEQ.N    ??OSEventPendMulti_2
    331                 *perr =  OS_ERR_PEVENT_NULL;
    332                  return (0);
    333              }
    334              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
   \   0000002A   002C               CMP      R4,#+0
   \   0000002C   F6D0               BEQ.N    ??OSEventPendMulti_2
    335                 *perr =  OS_ERR_PEVENT_NULL;
    336                  return (0);
    337              }
    338          #endif
    339          
    340             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
   \   0000002E   0020               MOVS     R0,#+0
   \   00000030   2860               STR      R0,[R5, #+0]
    341          
    342              pevents     =  pevents_pend;
   \   00000032   5846               MOV      R0,R11
    343              pevent      = *pevents;
   \   00000034   D0F80090           LDR      R9,[R0, #+0]
   \   00000038   01E0               B.N      ??OSEventPendMulti_3
    344              while  (pevent != (OS_EVENT *)0) {
    345                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
    346          #if (OS_SEM_EN  > 0)
    347                      case OS_EVENT_TYPE_SEM:
    348                           break;
    349          #endif
    350          #if (OS_MBOX_EN > 0)
    351                      case OS_EVENT_TYPE_MBOX:
    352                           break;
    353          #endif
    354          #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
    355                      case OS_EVENT_TYPE_Q:
    356                           break;
    357          #endif
    358          
    359                      case OS_EVENT_TYPE_MUTEX:                                            
    360                      case OS_EVENT_TYPE_FLAG:
    361                      default:           
    362                          *perr = OS_ERR_EVENT_TYPE;
    363                           return (0);
    364                  }
    365                  pevents++;
    366                  pevent = *pevents;
   \                     ??OSEventPendMulti_4:
   \   0000003A   50F8049F           LDR      R9,[R0, #+4]!
   \                     ??OSEventPendMulti_3:
   \   0000003E   B9F1000F           CMP      R9,#+0
   \   00000042   09D0               BEQ.N    ??OSEventPendMulti_5
   \   00000044   99F80010           LDRB     R1,[R9, #+0]
   \   00000048   491E               SUBS     R1,R1,#+1
   \   0000004A   0229               CMP      R1,#+2
   \   0000004C   F5D9               BLS.N    ??OSEventPendMulti_4
   \   0000004E   0120               MOVS     R0,#+1
   \   00000050   3070               STRB     R0,[R6, #+0]
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   BDE8F28F           POP      {R1,R4-R11,PC}
    367              }
    368          
    369              if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
   \                     ??OSEventPendMulti_5:
   \   00000058   ........           LDR.W    R10,??DataTable28  ;; OSCPUUsage
   \   0000005C   9AF80200           LDRB     R0,[R10, #+2]
   \   00000060   0028               CMP      R0,#+0
   \   00000062   04D0               BEQ.N    ??OSEventPendMulti_6
    370                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
   \   00000064   0220               MOVS     R0,#+2
   \   00000066   3070               STRB     R0,[R6, #+0]
    371                  return (0);
   \   00000068   0020               MOVS     R0,#+0
   \   0000006A   BDE8F28F           POP      {R1,R4-R11,PC}
    372              }
    373              if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
   \                     ??OSEventPendMulti_6:
   \   0000006E   9AF80300           LDRB     R0,[R10, #+3]
   \   00000072   0028               CMP      R0,#+0
   \   00000074   04D0               BEQ.N    ??OSEventPendMulti_7
    374                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
   \   00000076   0D20               MOVS     R0,#+13
   \   00000078   3070               STRB     R0,[R6, #+0]
    375                  return (0);
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   BDE8F28F           POP      {R1,R4-R11,PC}
    376              }
    377          
    378          /*$PAGE*/
    379              OS_ENTER_CRITICAL();
   \                     ??OSEventPendMulti_7:
   \   00000080   ........           BL       OS_CPU_SR_Save
   \   00000084   0746               MOV      R7,R0
    380              events_rdy     =  OS_FALSE;
   \   00000086   0022               MOVS     R2,#+0
    381              events_rdy_nbr =  0;
   \   00000088   9046               MOV      R8,R2
    382              events_stat    =  OS_STAT_RDY;
   \   0000008A   1146               MOV      R1,R2
    383              pevents        =  pevents_pend;
   \   0000008C   5846               MOV      R0,R11
    384              pevent         = *pevents;
   \   0000008E   D0F80090           LDR      R9,[R0, #+0]
   \   00000092   0FE0               B.N      ??OSEventPendMulti_8
    385              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
    386                  switch (pevent->OSEventType) {
    387          #if (OS_SEM_EN > 0)
    388                      case OS_EVENT_TYPE_SEM:
    389                           if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
    390                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
   \                     ??OSEventPendMulti_9:
   \   00000094   1A46               MOV      R2,R3
   \   00000096   521E               SUBS     R2,R2,#+1
   \   00000098   A9F80820           STRH     R2,[R9, #+8]
    391                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
   \   0000009C   45F8049B           STR      R9,[R5], #+4
    392                                events_rdy   =  OS_TRUE;
   \   000000A0   0122               MOVS     R2,#+1
    393                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
   \   000000A2   0023               MOVS     R3,#+0
   \   000000A4   44F8043B           STR      R3,[R4], #+4
    394                                events_rdy_nbr++;
   \   000000A8   08F10108           ADD      R8,R8,#+1
   \   000000AC   1FFA88F8           UXTH     R8,R8
    395          
    396                           } else {
    397                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
    398                           }
    399                           break;
    400          #endif
    401          
    402          #if (OS_MBOX_EN > 0)
    403                      case OS_EVENT_TYPE_MBOX:
    404                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
    405                                                                  /* ... return available message,           ... */
    406                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
    407                               pevent->OSEventPtr  = (void *)0;
    408                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
    409                                events_rdy         =  OS_TRUE;
    410                                events_rdy_nbr++;
    411          
    412                           } else {
    413                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
    414                           }
    415                           break;
    416          #endif
    417          
    418          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    419                      case OS_EVENT_TYPE_Q:
    420                           pq = (OS_Q *)pevent->OSEventPtr;
    421                           if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
    422                                                                  /* ... return available message,           ... */
    423                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
    424                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
    425                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
    426                               }
    427                               pq->OSQEntries--;                  /* Update number of queue entries              */
    428                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
    429                                events_rdy   = OS_TRUE;
    430                                events_rdy_nbr++;
    431          
    432                           } else {
    433                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
    434                           }
    435                           break;
    436          #endif
    437          
    438                      case OS_EVENT_TYPE_MUTEX:                                            
    439                      case OS_EVENT_TYPE_FLAG:
    440                      default:           
    441                           OS_EXIT_CRITICAL();
    442                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
    443                          *perr        =  OS_ERR_EVENT_TYPE;
    444                           return (events_rdy_nbr);
    445                  }
    446                  pevents++;
    447                  pevent = *pevents;
   \                     ??OSEventPendMulti_10:
   \   000000B0   50F8049F           LDR      R9,[R0, #+4]!
   \                     ??OSEventPendMulti_8:
   \   000000B4   B9F1000F           CMP      R9,#+0
   \   000000B8   53D0               BEQ.N    ??OSEventPendMulti_11
   \   000000BA   99F80030           LDRB     R3,[R9, #+0]
   \   000000BE   012B               CMP      R3,#+1
   \   000000C0   0AD0               BEQ.N    ??OSEventPendMulti_12
   \   000000C2   022B               CMP      R3,#+2
   \   000000C4   1ED0               BEQ.N    ??OSEventPendMulti_13
   \   000000C6   032B               CMP      R3,#+3
   \   000000C8   41D1               BNE.N    ??OSEventPendMulti_14
   \   000000CA   B9F80830           LDRH     R3,[R9, #+8]
   \   000000CE   002B               CMP      R3,#+0
   \   000000D0   E0D1               BNE.N    ??OSEventPendMulti_9
   \   000000D2   41F00101           ORR      R1,R1,#0x1
   \   000000D6   EBE7               B.N      ??OSEventPendMulti_10
   \                     ??OSEventPendMulti_12:
   \   000000D8   D9F80430           LDR      R3,[R9, #+4]
   \   000000DC   002B               CMP      R3,#+0
   \   000000DE   0DD0               BEQ.N    ??OSEventPendMulti_15
   \   000000E0   1A46               MOV      R2,R3
   \   000000E2   44F8042B           STR      R2,[R4], #+4
   \   000000E6   0022               MOVS     R2,#+0
   \   000000E8   C9F80420           STR      R2,[R9, #+4]
   \   000000EC   45F8049B           STR      R9,[R5], #+4
   \   000000F0   0122               MOVS     R2,#+1
   \   000000F2   08F10108           ADD      R8,R8,#+1
   \   000000F6   1FFA88F8           UXTH     R8,R8
   \   000000FA   D9E7               B.N      ??OSEventPendMulti_10
   \                     ??OSEventPendMulti_15:
   \   000000FC   41F00201           ORR      R1,R1,#0x2
   \   00000100   C9B2               UXTB     R1,R1
   \   00000102   D5E7               B.N      ??OSEventPendMulti_10
   \                     ??OSEventPendMulti_13:
   \   00000104   D9F80430           LDR      R3,[R9, #+4]
   \   00000108   B3F816C0           LDRH     R12,[R3, #+22]
   \   0000010C   BCF1000F           CMP      R12,#+0
   \   00000110   19D0               BEQ.N    ??OSEventPendMulti_16
   \   00000112   1A69               LDR      R2,[R3, #+16]
   \   00000114   02F1040C           ADD      R12,R2,#+4
   \   00000118   C3F810C0           STR      R12,[R3, #+16]
   \   0000011C   1268               LDR      R2,[R2, #+0]
   \   0000011E   44F8042B           STR      R2,[R4], #+4
   \   00000122   1A69               LDR      R2,[R3, #+16]
   \   00000124   D3F808C0           LDR      R12,[R3, #+8]
   \   00000128   6245               CMP      R2,R12
   \   0000012A   01D1               BNE.N    ??OSEventPendMulti_17
   \   0000012C   5A68               LDR      R2,[R3, #+4]
   \   0000012E   1A61               STR      R2,[R3, #+16]
   \                     ??OSEventPendMulti_17:
   \   00000130   DA8A               LDRH     R2,[R3, #+22]
   \   00000132   521E               SUBS     R2,R2,#+1
   \   00000134   DA82               STRH     R2,[R3, #+22]
   \   00000136   45F8049B           STR      R9,[R5], #+4
   \   0000013A   0122               MOVS     R2,#+1
   \   0000013C   08F10108           ADD      R8,R8,#+1
   \   00000140   1FFA88F8           UXTH     R8,R8
   \   00000144   B4E7               B.N      ??OSEventPendMulti_10
   \                     ??OSEventPendMulti_16:
   \   00000146   41F00401           ORR      R1,R1,#0x4
   \   0000014A   C9B2               UXTB     R1,R1
   \   0000014C   B0E7               B.N      ??OSEventPendMulti_10
   \                     ??OSEventPendMulti_14:
   \   0000014E   3846               MOV      R0,R7
   \   00000150   ........           BL       OS_CPU_SR_Restore
   \   00000154   0020               MOVS     R0,#+0
   \   00000156   2860               STR      R0,[R5, #+0]
   \   00000158   0120               MOVS     R0,#+1
   \   0000015A   3070               STRB     R0,[R6, #+0]
   \   0000015C   4046               MOV      R0,R8
   \   0000015E   BDE8F28F           POP      {R1,R4-R11,PC}
    448              }
    449          
    450              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
   \                     ??OSEventPendMulti_11:
   \   00000162   012A               CMP      R2,#+1
   \   00000164   09D1               BNE.N    ??OSEventPendMulti_18
    451                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
   \   00000166   0020               MOVS     R0,#+0
   \   00000168   2860               STR      R0,[R5, #+0]
    452                  OS_EXIT_CRITICAL();
   \   0000016A   3846               MOV      R0,R7
   \   0000016C   ........           BL       OS_CPU_SR_Restore
    453                 *perr        =  OS_ERR_NONE;
   \   00000170   0020               MOVS     R0,#+0
   \   00000172   3070               STRB     R0,[R6, #+0]
    454                  return (events_rdy_nbr);
   \   00000174   4046               MOV      R0,R8
   \   00000176   BDE8F28F           POP      {R1,R4-R11,PC}
    455              }
    456          /*$PAGE*/
    457                                                                  /* Otherwise, must wait until any event occurs */
    458              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    459                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
   \                     ??OSEventPendMulti_18:
   \   0000017A   DAF82000           LDR      R0,[R10, #+32]
   \   0000017E   90F83020           LDRB     R2,[R0, #+48]
   \   00000182   41F08001           ORR      R1,R1,#0x80
   \   00000186   1143               ORRS     R1,R1,R2
   \   00000188   80F83010           STRB     R1,[R0, #+48]
    460              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000018C   DAF82000           LDR      R0,[R10, #+32]
   \   00000190   0021               MOVS     R1,#+0
   \   00000192   80F83110           STRB     R1,[R0, #+49]
    461              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
   \   00000196   DAF82000           LDR      R0,[R10, #+32]
   \   0000019A   BDF80010           LDRH     R1,[SP, #+0]
   \   0000019E   C185               STRH     R1,[R0, #+46]
    462              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
   \   000001A0   5846               MOV      R0,R11
   \   000001A2   ........           BL       OS_EventTaskWaitMulti
    463          
    464              OS_EXIT_CRITICAL();
   \   000001A6   3846               MOV      R0,R7
   \   000001A8   ........           BL       OS_CPU_SR_Restore
    465              OS_Sched();                                         /* Find next highest priority task ready       */
   \   000001AC   ........           BL       OS_Sched
    466              OS_ENTER_CRITICAL();
   \   000001B0   ........           BL       OS_CPU_SR_Save
   \   000001B4   0746               MOV      R7,R0
    467          
    468              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
   \   000001B6   DAF82000           LDR      R0,[R10, #+32]
   \   000001BA   00F11C01           ADD      R1,R0,#+28
   \   000001BE   4A7D               LDRB     R2,[R1, #+21]
   \   000001C0   002A               CMP      R2,#+0
   \   000001C2   01D0               BEQ.N    ??OSEventPendMulti_19
   \   000001C4   022A               CMP      R2,#+2
   \   000001C6   16D1               BNE.N    ??OSEventPendMulti_20
    469                  case OS_STAT_PEND_OK:
    470                  case OS_STAT_PEND_ABORT:
    471                       pevent = OSTCBCur->OSTCBEventPtr;
   \                     ??OSEventPendMulti_19:
   \   000001C8   D0F81C90           LDR      R9,[R0, #+28]
    472                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
   \   000001CC   B9F1000F           CMP      R9,#+0
   \   000001D0   09D0               BEQ.N    ??OSEventPendMulti_21
    473                          *pevents_rdy++ =  pevent;               /* ... return available event ...              */
   \   000001D2   C5F80090           STR      R9,[R5, #+0]
    474                          *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
   \   000001D6   0020               MOVS     R0,#+0
   \   000001D8   45F8040F           STR      R0,[R5, #+4]!
    475                            events_rdy_nbr++;
   \   000001DC   08F10108           ADD      R8,R8,#+1
   \   000001E0   1FFA88F8           UXTH     R8,R8
   \   000001E4   0AE0               B.N      ??OSEventPendMulti_22
    476          
    477                       } else {                                   /* Else NO event available, handle as timeout  */
    478                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
   \                     ??OSEventPendMulti_21:
   \   000001E6   0120               MOVS     R0,#+1
   \   000001E8   4875               STRB     R0,[R1, #+21]
    479                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \   000001EA   5946               MOV      R1,R11
   \   000001EC   DAF82000           LDR      R0,[R10, #+32]
   \   000001F0   ........           BL       OS_EventTaskRemoveMulti
   \   000001F4   02E0               B.N      ??OSEventPendMulti_22
    480                       }
    481          			 break;
    482          
    483                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    484                  default:                                        /* ... remove task from events' wait lists     */
    485                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \                     ??OSEventPendMulti_20:
   \   000001F6   5946               MOV      R1,R11
   \   000001F8   ........           BL       OS_EventTaskRemoveMulti
    486                       break;
    487              }
    488          
    489              switch (OSTCBCur->OSTCBStatPend) {
   \                     ??OSEventPendMulti_22:
   \   000001FC   DAF82000           LDR      R0,[R10, #+32]
   \   00000200   00F12401           ADD      R1,R0,#+36
   \   00000204   497B               LDRB     R1,[R1, #+13]
   \   00000206   0029               CMP      R1,#+0
   \   00000208   02D0               BEQ.N    ??OSEventPendMulti_23
   \   0000020A   0229               CMP      R1,#+2
   \   0000020C   0FD0               BEQ.N    ??OSEventPendMulti_24
   \   0000020E   13E0               B.N      ??OSEventPendMulti_25
    490                  case OS_STAT_PEND_OK:
    491                       switch (pevent->OSEventType) {             /* Return event's message                      */
   \                     ??OSEventPendMulti_23:
   \   00000210   99F80010           LDRB     R1,[R9, #+0]
   \   00000214   491E               SUBS     R1,R1,#+1
   \   00000216   0129               CMP      R1,#+1
   \   00000218   04D9               BLS.N    ??OSEventPendMulti_26
   \   0000021A   891E               SUBS     R1,R1,#+2
   \   0000021C   97D1               BNE.N    ??OSEventPendMulti_14
    492          #if (OS_SEM_EN > 0)
    493                           case OS_EVENT_TYPE_SEM:
    494                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
   \   0000021E   0020               MOVS     R0,#+0
   \   00000220   2060               STR      R0,[R4, #+0]
   \   00000222   01E0               B.N      ??OSEventPendMulti_27
    495                                break;
    496          #endif
    497          
    498          #if ((OS_MBOX_EN > 0) ||                 \
    499              ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
    500                           case OS_EVENT_TYPE_MBOX:
    501                           case OS_EVENT_TYPE_Q:
    502                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
   \                     ??OSEventPendMulti_26:
   \   00000224   406A               LDR      R0,[R0, #+36]
   \   00000226   2060               STR      R0,[R4, #+0]
    503                                break;
    504          #endif
    505          
    506                           case OS_EVENT_TYPE_MUTEX:                                       
    507                           case OS_EVENT_TYPE_FLAG:
    508                           default:           
    509                                OS_EXIT_CRITICAL();
    510                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
    511                               *perr        =  OS_ERR_EVENT_TYPE;
    512                                return (events_rdy_nbr);
    513                       }
    514                      *perr = OS_ERR_NONE;
   \                     ??OSEventPendMulti_27:
   \   00000228   0020               MOVS     R0,#+0
   \   0000022A   3070               STRB     R0,[R6, #+0]
   \   0000022C   08E0               B.N      ??OSEventPendMulti_28
    515                       break;
    516          
    517                  case OS_STAT_PEND_ABORT:
    518                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
   \                     ??OSEventPendMulti_24:
   \   0000022E   0020               MOVS     R0,#+0
   \   00000230   2060               STR      R0,[R4, #+0]
    519                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
   \   00000232   0E20               MOVS     R0,#+14
   \   00000234   3070               STRB     R0,[R6, #+0]
   \   00000236   03E0               B.N      ??OSEventPendMulti_28
    520                       break;
    521                                                                  
    522                  case OS_STAT_PEND_TO:                                                
    523                  default:        
    524                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
   \                     ??OSEventPendMulti_25:
   \   00000238   0020               MOVS     R0,#+0
   \   0000023A   2060               STR      R0,[R4, #+0]
    525                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
   \   0000023C   0A20               MOVS     R0,#+10
   \   0000023E   3070               STRB     R0,[R6, #+0]
    526                       break;
    527              }
    528          
    529              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
   \                     ??OSEventPendMulti_28:
   \   00000240   DAF82000           LDR      R0,[R10, #+32]
   \   00000244   0021               MOVS     R1,#+0
   \   00000246   80F83010           STRB     R1,[R0, #+48]
    530              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
   \   0000024A   DAF82000           LDR      R0,[R10, #+32]
   \   0000024E   80F83110           STRB     R1,[R0, #+49]
    531              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
   \   00000252   DAF82000           LDR      R0,[R10, #+32]
   \   00000256   C161               STR      R1,[R0, #+28]
    532              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   00000258   DAF82000           LDR      R0,[R10, #+32]
   \   0000025C   0162               STR      R1,[R0, #+32]
    533              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
   \   0000025E   DAF82000           LDR      R0,[R10, #+32]
   \   00000262   4162               STR      R1,[R0, #+36]
    534              OS_EXIT_CRITICAL();
   \   00000264   3846               MOV      R0,R7
   \   00000266   ........           BL       OS_CPU_SR_Restore
    535          
    536              return (events_rdy_nbr);
   \   0000026A   4046               MOV      R0,R8
   \   0000026C   BDE8F28F           POP      {R1,R4-R11,PC}   ;; return
    537          }
    538          #endif
    539          
    540          /*$PAGE*/
    541          /*
    542          *********************************************************************************************************
    543          *                                             INITIALIZATION
    544          *
    545          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    546          *              creating any uC/OS-II object and, prior to calling OSStart().
    547          *
    548          * Arguments  : none
    549          *
    550          * Returns    : none
    551          *********************************************************************************************************
    552          */
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void  OSInit (void)
    555          {
   \                     OSInit:
   \   00000000   80B5               PUSH     {R7,LR}
    556              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   00000002   ........           BL       OSInitHookBegin
    557          
    558              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   00000006   ........           BL       OS_InitMisc
    559          
    560              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   0000000A   ........           BL       OS_InitRdyList
    561          
    562              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   0000000E   ........           BL       OS_InitTCBList
    563          
    564              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   00000012   ........           BL       OS_InitEventList
    565          
    566          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    567              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   00000016   ........           BL       OS_FlagInit
    568          #endif
    569          
    570          #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    571              OS_MemInit();                                                /* Initialize the memory manager            */
   \   0000001A   ........           BL       OS_MemInit
    572          #endif
    573          
    574          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    575              OS_QInit();                                                  /* Initialize the message queue structures  */
   \   0000001E   ........           BL       OS_QInit
    576          #endif
    577          
    578              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   00000022   ........           BL       OS_InitTaskIdle
    579          #if OS_TASK_STAT_EN > 0
    580              OS_InitTaskStat();                                           /* Create the Statistic Task                */
   \   00000026   ........           BL       OS_InitTaskStat
    581          #endif
    582          
    583          #if OS_TMR_EN > 0
    584              OSTmr_Init();                                                /* Initialize the Timer Manager             */
   \   0000002A   ........           BL       OSTmr_Init
    585          #endif
    586          
    587              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   0000002E   ........           BL       OSInitHookEnd
    588          
    589          #if OS_DEBUG_EN > 0
    590              OSDebugInit();
   \   00000032   BDE80140           POP      {R0,LR}
   \   00000036   ........           B.W      OSDebugInit
    591          #endif
    592          }
    593          /*$PAGE*/
    594          /*
    595          *********************************************************************************************************
    596          *                                              ENTER ISR
    597          *
    598          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    599          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    600          *              only perform rescheduling at the last nested ISR.
    601          *
    602          * Arguments  : none
    603          *
    604          * Returns    : none
    605          *
    606          * Notes      : 1) This function should be called ith interrupts already disabled
    607          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    608          *                 OSIntNesting has been declared 'global'.
    609          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    610          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    611          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    612          *                 end of the ISR.
    613          *              5) You are allowed to nest interrupts up to 255 levels deep.
    614          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    615          *                 OSIntEnter() is always called with interrupts disabled.
    616          *********************************************************************************************************
    617          */
    618          

   \                                 In section .text, align 2, keep-with-next
    619          void  OSIntEnter (void)
    620          {
    621              if (OSRunning == OS_TRUE) {
   \                     OSIntEnter:
   \   00000000   ........           LDR.W    R0,??DataTable28  ;; OSCPUUsage
   \   00000004   C179               LDRB     R1,[R0, #+7]
   \   00000006   0129               CMP      R1,#+1
   \   00000008   04D1               BNE.N    ??OSIntEnter_0
    622                  if (OSIntNesting < 255u) {
   \   0000000A   8178               LDRB     R1,[R0, #+2]
   \   0000000C   FF29               CMP      R1,#+255
   \   0000000E   01D0               BEQ.N    ??OSIntEnter_0
    623                      OSIntNesting++;                      /* Increment ISR nesting level                        */
   \   00000010   491C               ADDS     R1,R1,#+1
   \   00000012   8170               STRB     R1,[R0, #+2]
    624                  }
    625              }
    626          }
   \                     ??OSIntEnter_0:
   \   00000014   7047               BX       LR               ;; return
    627          /*$PAGE*/
    628          /*
    629          *********************************************************************************************************
    630          *                                               EXIT ISR
    631          *
    632          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    633          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    634          *              a new, high-priority task, is ready to run.
    635          *
    636          * Arguments  : none
    637          *
    638          * Returns    : none
    639          *
    640          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    641          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    642          *                 end of the ISR.
    643          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    644          *********************************************************************************************************
    645          */
    646          

   \                                 In section .text, align 2, keep-with-next
    647          void  OSIntExit (void)
    648          {
   \                     OSIntExit:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    649          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    650              OS_CPU_SR  cpu_sr = 0;
    651          #endif
    652          
    653          
    654          
    655              if (OSRunning == OS_TRUE) {
   \   00000002   ........           LDR.W    R4,??DataTable28  ;; OSCPUUsage
   \   00000006   E079               LDRB     R0,[R4, #+7]
   \   00000008   0128               CMP      R0,#+1
   \   0000000A   21D1               BNE.N    ??OSIntExit_0
    656                  OS_ENTER_CRITICAL();
   \   0000000C   ........           BL       OS_CPU_SR_Save
   \   00000010   0546               MOV      R5,R0
    657                  if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
   \   00000012   A078               LDRB     R0,[R4, #+2]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   01D0               BEQ.N    ??OSIntExit_1
    658                      OSIntNesting--;
   \   00000018   401E               SUBS     R0,R0,#+1
   \   0000001A   A070               STRB     R0,[R4, #+2]
    659                  }
    660                  if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    661                      if (OSLockNesting == 0) {                      /* ... and not locked.                      */
   \                     ??OSIntExit_1:
   \   0000001C   A078               LDRB     R0,[R4, #+2]
   \   0000001E   E178               LDRB     R1,[R4, #+3]
   \   00000020   0843               ORRS     R0,R1,R0
   \   00000022   12D1               BNE.N    ??OSIntExit_2
    662                          OS_SchedNew();
   \   00000024   ........           BL       OS_SchedNew
    663                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \   00000028   6079               LDRB     R0,[R4, #+5]
   \   0000002A   2179               LDRB     R1,[R4, #+4]
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   0CD0               BEQ.N    ??OSIntExit_2
    664                              OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
   \   00000030   ........           LDR.W    R1,??DataTable29  ;; OSTCBPrioTbl
   \   00000034   51F82000           LDR      R0,[R1, R0, LSL #+2]
   \   00000038   A062               STR      R0,[R4, #+40]
    665          #if OS_TASK_PROFILE_EN > 0
    666                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   0000003A   816B               LDR      R1,[R0, #+56]
   \   0000003C   491C               ADDS     R1,R1,#+1
   \   0000003E   8163               STR      R1,[R0, #+56]
    667          #endif
    668                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \   00000040   2069               LDR      R0,[R4, #+16]
   \   00000042   401C               ADDS     R0,R0,#+1
   \   00000044   2061               STR      R0,[R4, #+16]
    669                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \   00000046   ........           BL       OSIntCtxSw
    670                          }
    671                      }
    672                  }
    673                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2:
   \   0000004A   2846               MOV      R0,R5
   \   0000004C   ........           BL       OS_CPU_SR_Restore
    674              }
    675          }
   \                     ??OSIntExit_0:
   \   00000050   31BD               POP      {R0,R4,R5,PC}    ;; return
    676          /*$PAGE*/
    677          /*
    678          *********************************************************************************************************
    679          *                                          PREVENT SCHEDULING
    680          *
    681          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    682          *              to prevent context switches until you are ready to permit context switching.
    683          *
    684          * Arguments  : none
    685          *
    686          * Returns    : none
    687          *
    688          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    689          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    690          *********************************************************************************************************
    691          */
    692          
    693          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    694          void  OSSchedLock (void)
    695          {
   \                     OSSchedLock:
   \   00000000   10B5               PUSH     {R4,LR}
    696          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    697              OS_CPU_SR  cpu_sr = 0;
    698          #endif
    699          
    700          
    701          
    702              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   00000002   ........           LDR.W    R4,??DataTable28  ;; OSCPUUsage
   \   00000006   E079               LDRB     R0,[R4, #+7]
   \   00000008   0128               CMP      R0,#+1
   \   0000000A   0BD1               BNE.N    ??OSSchedLock_0
    703                  OS_ENTER_CRITICAL();
   \   0000000C   ........           BL       OS_CPU_SR_Save
    704                  if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
   \   00000010   A178               LDRB     R1,[R4, #+2]
   \   00000012   0029               CMP      R1,#+0
   \   00000014   04D1               BNE.N    ??OSSchedLock_1
    705                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   00000016   E178               LDRB     R1,[R4, #+3]
   \   00000018   FF29               CMP      R1,#+255
   \   0000001A   01D0               BEQ.N    ??OSSchedLock_1
    706                          OSLockNesting++;                 /* Increment lock nesting level                       */
   \   0000001C   491C               ADDS     R1,R1,#+1
   \   0000001E   E170               STRB     R1,[R4, #+3]
    707                      }
    708                  }
    709                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1:
   \   00000020   ........           BL       OS_CPU_SR_Restore
    710              }
    711          }
   \                     ??OSSchedLock_0:
   \   00000024   10BD               POP      {R4,PC}          ;; return
    712          #endif
    713          
    714          /*$PAGE*/
    715          /*
    716          *********************************************************************************************************
    717          *                                          ENABLE SCHEDULING
    718          *
    719          * Description: This function is used to re-allow rescheduling.
    720          *
    721          * Arguments  : none
    722          *
    723          * Returns    : none
    724          *
    725          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    726          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    727          *********************************************************************************************************
    728          */
    729          
    730          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    731          void  OSSchedUnlock (void)
    732          {
   \                     OSSchedUnlock:
   \   00000000   10B5               PUSH     {R4,LR}
    733          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    734              OS_CPU_SR  cpu_sr = 0;
    735          #endif
    736          
    737          
    738          
    739              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   00000002   ........           LDR.W    R4,??DataTable28  ;; OSCPUUsage
   \   00000006   E079               LDRB     R0,[R4, #+7]
   \   00000008   0128               CMP      R0,#+1
   \   0000000A   1BD1               BNE.N    ??OSSchedUnlock_0
    740                  OS_ENTER_CRITICAL();
   \   0000000C   ........           BL       OS_CPU_SR_Save
    741                  if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
   \   00000010   E178               LDRB     R1,[R4, #+3]
   \   00000012   0029               CMP      R1,#+0
   \   00000014   14D0               BEQ.N    ??OSSchedUnlock_1
    742                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \   00000016   491E               SUBS     R1,R1,#+1
   \   00000018   E170               STRB     R1,[R4, #+3]
    743                      if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
   \   0000001A   C9B2               UXTB     R1,R1
   \   0000001C   0029               CMP      R1,#+0
   \   0000001E   0BD1               BNE.N    ??OSSchedUnlock_2
    744                          if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
   \   00000020   A178               LDRB     R1,[R4, #+2]
   \   00000022   0029               CMP      R1,#+0
   \   00000024   04D1               BNE.N    ??OSSchedUnlock_3
    745                              OS_EXIT_CRITICAL();
   \   00000026   ........           BL       OS_CPU_SR_Restore
    746                              OS_Sched();                            /* See if a HPT is ready                    */
   \   0000002A   BDE81040           POP      {R4,LR}
   \   0000002E   ....               B.N      OS_Sched
    747                          } else {
    748                              OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_3:
   \   00000030   BDE81040           POP      {R4,LR}
   \   00000034   ........           B.W      OS_CPU_SR_Restore
    749                          }
    750                      } else {
    751                          OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_2:
   \   00000038   BDE81040           POP      {R4,LR}
   \   0000003C   ........           B.W      OS_CPU_SR_Restore
    752                      }
    753                  } else {
    754                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1:
   \   00000040   ........           BL       OS_CPU_SR_Restore
    755                  }
    756              }
    757          }
   \                     ??OSSchedUnlock_0:
   \   00000044   10BD               POP      {R4,PC}          ;; return
    758          #endif
    759          
    760          /*$PAGE*/
    761          /*
    762          *********************************************************************************************************
    763          *                                          START MULTITASKING
    764          *
    765          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    766          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    767          *              and you MUST have created at least one task.
    768          *
    769          * Arguments  : none
    770          *
    771          * Returns    : none
    772          *
    773          * Note       : OSStartHighRdy() MUST:
    774          *                 a) Call OSTaskSwHook() then,
    775          *                 b) Set OSRunning to OS_TRUE.
    776          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    777          *                 d_ Execute the task.
    778          *********************************************************************************************************
    779          */
    780          

   \                                 In section .text, align 2, keep-with-next
    781          void  OSStart (void)
    782          {
   \                     OSStart:
   \   00000000   10B5               PUSH     {R4,LR}
    783              if (OSRunning == OS_FALSE) {
   \   00000002   ........           LDR.W    R4,??DataTable28  ;; OSCPUUsage
   \   00000006   E079               LDRB     R0,[R4, #+7]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0BD1               BNE.N    ??OSStart_0
    784                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   0000000C   ........           BL       OS_SchedNew
    785                  OSPrioCur     = OSPrioHighRdy;
   \   00000010   6079               LDRB     R0,[R4, #+5]
   \   00000012   2071               STRB     R0,[R4, #+4]
    786                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   00000014   ........           LDR.W    R1,??DataTable29  ;; OSTCBPrioTbl
   \   00000018   51F82000           LDR      R0,[R1, R0, LSL #+2]
   \   0000001C   A062               STR      R0,[R4, #+40]
    787                  OSTCBCur      = OSTCBHighRdy;
   \   0000001E   2062               STR      R0,[R4, #+32]
    788                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   00000020   ........           BL       OSStartHighRdy
    789              }
    790          }
   \                     ??OSStart_0:
   \   00000024   10BD               POP      {R4,PC}          ;; return
    791          /*$PAGE*/
    792          /*
    793          *********************************************************************************************************
    794          *                                        STATISTICS INITIALIZATION
    795          *
    796          * Description: This function is called by your application to establish CPU usage by first determining
    797          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    798          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    799          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    800          *              determined by:
    801          *
    802          *                                             OSIdleCtr
    803          *                 CPU Usage (%) = 100 * (1 - ------------)
    804          *                                            OSIdleCtrMax
    805          *
    806          * Arguments  : none
    807          *
    808          * Returns    : none
    809          *********************************************************************************************************
    810          */
    811          
    812          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    813          void  OSStatInit (void)
    814          {
   \                     OSStatInit:
   \   00000000   10B5               PUSH     {R4,LR}
    815          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    816              OS_CPU_SR  cpu_sr = 0;
    817          #endif
    818          
    819          
    820          
    821              OSTimeDly(2);                                /* Synchronize with clock tick                        */
   \   00000002   0220               MOVS     R0,#+2
   \   00000004   ........           BL       OSTimeDly
    822              OS_ENTER_CRITICAL();
   \   00000008   ........           BL       OS_CPU_SR_Save
    823              OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
   \   0000000C   ........           LDR.W    R4,??DataTable28  ;; OSCPUUsage
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   E161               STR      R1,[R4, #+28]
    824              OS_EXIT_CRITICAL();
   \   00000014   ........           BL       OS_CPU_SR_Restore
    825              OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
   \   00000018   6420               MOVS     R0,#+100
   \   0000001A   ........           BL       OSTimeDly
    826              OS_ENTER_CRITICAL();
   \   0000001E   ........           BL       OS_CPU_SR_Save
    827              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
   \   00000022   E169               LDR      R1,[R4, #+28]
   \   00000024   6161               STR      R1,[R4, #+20]
    828              OSStatRdy    = OS_TRUE;
   \   00000026   0121               MOVS     R1,#+1
   \   00000028   6170               STRB     R1,[R4, #+1]
    829              OS_EXIT_CRITICAL();
   \   0000002A   BDE81040           POP      {R4,LR}
   \   0000002E   ........           B.W      OS_CPU_SR_Restore
    830          }
    831          #endif
    832          /*$PAGE*/
    833          /*
    834          *********************************************************************************************************
    835          *                                         PROCESS SYSTEM TICK
    836          *
    837          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    838          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    839          *              called by a high priority task.
    840          *
    841          * Arguments  : none
    842          *
    843          * Returns    : none
    844          *********************************************************************************************************
    845          */
    846          

   \                                 In section .text, align 2, keep-with-next
    847          void  OSTimeTick (void)
    848          {
   \                     OSTimeTick:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    849              OS_TCB    *ptcb;
    850          #if OS_TICK_STEP_EN > 0
    851              BOOLEAN    step;
    852          #endif
    853          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    854              OS_CPU_SR  cpu_sr = 0;
    855          #endif
    856          
    857          
    858          
    859          #if OS_TIME_TICK_HOOK_EN > 0
    860              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   00000002   ........           BL       OSTimeTickHook
    861          #endif
    862          #if OS_TIME_GET_SET_EN > 0
    863              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   00000006   ........           BL       OS_CPU_SR_Save
    864              OSTime++;
   \   0000000A   ........           LDR.W    R4,??DataTable28  ;; OSCPUUsage
   \   0000000E   216B               LDR      R1,[R4, #+48]
   \   00000010   491C               ADDS     R1,R1,#+1
   \   00000012   2163               STR      R1,[R4, #+48]
    865              OS_EXIT_CRITICAL();
   \   00000014   ........           BL       OS_CPU_SR_Restore
    866          #endif
    867              if (OSRunning == OS_TRUE) {
   \   00000018   E079               LDRB     R0,[R4, #+7]
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   48D1               BNE.N    ??OSTimeTick_0
    868          #if OS_TICK_STEP_EN > 0
    869                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   0000001E   607A               LDRB     R0,[R4, #+9]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   03D0               BEQ.N    ??OSTimeTick_1
   \   00000024   0228               CMP      R0,#+2
   \   00000026   05D0               BEQ.N    ??OSTimeTick_2
   \   00000028   02D3               BCC.N    ??OSTimeTick_3
   \   0000002A   07E0               B.N      ??OSTimeTick_4
    870                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    871                           step = OS_TRUE;
   \                     ??OSTimeTick_1:
   \   0000002C   0120               MOVS     R0,#+1
   \   0000002E   08E0               B.N      ??OSTimeTick_5
    872                           break;
    873          
    874                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    875                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
   \                     ??OSTimeTick_3:
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   06E0               B.N      ??OSTimeTick_5
    876                           break;
    877          
    878                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    879                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
   \                     ??OSTimeTick_2:
   \   00000034   0120               MOVS     R0,#+1
    880                           OSTickStepState = OS_TICK_STEP_WAIT;
   \   00000036   0146               MOV      R1,R0
   \   00000038   6172               STRB     R1,[R4, #+9]
   \   0000003A   02E0               B.N      ??OSTimeTick_5
    881                           break;
    882          
    883                      default:                                       /* Invalid case, correct situation              */
    884                           step            = OS_TRUE;
   \                     ??OSTimeTick_4:
   \   0000003C   0120               MOVS     R0,#+1
    885                           OSTickStepState = OS_TICK_STEP_DIS;
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   6172               STRB     R1,[R4, #+9]
    886                           break;
    887                  }
    888                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
   \                     ??OSTimeTick_5:
   \   00000042   0028               CMP      R0,#+0
   \   00000044   34D0               BEQ.N    ??OSTimeTick_0
    889                      return;
    890                  }
    891          #endif
    892                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \   00000046   E56A               LDR      R5,[R4, #+44]
   \   00000048   18E0               B.N      ??OSTimeTick_6
    893                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
    894                      OS_ENTER_CRITICAL();
    895                      if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    896                          if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    897                                                                     /* Check for timeout                            */
    898                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    899                                  ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
    900                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
    901                              } else {
    902                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \                     ??OSTimeTick_7:
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   7177               STRB     R1,[R6, #+29]
    903                              }
    904          
    905                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \                     ??OSTimeTick_8:
   \   0000004E   317F               LDRB     R1,[R6, #+28]
   \   00000050   11F0080F           TST      R1,#0x8
   \   00000054   0FD1               BNE.N    ??OSTimeTick_9
    906                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   00000056   05F13401           ADD      R1,R5,#+52
   \   0000005A   A279               LDRB     R2,[R4, #+6]
   \   0000005C   8B78               LDRB     R3,[R1, #+2]
   \   0000005E   1A43               ORRS     R2,R3,R2
   \   00000060   A271               STRB     R2,[R4, #+6]
    907                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000062   95F83420           LDRB     R2,[R5, #+52]
   \   00000066   1219               ADDS     R2,R2,R4
   \   00000068   127B               LDRB     R2,[R2, #+12]
   \   0000006A   4978               LDRB     R1,[R1, #+1]
   \   0000006C   1143               ORRS     R1,R1,R2
   \   0000006E   95F83420           LDRB     R2,[R5, #+52]
   \   00000072   1219               ADDS     R2,R2,R4
   \   00000074   1173               STRB     R1,[R2, #+12]
    908                              }
    909                          }
    910                      }
    911                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_9:
   \   00000076   6D69               LDR      R5,[R5, #+20]
    912                      OS_EXIT_CRITICAL();
   \   00000078   ........           BL       OS_CPU_SR_Restore
   \                     ??OSTimeTick_6:
   \   0000007C   05F11406           ADD      R6,R5,#+20
   \   00000080   B07F               LDRB     R0,[R6, #+30]
   \   00000082   1F28               CMP      R0,#+31
   \   00000084   14D0               BEQ.N    ??OSTimeTick_0
   \   00000086   ........           BL       OS_CPU_SR_Save
   \   0000008A   718B               LDRH     R1,[R6, #+26]
   \   0000008C   0029               CMP      R1,#+0
   \   0000008E   F2D0               BEQ.N    ??OSTimeTick_9
   \   00000090   491E               SUBS     R1,R1,#+1
   \   00000092   7183               STRH     R1,[R6, #+26]
   \   00000094   718B               LDRH     R1,[R6, #+26]
   \   00000096   0029               CMP      R1,#+0
   \   00000098   EDD1               BNE.N    ??OSTimeTick_9
   \   0000009A   317F               LDRB     R1,[R6, #+28]
   \   0000009C   31F0C801           BICS     R1,R1,#0xC8
   \   000000A0   D3D0               BEQ.N    ??OSTimeTick_7
   \   000000A2   317F               LDRB     R1,[R6, #+28]
   \   000000A4   21F03701           BIC      R1,R1,#0x37
   \   000000A8   3177               STRB     R1,[R6, #+28]
   \   000000AA   0121               MOVS     R1,#+1
   \   000000AC   7177               STRB     R1,[R6, #+29]
   \   000000AE   CEE7               B.N      ??OSTimeTick_8
    913                  }
    914              }
   \                     ??OSTimeTick_0:
   \   000000B0   70BD               POP      {R4-R6,PC}       ;; return
    915          }
    916          
    917          /*$PAGE*/
    918          /*
    919          *********************************************************************************************************
    920          *                                             GET VERSION
    921          *
    922          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    923          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    924          *              would be returned as 200.
    925          *
    926          * Arguments  : none
    927          *
    928          * Returns    : the version number of uC/OS-II multiplied by 100.
    929          *********************************************************************************************************
    930          */
    931          

   \                                 In section .text, align 2, keep-with-next
    932          INT16U  OSVersion (void)
    933          {
    934              return (OS_VERSION);
   \                     OSVersion:
   \   00000000   4FF48F70           MOV      R0,#+286
   \   00000004   7047               BX       LR               ;; return
    935          }
    936          
    937          /*$PAGE*/
    938          /*
    939          *********************************************************************************************************
    940          *                                            DUMMY FUNCTION
    941          *
    942          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    943          *
    944          * Arguments  : none
    945          *
    946          * Returns    : none
    947          *********************************************************************************************************
    948          */
    949          
    950          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    951          void  OS_Dummy (void)
    952          {
    953          }
   \                     OS_Dummy:
   \   00000000   7047               BX       LR               ;; return
    954          #endif
    955          
    956          /*$PAGE*/
    957          /*
    958          *********************************************************************************************************
    959          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
    960          *
    961          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
    962          *              waiting for an event to occur.
    963          *
    964          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
    965          *
    966          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
    967          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
    968          *                          service functions.
    969          *
    970          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
    971          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
    972          *
    973          *              pend_stat   is used to indicate the readied task's pending status:
    974          *
    975          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
    976          *                                               an abort.
    977          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
    978          *
    979          * Returns    : none
    980          *
    981          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    982          *********************************************************************************************************
    983          */
    984          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
    985          INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
    986          {
   \                     OS_EventTaskRdy:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0446               MOV      R4,R0
    987              OS_TCB  *ptcb;
    988              INT8U    y;
    989              INT8U    x;
    990              INT8U    prio;
    991          #if OS_LOWEST_PRIO > 63
    992              INT16U  *ptbl;
    993          #endif
    994          
    995          
    996          #if OS_LOWEST_PRIO <= 63
    997              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \   00000004   ........           LDR.W    R5,??DataTable24  ;; OSUnMapTbl
   \   00000008   A07A               LDRB     R0,[R4, #+10]
   \   0000000A   465D               LDRB     R6,[R0, R5]
    998              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
    999              prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
   \   0000000C   3046               MOV      R0,R6
   \   0000000E   0719               ADDS     R7,R0,R4
   \   00000010   FF7A               LDRB     R7,[R7, #+11]
   \   00000012   7D5D               LDRB     R5,[R7, R5]
   \   00000014   05EBC605           ADD      R5,R5,R6, LSL #+3
   \   00000018   EDB2               UXTB     R5,R5
   1000          #else
   1001              if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
   1002                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
   1003              } else {
   1004                  y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
   1005              }
   1006              ptbl = &pevent->OSEventTbl[y];
   1007              if ((*ptbl & 0xFF) != 0) {
   1008                  x = OSUnMapTbl[*ptbl & 0xFF];
   1009              } else {
   1010                  x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
   1011              }
   1012              prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
   1013          #endif
   1014          
   1015              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   \   0000001A   2E46               MOV      R6,R5
   \   0000001C   ........           LDR.W    R7,??DataTable29  ;; OSTCBPrioTbl
   \   00000020   57F82660           LDR      R6,[R7, R6, LSL #+2]
   1016              ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
   \   00000024   06F11C07           ADD      R7,R6,#+28
   \   00000028   4FF0000C           MOV      R12,#+0
   \   0000002C   A7F812C0           STRH     R12,[R7, #+18]
   1017          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
   1018              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \   00000030   B960               STR      R1,[R7, #+8]
   1019          #else
   1020              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1021          #endif
   1022              ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
   \   00000032   397D               LDRB     R1,[R7, #+20]
   \   00000034   D243               MVNS     R2,R2
   \   00000036   1140               ANDS     R1,R2,R1
   \   00000038   3975               STRB     R1,[R7, #+20]
   1023              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \   0000003A   7B75               STRB     R3,[R7, #+21]
   1024                                                                  /* See if task is ready (could be susp'd)      */
   1025              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \   0000003C   397D               LDRB     R1,[R7, #+20]
   \   0000003E   11F0080F           TST      R1,#0x8
   \   00000042   0AD1               BNE.N    ??OS_EventTaskRdy_0
   1026                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \   00000044   ........           LDR.W    R1,??DataTable28  ;; OSCPUUsage
   \   00000048   8A79               LDRB     R2,[R1, #+6]
   \   0000004A   BB7E               LDRB     R3,[R7, #+26]
   \   0000004C   1A43               ORRS     R2,R3,R2
   \   0000004E   8A71               STRB     R2,[R1, #+6]
   1027                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \   00000050   4018               ADDS     R0,R0,R1
   \   00000052   017B               LDRB     R1,[R0, #+12]
   \   00000054   7A7E               LDRB     R2,[R7, #+25]
   \   00000056   1143               ORRS     R1,R2,R1
   \   00000058   0173               STRB     R1,[R0, #+12]
   1028              }
   1029          
   1030              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0:
   \   0000005A   2146               MOV      R1,R4
   \   0000005C   3046               MOV      R0,R6
   \   0000005E   ........           BL       OS_EventTaskRemove
   1031          #if (OS_EVENT_MULTI_EN > 0)
   1032              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   \   00000062   7868               LDR      R0,[R7, #+4]
   \   00000064   0028               CMP      R0,#+0
   \   00000066   04D0               BEQ.N    ??OS_EventTaskRdy_1
   1033                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   00000068   0146               MOV      R1,R0
   \   0000006A   3046               MOV      R0,R6
   \   0000006C   ........           BL       OS_EventTaskRemoveMulti
   1034                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   \   00000070   F461               STR      R4,[R6, #+28]
   1035              }
   1036          #endif
   1037          
   1038              return (prio);
   \                     ??OS_EventTaskRdy_1:
   \   00000072   2846               MOV      R0,R5
   \   00000074   F2BD               POP      {R1,R4-R7,PC}    ;; return
   1039          }
   1040          #endif
   1041          /*$PAGE*/
   1042          /*
   1043          *********************************************************************************************************
   1044          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
   1045          *
   1046          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1047          *              not occurred.
   1048          *
   1049          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1050          *
   1051          * Returns    : none
   1052          *
   1053          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1054          *********************************************************************************************************
   1055          */
   1056          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1057          void  OS_EventTaskWait (OS_EVENT *pevent)
   1058          {
   \                     OS_EventTaskWait:
   \   00000000   18B4               PUSH     {R3,R4}
   1059              INT8U  y;
   1060          
   1061          
   1062              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \   00000002   ........           LDR.W    R1,??DataTable28  ;; OSCPUUsage
   \   00000006   0A6A               LDR      R2,[R1, #+32]
   \   00000008   D061               STR      R0,[R2, #+28]
   1063          
   1064              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \   0000000A   0A6A               LDR      R2,[R1, #+32]
   \   0000000C   92F83430           LDRB     R3,[R2, #+52]
   \   00000010   1B18               ADDS     R3,R3,R0
   \   00000012   DB7A               LDRB     R3,[R3, #+11]
   \   00000014   02F13404           ADD      R4,R2,#+52
   \   00000018   6478               LDRB     R4,[R4, #+1]
   \   0000001A   2343               ORRS     R3,R4,R3
   \   0000001C   92F83420           LDRB     R2,[R2, #+52]
   \   00000020   1218               ADDS     R2,R2,R0
   \   00000022   D372               STRB     R3,[R2, #+11]
   1065              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000024   827A               LDRB     R2,[R0, #+10]
   \   00000026   0B6A               LDR      R3,[R1, #+32]
   \   00000028   93F83630           LDRB     R3,[R3, #+54]
   \   0000002C   1A43               ORRS     R2,R3,R2
   \   0000002E   8272               STRB     R2,[R0, #+10]
   1066          
   1067              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000030   086A               LDR      R0,[R1, #+32]
   \   00000032   90F83420           LDRB     R2,[R0, #+52]
   1068              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   00000036   5218               ADDS     R2,R2,R1
   \   00000038   3430               ADDS     R0,R0,#+52
   \   0000003A   137B               LDRB     R3,[R2, #+12]
   \   0000003C   4478               LDRB     R4,[R0, #+1]
   \   0000003E   E443               MVNS     R4,R4
   \   00000040   2340               ANDS     R3,R4,R3
   \   00000042   1373               STRB     R3,[R2, #+12]
   1069              if (OSRdyTbl[y] == 0) {
   \   00000044   04D1               BNE.N    ??OS_EventTaskWait_0
   1070                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000046   8A79               LDRB     R2,[R1, #+6]
   \   00000048   8078               LDRB     R0,[R0, #+2]
   \   0000004A   C043               MVNS     R0,R0
   \   0000004C   1040               ANDS     R0,R0,R2
   \   0000004E   8871               STRB     R0,[R1, #+6]
   1071              }
   1072          }
   \                     ??OS_EventTaskWait_0:
   \   00000050   11BC               POP      {R0,R4}
   \   00000052   7047               BX       LR               ;; return
   1073          #endif
   1074          /*$PAGE*/
   1075          /*
   1076          *********************************************************************************************************
   1077          *                          MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1078          *
   1079          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1080          *              multiple events has not occurred.
   1081          *
   1082          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for 
   1083          *                               which the task will be waiting for.
   1084          *
   1085          * Returns    : none.
   1086          *
   1087          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1088          *********************************************************************************************************
   1089          */
   1090          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1091          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1092          {
   \                     OS_EventTaskWaitMulti:
   \   00000000   30B4               PUSH     {R4,R5}
   1093              OS_EVENT **pevents;
   1094              OS_EVENT  *pevent;
   1095              INT8U      y;
   1096          
   1097          
   1098              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   \   00000002   ........           LDR.W    R1,??DataTable28  ;; OSCPUUsage
   \   00000006   0A6A               LDR      R2,[R1, #+32]
   \   00000008   0023               MOVS     R3,#+0
   \   0000000A   D361               STR      R3,[R2, #+28]
   1099              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   \   0000000C   0A6A               LDR      R2,[R1, #+32]
   \   0000000E   1062               STR      R0,[R2, #+32]
   1100          
   1101              pevents =  pevents_wait;
   1102              pevent  = *pevents;
   \   00000010   0268               LDR      R2,[R0, #+0]
   \   00000012   11E0               B.N      ??OS_EventTaskWaitMulti_0
   1103              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   1104                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   \                     ??OS_EventTaskWaitMulti_1:
   \   00000014   94F83450           LDRB     R5,[R4, #+52]
   \   00000018   AD18               ADDS     R5,R5,R2
   \   0000001A   ED7A               LDRB     R5,[R5, #+11]
   \   0000001C   5B78               LDRB     R3,[R3, #+1]
   \   0000001E   2B43               ORRS     R3,R3,R5
   \   00000020   94F83440           LDRB     R4,[R4, #+52]
   \   00000024   A418               ADDS     R4,R4,R2
   \   00000026   E372               STRB     R3,[R4, #+11]
   1105                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000028   937A               LDRB     R3,[R2, #+10]
   \   0000002A   0C6A               LDR      R4,[R1, #+32]
   \   0000002C   94F83640           LDRB     R4,[R4, #+54]
   \   00000030   2343               ORRS     R3,R4,R3
   \   00000032   9372               STRB     R3,[R2, #+10]
   1106                  pevents++;
   1107                  pevent = *pevents;
   \   00000034   50F8042F           LDR      R2,[R0, #+4]!
   1108              }
   \                     ??OS_EventTaskWaitMulti_0:
   \   00000038   0C6A               LDR      R4,[R1, #+32]
   \   0000003A   04F13403           ADD      R3,R4,#+52
   \   0000003E   002A               CMP      R2,#+0
   \   00000040   E8D1               BNE.N    ??OS_EventTaskWaitMulti_1
   1109          
   1110              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000042   94F83400           LDRB     R0,[R4, #+52]
   1111              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   00000046   4018               ADDS     R0,R0,R1
   \   00000048   027B               LDRB     R2,[R0, #+12]
   \   0000004A   5C78               LDRB     R4,[R3, #+1]
   \   0000004C   E443               MVNS     R4,R4
   \   0000004E   2240               ANDS     R2,R4,R2
   \   00000050   0273               STRB     R2,[R0, #+12]
   1112              if (OSRdyTbl[y] == 0) {
   \   00000052   04D1               BNE.N    ??OS_EventTaskWaitMulti_2
   1113                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000054   8879               LDRB     R0,[R1, #+6]
   \   00000056   9A78               LDRB     R2,[R3, #+2]
   \   00000058   D243               MVNS     R2,R2
   \   0000005A   1040               ANDS     R0,R2,R0
   \   0000005C   8871               STRB     R0,[R1, #+6]
   1114              }
   1115          }
   \                     ??OS_EventTaskWaitMulti_2:
   \   0000005E   30BC               POP      {R4,R5}
   \   00000060   7047               BX       LR               ;; return
   1116          #endif
   1117          /*$PAGE*/
   1118          /*
   1119          *********************************************************************************************************
   1120          *                                   REMOVE TASK FROM EVENT WAIT LIST
   1121          *
   1122          * Description: Remove a task from an event's wait list.
   1123          *
   1124          * Arguments  : ptcb     is a pointer to the task to remove.
   1125          *
   1126          *              pevent   is a pointer to the event control block.
   1127          *
   1128          * Returns    : none
   1129          *
   1130          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1131          *********************************************************************************************************
   1132          */
   1133          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1134          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   1135                                    OS_EVENT *pevent)
   1136          {
   \                     OS_EventTaskRemove:
   \   00000000   18B4               PUSH     {R3,R4}
   1137              INT8U  y;
   1138          
   1139          
   1140              y                       =  ptcb->OSTCBY;
   \   00000002   90F83420           LDRB     R2,[R0, #+52]
   1141              pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
   \   00000006   5218               ADDS     R2,R2,R1
   \   00000008   3430               ADDS     R0,R0,#+52
   \   0000000A   D37A               LDRB     R3,[R2, #+11]
   \   0000000C   4478               LDRB     R4,[R0, #+1]
   \   0000000E   E443               MVNS     R4,R4
   \   00000010   2340               ANDS     R3,R4,R3
   \   00000012   D372               STRB     R3,[R2, #+11]
   1142              if (pevent->OSEventTbl[y] == 0) {
   \   00000014   D27A               LDRB     R2,[R2, #+11]
   \   00000016   002A               CMP      R2,#+0
   \   00000018   04D1               BNE.N    ??OS_EventTaskRemove_0
   1143                  pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
   \   0000001A   8A7A               LDRB     R2,[R1, #+10]
   \   0000001C   8078               LDRB     R0,[R0, #+2]
   \   0000001E   C043               MVNS     R0,R0
   \   00000020   1040               ANDS     R0,R0,R2
   \   00000022   8872               STRB     R0,[R1, #+10]
   1144              }
   1145          }
   \                     ??OS_EventTaskRemove_0:
   \   00000024   11BC               POP      {R0,R4}
   \   00000026   7047               BX       LR               ;; return
   1146          #endif
   1147          /*$PAGE*/
   1148          /*
   1149          *********************************************************************************************************
   1150          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1151          *
   1152          * Description: Remove a task from multiple events' wait lists.
   1153          *
   1154          * Arguments  : ptcb             is a pointer to the task to remove.
   1155          *
   1156          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1157          *
   1158          * Returns    : none
   1159          *
   1160          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1161          *********************************************************************************************************
   1162          */
   1163          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1164          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1165                                         OS_EVENT **pevents_multi)
   1166          {
   \                     OS_EventTaskRemoveMulti:
   \   00000000   F0B4               PUSH     {R4-R7}
   1167              OS_EVENT **pevents;
   1168              OS_EVENT  *pevent;
   1169              INT8U      y;
   1170          #if (OS_LOWEST_PRIO <= 63)
   1171              INT8U      bity;
   1172              INT8U      bitx;
   1173          #else
   1174              INT16U     bity;
   1175              INT16U     bitx;
   1176          #endif
   1177          
   1178          
   1179              y       =  ptcb->OSTCBY;
   \   00000002   90F83420           LDRB     R2,[R0, #+52]
   1180              bity    =  ptcb->OSTCBBitY;
   \   00000006   00F13403           ADD      R3,R0,#+52
   \   0000000A   9878               LDRB     R0,[R3, #+2]
   1181              bitx    =  ptcb->OSTCBBitX;
   \   0000000C   5B78               LDRB     R3,[R3, #+1]
   1182              pevents =  pevents_multi;
   1183              pevent  = *pevents;
   \   0000000E   0C68               LDR      R4,[R1, #+0]
   \   00000010   DF43               MVNS     R7,R3
   \   00000012   0DE0               B.N      ??OS_EventTaskRemoveMulti_0
   1184              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   1185                  pevent->OSEventTbl[y]  &= ~bitx;
   \                     ??OS_EventTaskRemoveMulti_1:
   \   00000014   1546               MOV      R5,R2
   \   00000016   2D19               ADDS     R5,R5,R4
   \   00000018   EE7A               LDRB     R6,[R5, #+11]
   \   0000001A   3E40               ANDS     R6,R7,R6
   \   0000001C   EE72               STRB     R6,[R5, #+11]
   1186                  if (pevent->OSEventTbl[y] == 0) {
   \   0000001E   ED7A               LDRB     R5,[R5, #+11]
   \   00000020   002D               CMP      R5,#+0
   \   00000022   03D1               BNE.N    ??OS_EventTaskRemoveMulti_2
   1187                      pevent->OSEventGrp &= ~bity;
   \   00000024   A57A               LDRB     R5,[R4, #+10]
   \   00000026   C643               MVNS     R6,R0
   \   00000028   3540               ANDS     R5,R6,R5
   \   0000002A   A572               STRB     R5,[R4, #+10]
   1188                  }
   1189                  pevents++;
   1190                  pevent = *pevents;
   \                     ??OS_EventTaskRemoveMulti_2:
   \   0000002C   51F8044F           LDR      R4,[R1, #+4]!
   1191              }
   \                     ??OS_EventTaskRemoveMulti_0:
   \   00000030   002C               CMP      R4,#+0
   \   00000032   EFD1               BNE.N    ??OS_EventTaskRemoveMulti_1
   1192          }
   \   00000034   F0BC               POP      {R4-R7}
   \   00000036   7047               BX       LR               ;; return
   1193          #endif
   1194          /*$PAGE*/
   1195          /*
   1196          *********************************************************************************************************
   1197          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1198          *
   1199          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1200          *
   1201          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1202          *
   1203          * Returns    : none
   1204          *
   1205          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1206          *********************************************************************************************************
   1207          */
   1208          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1209          void  OS_EventWaitListInit (OS_EVENT *pevent)
   1210          {
   1211          #if OS_LOWEST_PRIO <= 63
   1212              INT8U  *ptbl;
   1213          #else
   1214              INT16U *ptbl;
   1215          #endif
   1216              INT8U   i;
   1217          
   1218          
   1219              pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
   \                     OS_EventWaitListInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   8172               STRB     R1,[R0, #+10]
   1220              ptbl               = &pevent->OSEventTbl[0];
   \   00000004   0B30               ADDS     R0,R0,#+11
   1221          
   1222              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
   \   00000006   04E0               B.N      ??OS_EventWaitListInit_0
   1223                  *ptbl++ = 0;
   \                     ??OS_EventWaitListInit_1:
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   00F8012B           STRB     R2,[R0], #+1
   1224              }
   \   0000000E   491C               ADDS     R1,R1,#+1
   \   00000010   C9B2               UXTB     R1,R1
   \                     ??OS_EventWaitListInit_0:
   \   00000012   0A46               MOV      R2,R1
   \   00000014   042A               CMP      R2,#+4
   \   00000016   F7D3               BCC.N    ??OS_EventWaitListInit_1
   1225          }
   \   00000018   7047               BX       LR               ;; return
   1226          #endif
   1227          /*$PAGE*/
   1228          /*
   1229          *********************************************************************************************************
   1230          *                                             INITIALIZATION
   1231          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1232          *
   1233          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1234          *
   1235          * Arguments  : none
   1236          *
   1237          * Returns    : none
   1238          *********************************************************************************************************
   1239          */
   1240          

   \                                 In section .text, align 4, keep-with-next
   1241          static  void  OS_InitEventList (void)
   1242          {
   \                     OS_InitEventList:
   \   00000000   10B5               PUSH     {R4,LR}
   1243          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
   1244          #if (OS_MAX_EVENTS > 1)
   1245              INT16U     i;
   1246              OS_EVENT  *pevent1;
   1247              OS_EVENT  *pevent2;
   1248          
   1249          
   1250              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   \   00000002   134C               LDR.N    R4,??OS_InitEventList_0  ;; OSEventFreeList
   \   00000004   4FF4A071           MOV      R1,#+320
   \   00000008   201D               ADDS     R0,R4,#+4
   \   0000000A   ........           BL       OS_MemClr
   1251              pevent1 = &OSEventTbl[0];
   \   0000000E   201D               ADDS     R0,R4,#+4
   1252              pevent2 = &OSEventTbl[1];
   \   00000010   04F12401           ADD      R1,R4,#+36
   1253              for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
   \   00000014   0022               MOVS     R2,#+0
   \   00000016   0DE0               B.N      ??OS_InitEventList_1
   1254                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_InitEventList_2:
   \   00000018   0023               MOVS     R3,#+0
   \   0000001A   00F8043B           STRB     R3,[R0], #+4
   1255                  pevent1->OSEventPtr     = pevent2;
   \   0000001E   40F80B1B           STR      R1,[R0], #+11
   1256          #if OS_EVENT_NAME_SIZE > 1
   1257                  pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
   \   00000022   3F23               MOVS     R3,#+63
   \   00000024   00F8013B           STRB     R3,[R0], #+1
   1258                  pevent1->OSEventName[1] = OS_ASCII_NUL;
   \   00000028   0023               MOVS     R3,#+0
   \   0000002A   00F8103B           STRB     R3,[R0], #+16
   1259          #endif
   1260                  pevent1++;
   1261                  pevent2++;
   \   0000002E   2031               ADDS     R1,R1,#+32
   1262              }
   \   00000030   521C               ADDS     R2,R2,#+1
   \   00000032   92B2               UXTH     R2,R2
   \                     ??OS_InitEventList_1:
   \   00000034   1346               MOV      R3,R2
   \   00000036   092B               CMP      R3,#+9
   \   00000038   EED3               BCC.N    ??OS_InitEventList_2
   1263              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   \   0000003A   0021               MOVS     R1,#+0
   \   0000003C   0170               STRB     R1,[R0, #+0]
   1264              pevent1->OSEventPtr             = (OS_EVENT *)0;
   \   0000003E   4160               STR      R1,[R0, #+4]
   1265          #if OS_EVENT_NAME_SIZE > 1
   1266              pevent1->OSEventName[0]         = '?';
   \   00000040   3F21               MOVS     R1,#+63
   \   00000042   C173               STRB     R1,[R0, #+15]
   1267              pevent1->OSEventName[1]         = OS_ASCII_NUL;
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0174               STRB     R1,[R0, #+16]
   1268          #endif
   1269              OSEventFreeList                 = &OSEventTbl[0];
   \   00000048   201D               ADDS     R0,R4,#+4
   \   0000004A   2060               STR      R0,[R4, #+0]
   1270          #else
   1271              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1272              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1273              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1274          #if OS_EVENT_NAME_SIZE > 1
   1275              OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
   1276              OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
   1277          #endif
   1278          #endif
   1279          #endif
   1280          }
   \   0000004C   10BD               POP      {R4,PC}          ;; return
   \   0000004E   00BF               Nop      
   \                     ??OS_InitEventList_0:
   \   00000050   ........           DC32     OSEventFreeList
   1281          /*$PAGE*/
   1282          /*
   1283          *********************************************************************************************************
   1284          *                                             INITIALIZATION
   1285          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1286          *
   1287          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1288          *
   1289          * Arguments  : none
   1290          *
   1291          * Returns    : none
   1292          *********************************************************************************************************
   1293          */
   1294          

   \                                 In section .text, align 2, keep-with-next
   1295          static  void  OS_InitMisc (void)
   1296          {
   1297          #if OS_TIME_GET_SET_EN > 0
   1298              OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
   \                     OS_InitMisc:
   \   00000000   ........           LDR.W    R0,??DataTable28  ;; OSCPUUsage
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0163               STR      R1,[R0, #+48]
   1299          #endif
   1300          
   1301              OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
   \   00000008   8170               STRB     R1,[R0, #+2]
   1302              OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
   \   0000000A   C170               STRB     R1,[R0, #+3]
   1303          
   1304              OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
   \   0000000C   0172               STRB     R1,[R0, #+8]
   1305          
   1306              OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
   \   0000000E   C171               STRB     R1,[R0, #+7]
   1307          
   1308              OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
   \   00000010   0161               STR      R1,[R0, #+16]
   1309              OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
   \   00000012   C161               STR      R1,[R0, #+28]
   1310          
   1311          #if OS_TASK_STAT_EN > 0
   1312              OSIdleCtrRun  = 0L;
   \   00000014   8161               STR      R1,[R0, #+24]
   1313              OSIdleCtrMax  = 0L;
   \   00000016   4161               STR      R1,[R0, #+20]
   1314              OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
   \   00000018   4170               STRB     R1,[R0, #+1]
   1315          #endif
   1316          }
   \   0000001A   7047               BX       LR               ;; return
   1317          /*$PAGE*/
   1318          /*
   1319          *********************************************************************************************************
   1320          *                                             INITIALIZATION
   1321          *                                       INITIALIZE THE READY LIST
   1322          *
   1323          * Description: This function is called by OSInit() to initialize the Ready List.
   1324          *
   1325          * Arguments  : none
   1326          *
   1327          * Returns    : none
   1328          *********************************************************************************************************
   1329          */
   1330          

   \                                 In section .text, align 2, keep-with-next
   1331          static  void  OS_InitRdyList (void)
   1332          {
   1333              INT8U    i;
   1334          #if OS_LOWEST_PRIO <= 63
   1335              INT8U   *prdytbl;
   1336          #else
   1337              INT16U  *prdytbl;
   1338          #endif
   1339          
   1340          
   1341              OSRdyGrp      = 0;                                     /* Clear the ready list                     */
   \                     OS_InitRdyList:
   \   00000000   ........           LDR.W    R0,??DataTable28  ;; OSCPUUsage
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   8171               STRB     R1,[R0, #+6]
   1342              prdytbl       = &OSRdyTbl[0];
   \   00000008   00F10C01           ADD      R1,R0,#+12
   1343              for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   04E0               B.N      ??OS_InitRdyList_0
   1344                  *prdytbl++ = 0;
   \                     ??OS_InitRdyList_1:
   \   00000010   0023               MOVS     R3,#+0
   \   00000012   01F8013B           STRB     R3,[R1], #+1
   1345              }
   \   00000016   521C               ADDS     R2,R2,#+1
   \   00000018   D2B2               UXTB     R2,R2
   \                     ??OS_InitRdyList_0:
   \   0000001A   1346               MOV      R3,R2
   \   0000001C   042B               CMP      R3,#+4
   \   0000001E   F7D3               BCC.N    ??OS_InitRdyList_1
   1346          
   1347              OSPrioCur     = 0;
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   0171               STRB     R1,[R0, #+4]
   1348              OSPrioHighRdy = 0;
   \   00000024   4171               STRB     R1,[R0, #+5]
   1349          
   1350              OSTCBHighRdy  = (OS_TCB *)0;
   \   00000026   8162               STR      R1,[R0, #+40]
   1351              OSTCBCur      = (OS_TCB *)0;
   \   00000028   0162               STR      R1,[R0, #+32]
   1352          }
   \   0000002A   7047               BX       LR               ;; return
   1353          
   1354          /*$PAGE*/
   1355          /*
   1356          *********************************************************************************************************
   1357          *                                             INITIALIZATION
   1358          *                                         CREATING THE IDLE TASK
   1359          *
   1360          * Description: This function creates the Idle Task.
   1361          *
   1362          * Arguments  : none
   1363          *
   1364          * Returns    : none
   1365          *********************************************************************************************************
   1366          */
   1367          

   \                                 In section .text, align 4, keep-with-next
   1368          static  void  OS_InitTaskIdle (void)
   1369          {
   \                     OS_InitTaskIdle:
   \   00000000   80B5               PUSH     {R7,LR}
   1370          #if OS_TASK_NAME_SIZE > 7
   1371              INT8U  err;
   1372          #endif
   1373          
   1374          
   1375          #if OS_TASK_CREATE_EXT_EN > 0
   1376              #if OS_STK_GROWTH == 1
   1377              (void)OSTaskCreateExt(OS_TaskIdle,
   1378                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1379                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
   1380                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1381                                    OS_TASK_IDLE_ID,
   1382                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1383                                    OS_TASK_IDLE_STK_SIZE,
   1384                                    (void *)0,                                 /* No TCB extension                     */
   1385                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   \   00000002   0C4A               LDR.N    R2,??OS_InitTaskIdle_0  ;; OSTaskIdleStk
   \   00000004   0320               MOVS     R0,#+3
   \   00000006   01B5               PUSH     {R0,LR}
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8020               MOVS     R0,#+128
   \   0000000C   03B4               PUSH     {R0,R1}
   \   0000000E   1146               MOV      R1,R2
   \   00000010   4FF6FF70           MOVW     R0,#+65535
   \   00000014   03B4               PUSH     {R0,R1}
   \   00000016   1F23               MOVS     R3,#+31
   \   00000018   02F5FE72           ADD      R2,R2,#+508
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   0648               LDR.N    R0,??OS_InitTaskIdle_0+0x4  ;; OS_TaskIdle
   \   00000020   ........           BL       OSTaskCreateExt
   \   00000024   06B0               ADD      SP,SP,#+24
   1386              #else
   1387              (void)OSTaskCreateExt(OS_TaskIdle,
   1388                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1389                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1390                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1391                                    OS_TASK_IDLE_ID,
   1392                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
   1393                                    OS_TASK_IDLE_STK_SIZE,
   1394                                    (void *)0,                                 /* No TCB extension                     */
   1395                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1396              #endif
   1397          #else
   1398              #if OS_STK_GROWTH == 1
   1399              (void)OSTaskCreate(OS_TaskIdle,
   1400                                 (void *)0,
   1401                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
   1402                                 OS_TASK_IDLE_PRIO);
   1403              #else
   1404              (void)OSTaskCreate(OS_TaskIdle,
   1405                                 (void *)0,
   1406                                 &OSTaskIdleStk[0],
   1407                                 OS_TASK_IDLE_PRIO);
   1408              #endif
   1409          #endif
   1410          
   1411          #if OS_TASK_NAME_SIZE > 14
   1412              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
   \   00000026   00AA               ADD      R2,SP,#+0
   \   00000028   0449               LDR.N    R1,??OS_InitTaskIdle_0+0x8  ;; `?<Constant "uC/OS-II Idle">`
   \   0000002A   1F20               MOVS     R0,#+31
   \   0000002C   ........           BL       OSTaskNameSet
   1413          #else
   1414          #if OS_TASK_NAME_SIZE > 7
   1415              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
   1416          #endif
   1417          #endif
   1418          }
   \   00000030   01BD               POP      {R0,PC}          ;; return
   \   00000032   00BF               Nop      
   \                     ??OS_InitTaskIdle_0:
   \   00000034   ........           DC32     OSTaskIdleStk
   \   00000038   ........           DC32     OS_TaskIdle
   \   0000003C   ........           DC32     `?<Constant "uC/OS-II Idle">`
   1419          /*$PAGE*/
   1420          /*
   1421          *********************************************************************************************************
   1422          *                                             INITIALIZATION
   1423          *                                      CREATING THE STATISTIC TASK
   1424          *
   1425          * Description: This function creates the Statistic Task.
   1426          *
   1427          * Arguments  : none
   1428          *
   1429          * Returns    : none
   1430          *********************************************************************************************************
   1431          */
   1432          
   1433          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 4, keep-with-next
   1434          static  void  OS_InitTaskStat (void)
   1435          {
   \                     OS_InitTaskStat:
   \   00000000   80B5               PUSH     {R7,LR}
   1436          #if OS_TASK_NAME_SIZE > 7
   1437              INT8U  err;
   1438          #endif
   1439          
   1440          
   1441          #if OS_TASK_CREATE_EXT_EN > 0
   1442              #if OS_STK_GROWTH == 1
   1443              (void)OSTaskCreateExt(OS_TaskStat,
   1444                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1445                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
   1446                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1447                                    OS_TASK_STAT_ID,
   1448                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1449                                    OS_TASK_STAT_STK_SIZE,
   1450                                    (void *)0,                                   /* No TCB extension               */
   1451                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   \   00000002   0C4A               LDR.N    R2,??OS_InitTaskStat_0  ;; OSTaskStatStk
   \   00000004   0320               MOVS     R0,#+3
   \   00000006   01B5               PUSH     {R0,LR}
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8020               MOVS     R0,#+128
   \   0000000C   03B4               PUSH     {R0,R1}
   \   0000000E   1146               MOV      R1,R2
   \   00000010   4FF6FE70           MOVW     R0,#+65534
   \   00000014   03B4               PUSH     {R0,R1}
   \   00000016   1E23               MOVS     R3,#+30
   \   00000018   02F5FE72           ADD      R2,R2,#+508
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   0648               LDR.N    R0,??OS_InitTaskStat_0+0x4  ;; OS_TaskStat
   \   00000020   ........           BL       OSTaskCreateExt
   \   00000024   06B0               ADD      SP,SP,#+24
   1452              #else
   1453              (void)OSTaskCreateExt(OS_TaskStat,
   1454                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1455                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1456                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1457                                    OS_TASK_STAT_ID,
   1458                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
   1459                                    OS_TASK_STAT_STK_SIZE,
   1460                                    (void *)0,                                   /* No TCB extension               */
   1461                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1462              #endif
   1463          #else
   1464              #if OS_STK_GROWTH == 1
   1465              (void)OSTaskCreate(OS_TaskStat,
   1466                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1467                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
   1468                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1469              #else
   1470              (void)OSTaskCreate(OS_TaskStat,
   1471                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1472                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1473                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1474              #endif
   1475          #endif
   1476          
   1477          #if OS_TASK_NAME_SIZE > 14
   1478              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
   \   00000026   00AA               ADD      R2,SP,#+0
   \   00000028   0449               LDR.N    R1,??OS_InitTaskStat_0+0x8  ;; `?<Constant "uC/OS-II Stat">`
   \   0000002A   1E20               MOVS     R0,#+30
   \   0000002C   ........           BL       OSTaskNameSet
   1479          #else
   1480          #if OS_TASK_NAME_SIZE > 7
   1481              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
   1482          #endif
   1483          #endif
   1484          }
   \   00000030   01BD               POP      {R0,PC}          ;; return
   \   00000032   00BF               Nop      
   \                     ??OS_InitTaskStat_0:
   \   00000034   ........           DC32     OSTaskStatStk
   \   00000038   ........           DC32     OS_TaskStat
   \   0000003C   ........           DC32     `?<Constant "uC/OS-II Stat">`
   1485          #endif
   1486          /*$PAGE*/
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                             INITIALIZATION
   1490          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1491          *
   1492          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1493          *
   1494          * Arguments  : none
   1495          *
   1496          * Returns    : none
   1497          *********************************************************************************************************
   1498          */
   1499          

   \                                 In section .text, align 2, keep-with-next
   1500          static  void  OS_InitTCBList (void)
   1501          {
   \                     OS_InitTCBList:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   1502              INT8U    i;
   1503              OS_TCB  *ptcb1;
   1504              OS_TCB  *ptcb2;
   1505          
   1506          
   1507              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   \   00000002   ....               LDR.N    R4,??DataTable28  ;; OSCPUUsage
   \   00000004   4FF4CF61           MOV      R1,#+1656
   \   00000008   04F13400           ADD      R0,R4,#+52
   \   0000000C   ........           BL       OS_MemClr
   1508              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   \   00000010   8021               MOVS     R1,#+128
   \   00000012   ....               LDR.N    R0,??DataTable29  ;; OSTCBPrioTbl
   \   00000014   ........           BL       OS_MemClr
   1509              ptcb1 = &OSTCBTbl[0];
   \   00000018   04F13400           ADD      R0,R4,#+52
   1510              ptcb2 = &OSTCBTbl[1];
   \   0000001C   04F19001           ADD      R1,R4,#+144
   1511              for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   08E0               B.N      ??OS_InitTCBList_0
   1512                  ptcb1->OSTCBNext = ptcb2;
   \                     ??OS_InitTCBList_1:
   \   00000024   4161               STR      R1,[R0, #+20]
   1513          #if OS_TASK_NAME_SIZE > 1
   1514                  ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
   \   00000026   3F25               MOVS     R5,#+63
   \   00000028   80F84C50           STRB     R5,[R0, #+76]
   1515                  ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   0000002C   0025               MOVS     R5,#+0
   \   0000002E   5D70               STRB     R5,[R3, #+1]
   1516          #endif
   1517                  ptcb1++;
   \   00000030   5C30               ADDS     R0,R0,#+92
   1518                  ptcb2++;
   \   00000032   5C31               ADDS     R1,R1,#+92
   1519              }
   \   00000034   521C               ADDS     R2,R2,#+1
   \                     ??OS_InitTCBList_0:
   \   00000036   00F14C03           ADD      R3,R0,#+76
   \   0000003A   112A               CMP      R2,#+17
   \   0000003C   F2D3               BCC.N    ??OS_InitTCBList_1
   1520              ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   4161               STR      R1,[R0, #+20]
   1521          #if OS_TASK_NAME_SIZE > 1
   1522              ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
   \   00000042   3F21               MOVS     R1,#+63
   \   00000044   80F84C10           STRB     R1,[R0, #+76]
   1523              ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   5870               STRB     R0,[R3, #+1]
   1524          #endif
   1525              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   \   0000004C   E062               STR      R0,[R4, #+44]
   1526              OSTCBFreeList           = &OSTCBTbl[0];
   \   0000004E   04F13400           ADD      R0,R4,#+52
   \   00000052   6062               STR      R0,[R4, #+36]
   1527          }
   \   00000054   31BD               POP      {R0,R4,R5,PC}    ;; return
   1528          /*$PAGE*/
   1529          /*
   1530          *********************************************************************************************************
   1531          *                                        CLEAR A SECTION OF MEMORY
   1532          *
   1533          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1534          *
   1535          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1536          *
   1537          *              size     is the number of bytes to clear.
   1538          *
   1539          * Returns    : none
   1540          *
   1541          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1542          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1543          *                 of the uses of this function gets close to this limit.
   1544          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1545          *                 of the alignment of the destination.
   1546          *********************************************************************************************************
   1547          */
   1548          

   \                                 In section .text, align 2, keep-with-next
   1549          void  OS_MemClr (INT8U *pdest, INT16U size)
   1550          {
   \                     OS_MemClr:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   02E0               B.N      ??OS_MemClr_0
   1551              while (size > 0) {
   1552                  *pdest++ = (INT8U)0;
   \                     ??OS_MemClr_1:
   \   00000004   00F8012B           STRB     R2,[R0], #+1
   1553                  size--;
   \   00000008   491E               SUBS     R1,R1,#+1
   1554              }
   \                     ??OS_MemClr_0:
   \   0000000A   89B2               UXTH     R1,R1
   \   0000000C   0029               CMP      R1,#+0
   \   0000000E   F9D1               BNE.N    ??OS_MemClr_1
   1555          }
   \   00000010   7047               BX       LR               ;; return
   1556          /*$PAGE*/
   1557          /*
   1558          *********************************************************************************************************
   1559          *                                        COPY A BLOCK OF MEMORY
   1560          *
   1561          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1562          *              location to another.
   1563          *
   1564          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1565          *
   1566          *              psrc     is a pointer to the 'source'      memory block
   1567          *
   1568          *              size     is the number of bytes to copy.
   1569          *
   1570          * Returns    : none
   1571          *
   1572          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1573          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1574          *                 is not a situation that will happen.
   1575          *              2) Note that we can only copy up to 64K bytes of RAM
   1576          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1577          *                 of the alignment of the source and destination.
   1578          *********************************************************************************************************
   1579          */
   1580          

   \                                 In section .text, align 2, keep-with-next
   1581          void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
   1582          {
   \                     OS_MemCopy:
   \   00000000   04E0               B.N      ??OS_MemCopy_0
   1583              while (size > 0) {
   1584                  *pdest++ = *psrc++;
   \                     ??OS_MemCopy_1:
   \   00000002   11F8013B           LDRB     R3,[R1], #+1
   \   00000006   00F8013B           STRB     R3,[R0], #+1
   1585                  size--;
   \   0000000A   521E               SUBS     R2,R2,#+1
   1586              }
   \                     ??OS_MemCopy_0:
   \   0000000C   92B2               UXTH     R2,R2
   \   0000000E   002A               CMP      R2,#+0
   \   00000010   F7D1               BNE.N    ??OS_MemCopy_1
   1587          }
   \   00000012   7047               BX       LR               ;; return
   1588          /*$PAGE*/
   1589          /*
   1590          *********************************************************************************************************
   1591          *                                              SCHEDULER
   1592          *
   1593          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1594          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1595          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1596          *
   1597          * Arguments  : none
   1598          *
   1599          * Returns    : none
   1600          *
   1601          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1602          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1603          *********************************************************************************************************
   1604          */
   1605          

   \                                 In section .text, align 2, keep-with-next
   1606          void  OS_Sched (void)
   1607          {
   \                     OS_Sched:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   1608          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
   1609              OS_CPU_SR  cpu_sr = 0;
   1610          #endif
   1611          
   1612          
   1613          
   1614              OS_ENTER_CRITICAL();
   \   00000002   ........           BL       OS_CPU_SR_Save
   \   00000006   0446               MOV      R4,R0
   1615              if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
   1616                  if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
   \   00000008   ....               LDR.N    R5,??DataTable28  ;; OSCPUUsage
   \   0000000A   A878               LDRB     R0,[R5, #+2]
   \   0000000C   E978               LDRB     R1,[R5, #+3]
   \   0000000E   0843               ORRS     R0,R1,R0
   \   00000010   11D1               BNE.N    ??OS_Sched_0
   1617                      OS_SchedNew();
   \   00000012   ........           BL       OS_SchedNew
   1618                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \   00000016   6879               LDRB     R0,[R5, #+5]
   \   00000018   2979               LDRB     R1,[R5, #+4]
   \   0000001A   8842               CMP      R0,R1
   \   0000001C   0BD0               BEQ.N    ??OS_Sched_0
   1619                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000001E   ....               LDR.N    R1,??DataTable29  ;; OSTCBPrioTbl
   \   00000020   51F82000           LDR      R0,[R1, R0, LSL #+2]
   \   00000024   A862               STR      R0,[R5, #+40]
   1620          #if OS_TASK_PROFILE_EN > 0
   1621                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00000026   816B               LDR      R1,[R0, #+56]
   \   00000028   491C               ADDS     R1,R1,#+1
   \   0000002A   8163               STR      R1,[R0, #+56]
   1622          #endif
   1623                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \   0000002C   2869               LDR      R0,[R5, #+16]
   \   0000002E   401C               ADDS     R0,R0,#+1
   \   00000030   2861               STR      R0,[R5, #+16]
   1624                          OS_TASK_SW();                          /* Perform a context switch                     */
   \   00000032   ........           BL       OSCtxSw
   1625                      }
   1626                  }
   1627              }
   1628              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0:
   \   00000036   2046               MOV      R0,R4
   \   00000038   BDE83240           POP      {R1,R4,R5,LR}
   \   0000003C   ........           B.W      OS_CPU_SR_Restore
   1629          }
   1630          
   1631          
   1632          /*
   1633          *********************************************************************************************************
   1634          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1635          *
   1636          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1637          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1638          *
   1639          * Arguments  : none
   1640          *
   1641          * Returns    : none
   1642          *
   1643          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1644          *              2) Interrupts are assumed to be disabled when this function is called.
   1645          *********************************************************************************************************
   1646          */
   1647          

   \                                 In section .text, align 2, keep-with-next
   1648          static  void  OS_SchedNew (void)
   1649          {
   1650          #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
   1651              INT8U   y;
   1652          
   1653          
   1654              y             = OSUnMapTbl[OSRdyGrp];
   \                     OS_SchedNew:
   \   00000000   ....               LDR.N    R0,??DataTable28  ;; OSCPUUsage
   \   00000002   ....               LDR.N    R1,??DataTable24  ;; OSUnMapTbl
   \   00000004   8279               LDRB     R2,[R0, #+6]
   \   00000006   525C               LDRB     R2,[R2, R1]
   1655              OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
   \   00000008   1346               MOV      R3,R2
   \   0000000A   1B18               ADDS     R3,R3,R0
   \   0000000C   1B7B               LDRB     R3,[R3, #+12]
   \   0000000E   595C               LDRB     R1,[R3, R1]
   \   00000010   01EBC201           ADD      R1,R1,R2, LSL #+3
   \   00000014   4171               STRB     R1,[R0, #+5]
   1656          #else                                            /* We support up to 256 tasks                         */
   1657              INT8U   y;
   1658              INT16U *ptbl;
   1659          
   1660          
   1661              if ((OSRdyGrp & 0xFF) != 0) {
   1662                  y = OSUnMapTbl[OSRdyGrp & 0xFF];
   1663              } else {
   1664                  y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
   1665              }
   1666              ptbl = &OSRdyTbl[y];
   1667              if ((*ptbl & 0xFF) != 0) {
   1668                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
   1669              } else {
   1670                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
   1671              }
   1672          #endif
   1673          }
   \   00000016   7047               BX       LR               ;; return
   1674          
   1675          /*$PAGE*/
   1676          /*
   1677          *********************************************************************************************************
   1678          *                                        COPY AN ASCII STRING
   1679          *
   1680          * Description: This function is called by other uC/OS-II services to copy an ASCII string from a 'source'
   1681          *              string to a 'destination' string.
   1682          *
   1683          * Arguments  : pdest    is a pointer to the string that will be receiving the copy.  Note that there MUST
   1684          *                       be sufficient space in the destination storage area to receive this string.
   1685          *
   1686          *              psrc     is a pointer to the source string.  The source string MUST NOT be greater than
   1687          *                       254 characters.
   1688          *
   1689          * Returns    : The size of the string (excluding the NUL terminating character)
   1690          *
   1691          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1692          *********************************************************************************************************
   1693          */
   1694          
   1695          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1696          INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
   1697          {
   \                     OS_StrCopy:
   \   00000000   0246               MOV      R2,R0
   1698              INT8U  len;
   1699          
   1700          
   1701              len = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   05E0               B.N      ??OS_StrCopy_0
   1702              while (*psrc != OS_ASCII_NUL) {
   1703                  *pdest++ = *psrc++;
   \                     ??OS_StrCopy_1:
   \   00000006   11F8013B           LDRB     R3,[R1], #+1
   \   0000000A   02F8013B           STRB     R3,[R2], #+1
   1704                  len++;
   \   0000000E   401C               ADDS     R0,R0,#+1
   \   00000010   C0B2               UXTB     R0,R0
   1705              }
   \                     ??OS_StrCopy_0:
   \   00000012   0B78               LDRB     R3,[R1, #+0]
   \   00000014   002B               CMP      R3,#+0
   \   00000016   F6D1               BNE.N    ??OS_StrCopy_1
   1706              *pdest = OS_ASCII_NUL;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   1170               STRB     R1,[R2, #+0]
   1707              return (len);
   \   0000001C   7047               BX       LR               ;; return
   1708          }
   1709          #endif
   1710          /*$PAGE*/
   1711          /*
   1712          *********************************************************************************************************
   1713          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1714          *
   1715          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1716          *              (excluding the NUL character).
   1717          *
   1718          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1719          *
   1720          * Returns    : The size of the string (excluding the NUL terminating character)
   1721          *
   1722          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1723          *              2) The string to check must be less than 255 characters long.
   1724          *********************************************************************************************************
   1725          */
   1726          
   1727          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1728          INT8U  OS_StrLen (INT8U *psrc)
   1729          {
   \                     OS_StrLen:
   \   00000000   0146               MOV      R1,R0
   1730              INT8U  len;
   1731          
   1732          
   1733              len = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   02E0               B.N      ??OS_StrLen_0
   1734              while (*psrc != OS_ASCII_NUL) {
   1735                  psrc++;
   \                     ??OS_StrLen_1:
   \   00000006   491C               ADDS     R1,R1,#+1
   1736                  len++;
   \   00000008   401C               ADDS     R0,R0,#+1
   \   0000000A   C0B2               UXTB     R0,R0
   1737              }
   \                     ??OS_StrLen_0:
   \   0000000C   0A78               LDRB     R2,[R1, #+0]
   \   0000000E   002A               CMP      R2,#+0
   \   00000010   F9D1               BNE.N    ??OS_StrLen_1
   1738              return (len);
   \   00000012   7047               BX       LR               ;; return
   1739          }
   1740          #endif
   1741          /*$PAGE*/
   1742          /*
   1743          *********************************************************************************************************
   1744          *                                              IDLE TASK
   1745          *
   1746          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1747          *              executes because they are ALL waiting for event(s) to occur.
   1748          *
   1749          * Arguments  : none
   1750          *
   1751          * Returns    : none
   1752          *
   1753          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1754          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1755          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1756          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1757          *                 interrupts.
   1758          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1759          *                 power.
   1760          *********************************************************************************************************
   1761          */
   1762          

   \                                 In section .text, align 2, keep-with-next
   1763          void  OS_TaskIdle (void *p_arg)
   1764          {
   \                     OS_TaskIdle:
   \   00000000   80B5               PUSH     {R7,LR}
   1765          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1766              OS_CPU_SR  cpu_sr = 0;
   1767          #endif
   1768          
   1769          
   1770          
   1771              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   1772              for (;;) {
   1773                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0:
   \   00000002   ........           BL       OS_CPU_SR_Save
   1774                  OSIdleCtr++;
   \   00000006   ....               LDR.N    R1,??DataTable28  ;; OSCPUUsage
   \   00000008   CA69               LDR      R2,[R1, #+28]
   \   0000000A   521C               ADDS     R2,R2,#+1
   \   0000000C   CA61               STR      R2,[R1, #+28]
   1775                  OS_EXIT_CRITICAL();
   \   0000000E   ........           BL       OS_CPU_SR_Restore
   1776                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   00000012   ........           BL       OSTaskIdleHook
   \   00000016   F4E7               B.N      ??OS_TaskIdle_0
   1777              }
   1778          }
   1779          /*$PAGE*/
   1780          /*
   1781          *********************************************************************************************************
   1782          *                                            STATISTICS TASK
   1783          *
   1784          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1785          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1786          *              CPU usage is determined by:
   1787          *
   1788          *                                          OSIdleCtr
   1789          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1790          *                                         OSIdleCtrMax
   1791          *
   1792          * Arguments  : parg     this pointer is not used at this time.
   1793          *
   1794          * Returns    : none
   1795          *
   1796          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1797          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1798          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1799          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1800          *                 maximum value for the idle counter.
   1801          *********************************************************************************************************
   1802          */
   1803          
   1804          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1805          void  OS_TaskStat (void *p_arg)
   1806          {
   \                     OS_TaskStat:
   \   00000000   10B5               PUSH     {R4,LR}
   1807          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1808              OS_CPU_SR  cpu_sr = 0;
   1809          #endif
   1810          
   1811          
   1812          
   1813              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   \   00000002   ....               LDR.N    R4,??DataTable28  ;; OSCPUUsage
   \   00000004   02E0               B.N      ??OS_TaskStat_0
   1814              while (OSStatRdy == OS_FALSE) {
   1815                  OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
   \                     ??OS_TaskStat_1:
   \   00000006   C820               MOVS     R0,#+200
   \   00000008   ........           BL       OSTimeDly
   1816              }
   \                     ??OS_TaskStat_0:
   \   0000000C   6078               LDRB     R0,[R4, #+1]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   F9D0               BEQ.N    ??OS_TaskStat_1
   1817              OSIdleCtrMax /= 100L;
   \   00000012   6069               LDR      R0,[R4, #+20]
   \   00000014   6421               MOVS     R1,#+100
   \   00000016   B0FBF1F0           UDIV     R0,R0,R1
   \   0000001A   6061               STR      R0,[R4, #+20]
   1818              if (OSIdleCtrMax == 0L) {
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   03D1               BNE.N    ??OS_TaskStat_2
   1819                  OSCPUUsage = 0;
   \   00000020   2070               STRB     R0,[R4, #+0]
   1820                  (void)OSTaskSuspend(OS_PRIO_SELF);
   \   00000022   FF20               MOVS     R0,#+255
   \   00000024   ........           BL       OSTaskSuspend
   1821              }
   1822              for (;;) {
   1823                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskStat_2:
   \   00000028   ........           BL       OS_CPU_SR_Save
   1824                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   \   0000002C   E169               LDR      R1,[R4, #+28]
   \   0000002E   A161               STR      R1,[R4, #+24]
   1825                  OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   E161               STR      R1,[R4, #+28]
   1826                  OS_EXIT_CRITICAL();
   \   00000034   ........           BL       OS_CPU_SR_Restore
   1827                  OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
   \   00000038   A069               LDR      R0,[R4, #+24]
   \   0000003A   6169               LDR      R1,[R4, #+20]
   \   0000003C   B0FBF1F0           UDIV     R0,R0,R1
   \   00000040   C0F16400           RSB      R0,R0,#+100
   \   00000044   2070               STRB     R0,[R4, #+0]
   1828                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   \   00000046   ........           BL       OSTaskStatHook
   1829          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
   1830                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   \   0000004A   ........           BL       OS_TaskStatStkChk
   1831          #endif
   1832                  OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
   \   0000004E   6420               MOVS     R0,#+100
   \   00000050   ........           BL       OSTimeDly
   \   00000054   E8E7               B.N      ??OS_TaskStat_2
   1833              }
   1834          }
   1835          #endif
   1836          /*$PAGE*/
   1837          /*
   1838          *********************************************************************************************************
   1839          *                                      CHECK ALL TASK STACKS
   1840          *
   1841          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1842          *
   1843          * Arguments  : none
   1844          *
   1845          * Returns    : none
   1846          *********************************************************************************************************
   1847          */
   1848          
   1849          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1850          void  OS_TaskStatStkChk (void)
   1851          {
   \                     OS_TaskStatStkChk:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
   1852              OS_TCB      *ptcb;
   1853              OS_STK_DATA  stk_data;
   1854              INT8U        err;
   1855              INT8U        prio;
   1856          
   1857          
   1858              for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   15E0               B.N      ??OS_TaskStatStkChk_0
   1859                  err = OSTaskStkChk(prio, &stk_data);
   \                     ??OS_TaskStatStkChk_1:
   \   00000006   00A9               ADD      R1,SP,#+0
   \   00000008   ........           BL       OSTaskStkChk
   1860                  if (err == OS_ERR_NONE) {
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   0ED1               BNE.N    ??OS_TaskStatStkChk_2
   1861                      ptcb = OSTCBPrioTbl[prio];
   \   00000010   2046               MOV      R0,R4
   \   00000012   ....               LDR.N    R1,??DataTable29  ;; OSTCBPrioTbl
   \   00000014   51F82000           LDR      R0,[R1, R0, LSL #+2]
   1862                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   08D0               BEQ.N    ??OS_TaskStatStkChk_2
   1863                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   \   0000001C   0128               CMP      R0,#+1
   \   0000001E   06D0               BEQ.N    ??OS_TaskStatStkChk_2
   1864          #if OS_TASK_PROFILE_EN > 0
   1865                              #if OS_STK_GROWTH == 1
   1866                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   \   00000020   C168               LDR      R1,[R0, #+12]
   \   00000022   8268               LDR      R2,[R0, #+8]
   \   00000024   02EB8101           ADD      R1,R2,R1, LSL #+2
   \   00000028   4164               STR      R1,[R0, #+68]
   1867                              #else
   1868                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1869                              #endif
   1870                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   \   0000002A   0199               LDR      R1,[SP, #+4]
   \   0000002C   8164               STR      R1,[R0, #+72]
   1871          #endif
   1872                          }
   1873                      }
   1874                  }
   1875              }
   \                     ??OS_TaskStatStkChk_2:
   \   0000002E   641C               ADDS     R4,R4,#+1
   \   00000030   E4B2               UXTB     R4,R4
   \                     ??OS_TaskStatStkChk_0:
   \   00000032   2046               MOV      R0,R4
   \   00000034   2028               CMP      R0,#+32
   \   00000036   E6D3               BCC.N    ??OS_TaskStatStkChk_1
   1876          }
   \   00000038   13BD               POP      {R0,R1,R4,PC}    ;; return
   1877          #endif
   1878          /*$PAGE*/
   1879          /*
   1880          *********************************************************************************************************
   1881          *                                            INITIALIZE TCB
   1882          *
   1883          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1884          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1885          *
   1886          * Arguments  : prio          is the priority of the task being created
   1887          *
   1888          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1889          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1890          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1891          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1892          *                            specific.
   1893          *
   1894          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1895          *                            'OSTaskCreate()'.
   1896          *
   1897          *              id            is the task's ID (0..65535)
   1898          *
   1899          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1900          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1901          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1902          *                            units are established by the #define constant OS_STK which is CPU
   1903          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1904          *
   1905          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1906          *                            control block.  This allows you to store the contents of floating-point
   1907          *                            registers, MMU registers or anything else you could find useful during a
   1908          *                            context switch.  You can even assign a name to each task and store this name
   1909          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1910          *
   1911          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1912          *                            0 if called from 'OSTaskCreate()'.
   1913          *
   1914          * Returns    : OS_ERR_NONE         if the call was successful
   1915          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1916          *                                  be created.
   1917          *
   1918          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1919          *********************************************************************************************************
   1920          */
   1921          

   \                                 In section .text, align 2, keep-with-next
   1922          INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
   1923          {
   \                     OS_TCBInit:
   \   00000000   2DE9F44F           PUSH     {R2,R4-R11,LR}
   \   00000004   0546               MOV      R5,R0
   \   00000006   8A46               MOV      R10,R1
   \   00000008   9B46               MOV      R11,R3
   \   0000000A   0A9E               LDR      R6,[SP, #+40]
   \   0000000C   0B9F               LDR      R7,[SP, #+44]
   \   0000000E   0C9C               LDR      R4,[SP, #+48]
   1924              OS_TCB    *ptcb;
   1925          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
   1926              OS_CPU_SR  cpu_sr = 0;
   1927          #endif
   1928          
   1929          
   1930          
   1931              OS_ENTER_CRITICAL();
   \   00000010   ........           BL       OS_CPU_SR_Save
   1932              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   00000014   ........           LDR.W    R8,??DataTable28  ;; OSCPUUsage
   \   00000018   D8F82490           LDR      R9,[R8, #+36]
   1933              if (ptcb != (OS_TCB *)0) {
   \   0000001C   B9F1000F           CMP      R9,#+0
   \   00000020   00F08380           BEQ.W    ??OS_TCBInit_0
   1934                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \   00000024   D9F81410           LDR      R1,[R9, #+20]
   \   00000028   C8F82410           STR      R1,[R8, #+36]
   1935                  OS_EXIT_CRITICAL();
   \   0000002C   ........           BL       OS_CPU_SR_Restore
   1936                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \   00000030   C9F800A0           STR      R10,[R9, #+0]
   1937                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   \   00000034   09F1300A           ADD      R10,R9,#+48
   \   00000038   8AF80250           STRB     R5,[R10, #+2]
   1938                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   89F83000           STRB     R0,[R9, #+48]
   1939                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \   00000042   8AF80100           STRB     R0,[R10, #+1]
   1940                  ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
   \   00000046   A9F82E00           STRH     R0,[R9, #+46]
   1941          
   1942          #if OS_TASK_CREATE_EXT_EN > 0
   1943                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   \   0000004A   C9F80470           STR      R7,[R9, #+4]
   1944                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   \   0000004E   C9F80C60           STR      R6,[R9, #+12]
   1945                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   \   00000052   0098               LDR      R0,[SP, #+0]
   \   00000054   C9F80800           STR      R0,[R9, #+8]
   1946                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   \   00000058   A9F81040           STRH     R4,[R9, #+16]
   1947                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   \   0000005C   A9F812B0           STRH     R11,[R9, #+18]
   1948          #else
   1949                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1950                  stk_size                 = stk_size;
   1951                  pbos                     = pbos;
   1952                  opt                      = opt;
   1953                  id                       = id;
   1954          #endif
   1955          
   1956          #if OS_TASK_DEL_EN > 0
   1957                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   8AF80700           STRB     R0,[R10, #+7]
   1958          #endif
   1959          
   1960          #if OS_LOWEST_PRIO <= 63
   1961                  ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
   \   00000066   E808               LSRS     R0,R5,#+3
   \   00000068   8AF80400           STRB     R0,[R10, #+4]
   1962                  ptcb->OSTCBX             = (INT8U)(prio & 0x07);
   \   0000006C   05F00700           AND      R0,R5,#0x7
   \   00000070   8AF80300           STRB     R0,[R10, #+3]
   1963                  ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
   \   00000074   0120               MOVS     R0,#+1
   \   00000076   9AF90410           LDRSB    R1,[R10, #+4]
   \   0000007A   8840               LSLS     R0,R0,R1
   \   0000007C   8AF80600           STRB     R0,[R10, #+6]
   1964                  ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
   \   00000080   0120               MOVS     R0,#+1
   \   00000082   9AF90310           LDRSB    R1,[R10, #+3]
   \   00000086   8840               LSLS     R0,R0,R1
   \   00000088   8AF80500           STRB     R0,[R10, #+5]
   1965          #else
   1966                  ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
   1967                  ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
   1968                  ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
   1969                  ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
   1970          #endif
   1971          
   1972          #if (OS_EVENT_EN)
   1973                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   C9F81C00           STR      R0,[R9, #+28]
   1974          #if (OS_EVENT_MULTI_EN > 0)
   1975                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   \   00000092   C9F82000           STR      R0,[R9, #+32]
   1976          #endif
   1977          #endif
   1978          
   1979          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
   1980                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   00000096   C9F82800           STR      R0,[R9, #+40]
   1981          #endif
   1982          
   1983          #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
   1984                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   0000009A   C9F82400           STR      R0,[R9, #+36]
   1985          #endif
   1986          
   1987          #if OS_TASK_PROFILE_EN > 0
   1988                  ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
   \   0000009E   CAF80800           STR      R0,[R10, #+8]
   1989                  ptcb->OSTCBCyclesStart = 0L;
   \   000000A2   CAF81000           STR      R0,[R10, #+16]
   1990                  ptcb->OSTCBCyclesTot   = 0L;
   \   000000A6   CAF80C00           STR      R0,[R10, #+12]
   1991                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   000000AA   CAF81400           STR      R0,[R10, #+20]
   1992                  ptcb->OSTCBStkUsed     = 0L;
   \   000000AE   CAF81800           STR      R0,[R10, #+24]
   1993          #endif
   1994          
   1995          #if OS_TASK_NAME_SIZE > 1
   1996                  ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
   \   000000B2   3F20               MOVS     R0,#+63
   \   000000B4   8AF81C00           STRB     R0,[R10, #+28]
   1997                  ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   000000B8   0020               MOVS     R0,#+0
   \   000000BA   8AF81D00           STRB     R0,[R10, #+29]
   1998          #endif
   1999          
   2000                  OSTCBInitHook(ptcb);
   \   000000BE   4846               MOV      R0,R9
   \   000000C0   ........           BL       OSTCBInitHook
   2001          
   2002                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   000000C4   4846               MOV      R0,R9
   \   000000C6   ........           BL       OSTaskCreateHook
   2003          
   2004                  OS_ENTER_CRITICAL();
   \   000000CA   ........           BL       OS_CPU_SR_Save
   2005                  OSTCBPrioTbl[prio] = ptcb;
   \   000000CE   ....               LDR.N    R1,??DataTable29  ;; OSTCBPrioTbl
   \   000000D0   41F82590           STR      R9,[R1, R5, LSL #+2]
   2006                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   000000D4   D8F82C10           LDR      R1,[R8, #+44]
   \   000000D8   C9F81410           STR      R1,[R9, #+20]
   2007                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   000000DC   0021               MOVS     R1,#+0
   \   000000DE   C9F81810           STR      R1,[R9, #+24]
   2008                  if (OSTCBList != (OS_TCB *)0) {
   \   000000E2   D8F82C10           LDR      R1,[R8, #+44]
   \   000000E6   0029               CMP      R1,#+0
   \   000000E8   01D0               BEQ.N    ??OS_TCBInit_1
   2009                      OSTCBList->OSTCBPrev = ptcb;
   \   000000EA   C1F81890           STR      R9,[R1, #+24]
   2010                  }
   2011                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_1:
   \   000000EE   C8F82C90           STR      R9,[R8, #+44]
   2012                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   000000F2   98F80610           LDRB     R1,[R8, #+6]
   \   000000F6   9AF80620           LDRB     R2,[R10, #+6]
   \   000000FA   1143               ORRS     R1,R2,R1
   \   000000FC   88F80610           STRB     R1,[R8, #+6]
   2013                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000100   9AF80410           LDRB     R1,[R10, #+4]
   \   00000104   4144               ADD      R1,R1,R8
   \   00000106   097B               LDRB     R1,[R1, #+12]
   \   00000108   9AF80520           LDRB     R2,[R10, #+5]
   \   0000010C   1143               ORRS     R1,R2,R1
   \   0000010E   9AF80420           LDRB     R2,[R10, #+4]
   \   00000112   4244               ADD      R2,R2,R8
   \   00000114   1173               STRB     R1,[R2, #+12]
   2014                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   00000116   98F80810           LDRB     R1,[R8, #+8]
   \   0000011A   491C               ADDS     R1,R1,#+1
   \   0000011C   88F80810           STRB     R1,[R8, #+8]
   2015                  OS_EXIT_CRITICAL();
   \   00000120   ........           BL       OS_CPU_SR_Restore
   2016                  return (OS_ERR_NONE);
   \   00000124   0020               MOVS     R0,#+0
   \   00000126   BDE8F28F           POP      {R1,R4-R11,PC}
   2017              }
   2018              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0:
   \   0000012A   ........           BL       OS_CPU_SR_Restore
   2019              return (OS_ERR_TASK_NO_MORE_TCB);
   \   0000012E   4220               MOVS     R0,#+66
   \   00000130   BDE8F28F           POP      {R1,R4-R11,PC}   ;; return
   2020          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     OSUnMapTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   ........           DC32     OSTCBPrioTbl

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II Idle">`:
   \   00000000   75432F4F532D       DC8 "uC/OS-II Idle"
   \              49492049646C
   \              6500        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II Stat">`:
   \   00000000   75432F4F532D       DC8 "uC/OS-II Stat"
   \              494920537461
   \              7400        
   \   0000000E   0000               DC8 0, 0

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     OSEventNameGet              24
     OSEventNameSet              24
     OSEventPendMulti            40
     OSInit                       8
     OSIntEnter                   0
     OSIntExit                   16
     OSSchedLock                  8
     OSSchedUnlock                8
     OSStart                      8
     OSStatInit                   8
     OSTimeTick                  16
     OSVersion                    0
     OS_Dummy                     0
     OS_EventTaskRdy             24
     OS_EventTaskRemove           8
     OS_EventTaskRemoveMulti     16
     OS_EventTaskWait             8
     OS_EventTaskWaitMulti        8
     OS_EventWaitListInit         0
     OS_InitEventList             8
     OS_InitMisc                  0
     OS_InitRdyList               0
     OS_InitTCBList              16
     OS_InitTaskIdle             32
     OS_InitTaskStat             32
     OS_MemClr                    0
     OS_MemCopy                   0
     OS_Sched                    16
     OS_SchedNew                  0
     OS_StrCopy                   0
     OS_StrLen                    0
     OS_TCBInit                  40
     OS_TaskIdle                  8
     OS_TaskStat                  8
     OS_TaskStatStkChk           16


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     OSCPUUsage                  1708
     OSStatRdy
     OSIntNesting
     OSLockNesting
     OSPrioCur
     OSPrioHighRdy
     OSRdyGrp
     OSRunning
     OSTaskCtr
     OSTickStepState
     OSRdyTbl
     OSCtxSwCtr
     OSIdleCtrMax
     OSIdleCtrRun
     OSIdleCtr
     OSTCBCur
     OSTCBFreeList
     OSTCBHighRdy
     OSTCBList
     OSTime
     OSTCBTbl
     OSEventFreeList              324
     OSEventTbl
     OSFlagTbl                    140
     OSFlagFreeList                 4
     OSTaskStatStk                512
     OSTaskIdleStk                512
     OSTCBPrioTbl                 128
     OSMemFreeList                  4
     OSMemTbl                     180
     OSQFreeList                    4
     OSQTbl                        96
     OSTmrFree                      2
     OSTmrUsed                      2
     OSTmrTime                      4
     OSTmrSem                       4
     OSTmrSemSignal                 4
     OSTmrTbl                     832
     OSTmrFreeList                  4
     OSTmrTaskStk                 512
     OSTmrWheelTbl                 64
     OSUnMapTbl                   256
     OSEventNameGet               104
     OSEventNameSet               110
     OSEventPendMulti             624
     OSInit                        58
     OSIntEnter                    22
     OSIntExit                     82
     OSSchedLock                   38
     OSSchedUnlock                 70
     OSStart                       38
     OSStatInit                    50
     OSTimeTick                   178
     OSVersion                      6
     OS_Dummy                       2
     OS_EventTaskRdy              118
     OS_EventTaskWait              84
     OS_EventTaskWaitMulti         98
     OS_EventTaskRemove            40
     OS_EventTaskRemoveMulti       56
     OS_EventWaitListInit          26
     OS_InitEventList              84
     OS_InitMisc                   28
     OS_InitRdyList                44
     OS_InitTaskIdle               64
     OS_InitTaskStat               64
     OS_InitTCBList                86
     OS_MemClr                     18
     OS_MemCopy                    20
     OS_Sched                      64
     OS_SchedNew                   24
     OS_StrCopy                    30
     OS_StrLen                     20
     OS_TaskIdle                   24
     OS_TaskStat                   86
     OS_TaskStatStkChk             58
     OS_TCBInit                   308
     ??DataTable24                  4
     ??DataTable28                  4
     ??DataTable29                  4
     ?<Constant "uC/OS-II Idle">   16
     ?<Constant "uC/OS-II Stat">   16

 
 5 040 bytes in section .bss
   288 bytes in section .rodata
 2 838 bytes in section .text
 
 2 838 bytes of CODE  memory
   288 bytes of CONST memory
 5 040 bytes of DATA  memory

Errors: none
Warnings: none
