###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     28/Dec/2014  20:59:03 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_q.c                                    #
#    Command line =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    uCOS-II\Source\os_q.c -lCN C:\Users\Administrator\Deskto #
#                    p\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS #
#                    -Probe-LCD\Flash\List\ -o C:\Users\Administrator\Desktop #
#                    \uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS- #
#                    Probe-LCD\Flash\Obj\ --no_unroll --no_inline --no_tbaa   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "F:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\S #
#                    oftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\ -I      #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\BSP\ -I       #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\C #
#                    PU\ST\STM32\inc\ -I C:\Users\Administrator\Desktop\uCOS- #
#                    II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe- #
#                    LCD\..\..\..\..\..\uC-CPU\ -I                            #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-CPU\ARM-Cortex-M3\IAR\ -I                              #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-LCD\Source\ -I C:\Users\Administrator\Desktop\uCOS-II\ #
#                    Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD #
#                    \..\..\..\..\..\uC-LIB\ -I C:\Users\Administrator\Deskto #
#                    p\uCOS-II\Micrium\Software\EvalBoards\ST\STM32-SK\IAR\OS #
#                    -Probe-LCD\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Ge #
#                    neric\IAR\ -I C:\Users\Administrator\Desktop\uCOS-II\Mic #
#                    rium\Software\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\.. #
#                    \..\..\..\..\uCOS-II\Source\ -I                          #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM #
#                    32\ -I C:\Users\Administrator\Desktop\uCOS-II\Micrium\So #
#                    ftware\EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\ #
#                    ..\..\uC-Probe\Target\Communication\Generic\Source\ -I   #
#                    C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\..\..\..\..\..\u #
#                    C-Probe\Target\Plugins\uCOS-II\ -I "F:\Program Files     #
#                    (x86)\IAR Systems\Embedded Workbench 5.4\arm\INC\" -Om   #
#    List file    =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\List\os_q. #
#                    lst                                                      #
#    Object file  =  C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\ #
#                    EvalBoards\ST\STM32-SK\IAR\OS-Probe-LCD\Flash\Obj\os_q.o #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\uCOS-II\Micrium\Software\uCOS-II\Source\os_q.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                        MESSAGE QUEUE MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_Q.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
     29          /*
     30          *********************************************************************************************************
     31          *                                      ACCEPT MESSAGE FROM QUEUE
     32          *
     33          * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
     34          *              OSQAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          *              perr          is a pointer to where an error message will be deposited.  Possible error
     39          *                            messages are:
     40          *
     41          *                            OS_ERR_NONE         The call was successful and your task received a
     42          *                                                message.
     43          *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
     44          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
     45          *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
     46          *
     47          * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
     48          *                            from the so the next time OSQAccept() is called, the queue will contain
     49          *                            one less entry.
     50          *              == (void *)0  if you received a NULL pointer message
     51          *                            if the queue is empty or,
     52          *                            if 'pevent' is a NULL pointer or,
     53          *                            if you passed an invalid event type
     54          *
     55          * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
     56          *              'perr' has been added to the API to tell you about the outcome of the call.
     57          *********************************************************************************************************
     58          */
     59          
     60          #if OS_Q_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     61          void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
     62          {
   \                     OSQAccept:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C00               MOVS     R4,R1
     63              void      *pmsg;
     64              OS_Q      *pq;
     65          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
     66              OS_CPU_SR  cpu_sr = 0;
     67          #endif
     68          
     69          
     70          
     71          #if OS_ARG_CHK_EN > 0
     72              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
   \   00000006   01D1               BNE.N    ??OSQAccept_0
     73                  return ((void *)0);
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   32BD               POP      {R1,R4,R5,PC}
     74              }
     75              if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
   \                     ??OSQAccept_0:
   \   0000000C   002D               CMP      R5,#+0
   \   0000000E   03D1               BNE.N    ??OSQAccept_1
     76                  *perr = OS_ERR_PEVENT_NULL;
   \   00000010   0420               MOVS     R0,#+4
   \   00000012   2070               STRB     R0,[R4, #+0]
     77                  return ((void *)0);
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   32BD               POP      {R1,R4,R5,PC}
     78              }
     79          #endif
     80              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
   \                     ??OSQAccept_1:
   \   00000018   2878               LDRB     R0,[R5, #+0]
   \   0000001A   0228               CMP      R0,#+2
   \   0000001C   03D0               BEQ.N    ??OSQAccept_2
     81                  *perr = OS_ERR_EVENT_TYPE;
   \   0000001E   0120               MOVS     R0,#+1
   \   00000020   2070               STRB     R0,[R4, #+0]
     82                  return ((void *)0);
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   32BD               POP      {R1,R4,R5,PC}
     83              }
     84              OS_ENTER_CRITICAL();
   \                     ??OSQAccept_2:
   \   00000026   ........           BL       OS_CPU_SR_Save
     85              pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
   \   0000002A   6968               LDR      R1,[R5, #+4]
     86              if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
   \   0000002C   CA8A               LDRH     R2,[R1, #+22]
   \   0000002E   002A               CMP      R2,#+0
   \   00000030   0FD0               BEQ.N    ??OSQAccept_3
     87                  pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
   \   00000032   0A69               LDR      R2,[R1, #+16]
   \   00000034   131D               ADDS     R3,R2,#+4
   \   00000036   0B61               STR      R3,[R1, #+16]
   \   00000038   1568               LDR      R5,[R2, #+0]
     88                  pq->OSQEntries--;                        /* Update the number of entries in the queue          */
   \   0000003A   CA8A               LDRH     R2,[R1, #+22]
   \   0000003C   521E               SUBS     R2,R2,#+1
   \   0000003E   CA82               STRH     R2,[R1, #+22]
     89                  if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
   \   00000040   0A69               LDR      R2,[R1, #+16]
   \   00000042   8B68               LDR      R3,[R1, #+8]
   \   00000044   9A42               CMP      R2,R3
   \   00000046   01D1               BNE.N    ??OSQAccept_4
     90                      pq->OSQOut = pq->OSQStart;
   \   00000048   4A68               LDR      R2,[R1, #+4]
   \   0000004A   0A61               STR      R2,[R1, #+16]
     91                  }
     92                  *perr = OS_ERR_NONE;
   \                     ??OSQAccept_4:
   \   0000004C   0021               MOVS     R1,#+0
   \   0000004E   2170               STRB     R1,[R4, #+0]
   \   00000050   02E0               B.N      ??OSQAccept_5
     93              } else {
     94                  *perr = OS_ERR_Q_EMPTY;
   \                     ??OSQAccept_3:
   \   00000052   1F21               MOVS     R1,#+31
   \   00000054   2170               STRB     R1,[R4, #+0]
     95                  pmsg  = (void *)0;                       /* Queue is empty                                     */
   \   00000056   0025               MOVS     R5,#+0
     96              }
     97              OS_EXIT_CRITICAL();
   \                     ??OSQAccept_5:
   \   00000058   ........           BL       OS_CPU_SR_Restore
     98              return (pmsg);                               /* Return message received (or NULL)                  */
   \   0000005C   2846               MOV      R0,R5
   \   0000005E   32BD               POP      {R1,R4,R5,PC}    ;; return
     99          }
    100          #endif
    101          /*$PAGE*/
    102          /*
    103          *********************************************************************************************************
    104          *                                        CREATE A MESSAGE QUEUE
    105          *
    106          * Description: This function creates a message queue if free event control blocks are available.
    107          *
    108          * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
    109          *                            storage area MUST be declared as an array of pointers to 'void' as follows
    110          *
    111          *                            void *MessageStorage[size]
    112          *
    113          *              size          is the number of elements in the storage area
    114          *
    115          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
    116          *                                created queue
    117          *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
    118          *********************************************************************************************************
    119          */
    120          

   \                                 In section .text, align 2, keep-with-next
    121          OS_EVENT  *OSQCreate (void **start, INT16U size)
    122          {
   \                     OSQCreate:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0546               MOV      R5,R0
   \   00000006   0C46               MOV      R4,R1
    123              OS_EVENT  *pevent;
    124              OS_Q      *pq;
    125          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    126              OS_CPU_SR  cpu_sr = 0;
    127          #endif
    128          
    129          
    130          
    131              if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
   \   00000008   ....               LDR.N    R0,??DataTable8  ;; OSIntNesting
   \   0000000A   0078               LDRB     R0,[R0, #+0]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   02D0               BEQ.N    ??OSQCreate_0
    132                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   BDE8F081           POP      {R4-R8,PC}
    133              }
    134              OS_ENTER_CRITICAL();
   \                     ??OSQCreate_0:
   \   00000016   ........           BL       OS_CPU_SR_Save
    135              pevent = OSEventFreeList;                    /* Get next free event control block                  */
   \   0000001A   ....               LDR.N    R6,??DataTable7  ;; OSEventFreeList
   \   0000001C   3168               LDR      R1,[R6, #+0]
   \   0000001E   0F00               MOVS     R7,R1
    136              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   00000020   01D0               BEQ.N    ??OSQCreate_1
    137                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   00000022   4968               LDR      R1,[R1, #+4]
   \   00000024   3160               STR      R1,[R6, #+0]
    138              }
    139              OS_EXIT_CRITICAL();
   \                     ??OSQCreate_1:
   \   00000026   ........           BL       OS_CPU_SR_Restore
    140              if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
   \   0000002A   002F               CMP      R7,#+0
   \   0000002C   2FD0               BEQ.N    ??OSQCreate_2
    141                  OS_ENTER_CRITICAL();
   \   0000002E   ........           BL       OS_CPU_SR_Save
    142                  pq = OSQFreeList;                        /* Get a free queue control block                     */
   \   00000032   ........           LDR.W    R1,??DataTable9  ;; OSQFreeList
   \   00000036   0A68               LDR      R2,[R1, #+0]
   \   00000038   9046               MOV      R8,R2
    143                  if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
   \   0000003A   B8F1000F           CMP      R8,#+0
   \   0000003E   20D0               BEQ.N    ??OSQCreate_3
    144                      OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
   \   00000040   1268               LDR      R2,[R2, #+0]
   \   00000042   0A60               STR      R2,[R1, #+0]
    145                      OS_EXIT_CRITICAL();
   \   00000044   ........           BL       OS_CPU_SR_Restore
    146                      pq->OSQStart           = start;               /*      Initialize the queue                 */
   \   00000048   C8F80450           STR      R5,[R8, #+4]
    147                      pq->OSQEnd             = &start[size];
   \   0000004C   05EB8400           ADD      R0,R5,R4, LSL #+2
   \   00000050   C8F80800           STR      R0,[R8, #+8]
    148                      pq->OSQIn              = start;
   \   00000054   C8F80C50           STR      R5,[R8, #+12]
    149                      pq->OSQOut             = start;
   \   00000058   C8F81050           STR      R5,[R8, #+16]
    150                      pq->OSQSize            = size;
   \   0000005C   A8F81440           STRH     R4,[R8, #+20]
    151                      pq->OSQEntries         = 0;
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   A8F81600           STRH     R0,[R8, #+22]
    152                      pevent->OSEventType    = OS_EVENT_TYPE_Q;
   \   00000066   0220               MOVS     R0,#+2
   \   00000068   3870               STRB     R0,[R7, #+0]
    153                      pevent->OSEventCnt     = 0;
   \   0000006A   0020               MOVS     R0,#+0
   \   0000006C   3881               STRH     R0,[R7, #+8]
    154                      pevent->OSEventPtr     = pq;
   \   0000006E   C7F80480           STR      R8,[R7, #+4]
    155          #if OS_EVENT_NAME_SIZE > 1
    156                      pevent->OSEventName[0] = '?';                  /* Unknown name                             */
   \   00000072   3F20               MOVS     R0,#+63
   \   00000074   F873               STRB     R0,[R7, #+15]
    157                      pevent->OSEventName[1] = OS_ASCII_NUL;
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   3874               STRB     R0,[R7, #+16]
    158          #endif
    159                      OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
   \   0000007A   3846               MOV      R0,R7
   \   0000007C   ........           BL       OS_EventWaitListInit
   \   00000080   05E0               B.N      ??OSQCreate_2
    160                  } else {
    161                      pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
   \                     ??OSQCreate_3:
   \   00000082   3168               LDR      R1,[R6, #+0]
   \   00000084   7960               STR      R1,[R7, #+4]
    162                      OSEventFreeList    = pevent;
   \   00000086   3760               STR      R7,[R6, #+0]
    163                      OS_EXIT_CRITICAL();
   \   00000088   ........           BL       OS_CPU_SR_Restore
    164                      pevent = (OS_EVENT *)0;
   \   0000008C   0027               MOVS     R7,#+0
    165                  }
    166              }
    167              return (pevent);
   \                     ??OSQCreate_2:
   \   0000008E   3846               MOV      R0,R7
   \   00000090   BDE8F081           POP      {R4-R8,PC}       ;; return
    168          }
    169          /*$PAGE*/
    170          /*
    171          *********************************************************************************************************
    172          *                                        DELETE A MESSAGE QUEUE
    173          *
    174          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    175          *
    176          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    177          *                            queue.
    178          *
    179          *              opt           determines delete options as follows:
    180          *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
    181          *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
    182          *                                                    In this case, all the tasks pending will be readied.
    183          *
    184          *              perr          is a pointer to an error code that can contain one of the following values:
    185          *                            OS_ERR_NONE             The call was successful and the queue was deleted
    186          *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
    187          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    188          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
    189          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
    190          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    191          *
    192          * Returns    : pevent        upon error
    193          *              (OS_EVENT *)0 if the queue was successfully deleted.
    194          *
    195          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    196          *                 the queue MUST check the return code of OSQPend().
    197          *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
    198          *                 they check 'pevent' to see that it's a NULL pointer.
    199          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    200          *                 time is directly proportional to the number of tasks waiting on the queue.
    201          *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
    202          *                 applications where the queue is used for mutual exclusion because the resource(s)
    203          *                 will no longer be guarded by the queue.
    204          *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
    205          *                 type call) then your application MUST release the memory storage by call the counterpart
    206          *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
    207          *                 then, the storage can be reused.
    208          *********************************************************************************************************
    209          */
    210          
    211          #if OS_Q_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    212          OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    213          {
   \                     OSQDel:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   8846               MOV      R8,R1
   \   00000008   1500               MOVS     R5,R2
    214              BOOLEAN    tasks_waiting;
    215              OS_EVENT  *pevent_return;
    216              OS_Q      *pq;
    217          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    218              OS_CPU_SR  cpu_sr = 0;
    219          #endif
    220          
    221          
    222          
    223          #if OS_ARG_CHK_EN > 0
    224              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
   \   0000000A   75D0               BEQ.N    ??OSQDel_0
    225                  return (pevent);
    226              }
    227              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
   \   0000000C   002C               CMP      R4,#+0
   \   0000000E   04D1               BNE.N    ??OSQDel_1
    228                  *perr = OS_ERR_PEVENT_NULL;
   \   00000010   0420               MOVS     R0,#+4
   \   00000012   2870               STRB     R0,[R5, #+0]
    229                  return (pevent);
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   BDE8F081           POP      {R4-R8,PC}
    230              }
    231          #endif
    232              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
   \                     ??OSQDel_1:
   \   0000001A   2078               LDRB     R0,[R4, #+0]
   \   0000001C   0228               CMP      R0,#+2
   \   0000001E   04D0               BEQ.N    ??OSQDel_2
    233                  *perr = OS_ERR_EVENT_TYPE;
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2870               STRB     R0,[R5, #+0]
    234                  return (pevent);
   \   00000024   2046               MOV      R0,R4
   \   00000026   BDE8F081           POP      {R4-R8,PC}
    235              }
    236              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \                     ??OSQDel_2:
   \   0000002A   ....               LDR.N    R0,??DataTable8  ;; OSIntNesting
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   04D0               BEQ.N    ??OSQDel_3
    237                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000032   0F20               MOVS     R0,#+15
   \   00000034   2870               STRB     R0,[R5, #+0]
    238                  return (pevent);
   \   00000036   2046               MOV      R0,R4
   \   00000038   BDE8F081           POP      {R4-R8,PC}
    239              }
    240              OS_ENTER_CRITICAL();
   \                     ??OSQDel_3:
   \   0000003C   ........           BL       OS_CPU_SR_Save
   \   00000040   0646               MOV      R6,R0
    241              if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
   \   00000042   A07A               LDRB     R0,[R4, #+10]
   \   00000044   471E               SUBS     R7,R0,#+1
   \   00000046   BF41               SBCS     R7,R7,R7
   \   00000048   FF43               MVNS     R7,R7
   \   0000004A   FF0F               LSRS     R7,R7,#+31
    242                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    243              } else {
    244                  tasks_waiting = OS_FALSE;                          /* No                                       */
    245              }
    246              switch (opt) {
   \   0000004C   B8F1000F           CMP      R8,#+0
   \   00000050   03D0               BEQ.N    ??OSQDel_4
   \   00000052   B8F1010F           CMP      R8,#+1
   \   00000056   29D0               BEQ.N    ??OSQDel_5
   \   00000058   48E0               B.N      ??OSQDel_6
    247                  case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
    248                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSQDel_4:
   \   0000005A   002F               CMP      R7,#+0
   \   0000005C   18D1               BNE.N    ??OSQDel_7
    249          #if OS_EVENT_NAME_SIZE > 1
    250                           pevent->OSEventName[0] = '?';             /* Unknown name                             */
   \   0000005E   3F20               MOVS     R0,#+63
   \   00000060   E073               STRB     R0,[R4, #+15]
    251                           pevent->OSEventName[1] = OS_ASCII_NUL;
   \   00000062   0020               MOVS     R0,#+0
   \   00000064   2074               STRB     R0,[R4, #+16]
    252          #endif
    253                           pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
   \   00000066   6068               LDR      R0,[R4, #+4]
    254                           pq->OSQPtr             = OSQFreeList;
   \   00000068   ........           LDR.W    R1,??DataTable9  ;; OSQFreeList
   \   0000006C   0A68               LDR      R2,[R1, #+0]
   \   0000006E   0260               STR      R2,[R0, #+0]
    255                           OSQFreeList            = pq;
   \   00000070   0860               STR      R0,[R1, #+0]
    256                           pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   2070               STRB     R0,[R4, #+0]
    257                           pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
   \   00000076   ....               LDR.N    R0,??DataTable7  ;; OSEventFreeList
   \   00000078   0168               LDR      R1,[R0, #+0]
   \   0000007A   6160               STR      R1,[R4, #+4]
    258                           pevent->OSEventCnt     = 0;
   \   0000007C   0021               MOVS     R1,#+0
   \   0000007E   2181               STRH     R1,[R4, #+8]
    259                           OSEventFreeList        = pevent;          /* Get next free event control block        */
   \   00000080   0460               STR      R4,[R0, #+0]
    260                           OS_EXIT_CRITICAL();
   \   00000082   3046               MOV      R0,R6
   \   00000084   ........           BL       OS_CPU_SR_Restore
    261                           *perr                  = OS_ERR_NONE;
   \   00000088   0020               MOVS     R0,#+0
   \   0000008A   2870               STRB     R0,[R5, #+0]
    262                           pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
   \   0000008C   BDE8F081           POP      {R4-R8,PC}
    263                       } else {
    264                           OS_EXIT_CRITICAL();
   \                     ??OSQDel_7:
   \   00000090   3046               MOV      R0,R6
   \   00000092   ........           BL       OS_CPU_SR_Restore
    265                           *perr                  = OS_ERR_TASK_WAITING;
   \   00000096   4920               MOVS     R0,#+73
   \   00000098   2870               STRB     R0,[R5, #+0]
    266                           pevent_return          = pevent;
   \   0000009A   2046               MOV      R0,R4
   \   0000009C   BDE8F081           POP      {R4-R8,PC}
    267                       }
    268                       break;
    269          
    270                  case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
    271                       while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
    272                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
   \                     ??OSQDel_8:
   \   000000A0   0023               MOVS     R3,#+0
   \   000000A2   0422               MOVS     R2,#+4
   \   000000A4   1946               MOV      R1,R3
   \   000000A6   2046               MOV      R0,R4
   \   000000A8   ........           BL       OS_EventTaskRdy
    273                       }
   \                     ??OSQDel_5:
   \   000000AC   A07A               LDRB     R0,[R4, #+10]
   \   000000AE   0028               CMP      R0,#+0
   \   000000B0   F6D1               BNE.N    ??OSQDel_8
    274          #if OS_EVENT_NAME_SIZE > 1
    275                       pevent->OSEventName[0] = '?';                 /* Unknown name                             */
   \   000000B2   3F20               MOVS     R0,#+63
   \   000000B4   E073               STRB     R0,[R4, #+15]
    276                       pevent->OSEventName[1] = OS_ASCII_NUL;
   \   000000B6   0020               MOVS     R0,#+0
   \   000000B8   2074               STRB     R0,[R4, #+16]
    277          #endif
    278                       pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
   \   000000BA   6068               LDR      R0,[R4, #+4]
    279                       pq->OSQPtr             = OSQFreeList;
   \   000000BC   ........           LDR.W    R1,??DataTable9  ;; OSQFreeList
   \   000000C0   0A68               LDR      R2,[R1, #+0]
   \   000000C2   0260               STR      R2,[R0, #+0]
    280                       OSQFreeList            = pq;
   \   000000C4   0860               STR      R0,[R1, #+0]
    281                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   000000C6   0020               MOVS     R0,#+0
   \   000000C8   2070               STRB     R0,[R4, #+0]
    282                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   000000CA   ....               LDR.N    R0,??DataTable7  ;; OSEventFreeList
   \   000000CC   0168               LDR      R1,[R0, #+0]
   \   000000CE   6160               STR      R1,[R4, #+4]
    283                       pevent->OSEventCnt     = 0;
   \   000000D0   0021               MOVS     R1,#+0
   \   000000D2   2181               STRH     R1,[R4, #+8]
    284                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   000000D4   0460               STR      R4,[R0, #+0]
    285                       OS_EXIT_CRITICAL();
   \   000000D6   3046               MOV      R0,R6
   \   000000D8   ........           BL       OS_CPU_SR_Restore
    286                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000DC   012F               CMP      R7,#+1
   \   000000DE   01D1               BNE.N    ??OSQDel_9
    287                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000E0   ........           BL       OS_Sched
    288                       }
    289                       *perr                  = OS_ERR_NONE;
   \                     ??OSQDel_9:
   \   000000E4   0020               MOVS     R0,#+0
   \   000000E6   2870               STRB     R0,[R5, #+0]
    290                       pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
   \   000000E8   BDE8F081           POP      {R4-R8,PC}
    291                       break;
    292          
    293                  default:
    294                       OS_EXIT_CRITICAL();
   \                     ??OSQDel_6:
   \   000000EC   3046               MOV      R0,R6
   \   000000EE   ........           BL       OS_CPU_SR_Restore
    295                       *perr                  = OS_ERR_INVALID_OPT;
   \   000000F2   0720               MOVS     R0,#+7
   \   000000F4   2870               STRB     R0,[R5, #+0]
    296                       pevent_return          = pevent;
   \   000000F6   2046               MOV      R0,R4
    297                       break;
    298              }
    299              return (pevent_return);
   \                     ??OSQDel_0:
   \   000000F8   BDE8F081           POP      {R4-R8,PC}       ;; return
    300          }
    301          #endif
    302          
    303          /*$PAGE*/
    304          /*
    305          *********************************************************************************************************
    306          *                                             FLUSH QUEUE
    307          *
    308          * Description : This function is used to flush the contents of the message queue.
    309          *
    310          * Arguments   : none
    311          *
    312          * Returns     : OS_ERR_NONE         upon success
    313          *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
    314          *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    315          *
    316          * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
    317          *               the references to what the queue entries are pointing to and thus, you could cause
    318          *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
    319          *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
    320          *********************************************************************************************************
    321          */
    322          
    323          #if OS_Q_FLUSH_EN > 0

   \                                 In section .text, align 2, keep-with-next
    324          INT8U  OSQFlush (OS_EVENT *pevent)
    325          {
   \                     OSQFlush:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    326              OS_Q      *pq;
    327          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    328              OS_CPU_SR  cpu_sr = 0;
    329          #endif
    330          
    331          
    332          
    333          #if OS_ARG_CHK_EN > 0
    334              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
   \   00000004   01D1               BNE.N    ??OSQFlush_0
    335                  return (OS_ERR_PEVENT_NULL);
   \   00000006   0420               MOVS     R0,#+4
   \   00000008   10BD               POP      {R4,PC}
    336              }
    337              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \                     ??OSQFlush_0:
   \   0000000A   2078               LDRB     R0,[R4, #+0]
   \   0000000C   0228               CMP      R0,#+2
   \   0000000E   01D0               BEQ.N    ??OSQFlush_1
    338                  return (OS_ERR_EVENT_TYPE);
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   10BD               POP      {R4,PC}
    339              }
    340          #endif
    341              OS_ENTER_CRITICAL();
   \                     ??OSQFlush_1:
   \   00000014   ........           BL       OS_CPU_SR_Save
    342              pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
   \   00000018   6168               LDR      R1,[R4, #+4]
    343              pq->OSQIn      = pq->OSQStart;
   \   0000001A   4A68               LDR      R2,[R1, #+4]
   \   0000001C   CA60               STR      R2,[R1, #+12]
    344              pq->OSQOut     = pq->OSQStart;
   \   0000001E   4A68               LDR      R2,[R1, #+4]
   \   00000020   0A61               STR      R2,[R1, #+16]
    345              pq->OSQEntries = 0;
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   CA82               STRH     R2,[R1, #+22]
    346              OS_EXIT_CRITICAL();
   \   00000026   ........           BL       OS_CPU_SR_Restore
    347              return (OS_ERR_NONE);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   10BD               POP      {R4,PC}          ;; return
    348          }
    349          #endif
    350          
    351          /*$PAGE*/
    352          /*
    353          *********************************************************************************************************
    354          *                                     PEND ON A QUEUE FOR A MESSAGE
    355          *
    356          * Description: This function waits for a message to be sent to a queue
    357          *
    358          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    359          *
    360          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    361          *                            wait for a message to arrive at the queue up to the amount of time
    362          *                            specified by this argument.  If you specify 0, however, your task will wait
    363          *                            forever at the specified queue or, until a message arrives.
    364          *
    365          *              perr          is a pointer to where an error message will be deposited.  Possible error
    366          *                            messages are:
    367          *
    368          *                            OS_ERR_NONE         The call was successful and your task received a
    369          *                                                message.
    370          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    371          *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
    372          *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
    373          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    374          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    375          *                                                would lead to a suspension.
    376          *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
    377          *
    378          * Returns    : != (void *)0  is a pointer to the message received
    379          *              == (void *)0  if you received a NULL pointer message or,
    380          *                            if no message was received or,
    381          *                            if 'pevent' is a NULL pointer or,
    382          *                            if you didn't pass a pointer to a queue.
    383          *
    384          * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
    385          *********************************************************************************************************
    386          */
    387          

   \                                 In section .text, align 4, keep-with-next
    388          void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
    389          {
   \                     OSQPend:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0646               MOV      R6,R0
   \   00000006   0D46               MOV      R5,R1
   \   00000008   1400               MOVS     R4,R2
    390              void      *pmsg;
    391              OS_Q      *pq;
    392          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    393              OS_CPU_SR  cpu_sr = 0;
    394          #endif
    395          
    396          
    397          
    398          #if OS_ARG_CHK_EN > 0
    399              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
   \   0000000A   02D1               BNE.N    ??OSQPend_0
    400                  return ((void *)0);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   BDE8F081           POP      {R4-R8,PC}
    401              }
    402              if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
   \                     ??OSQPend_0:
   \   00000012   002E               CMP      R6,#+0
   \   00000014   04D1               BNE.N    ??OSQPend_1
    403                  *perr = OS_ERR_PEVENT_NULL;
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   2070               STRB     R0,[R4, #+0]
    404                  return ((void *)0);
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   BDE8F081           POP      {R4-R8,PC}
    405              }
    406          #endif
    407              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
   \                     ??OSQPend_1:
   \   00000020   3078               LDRB     R0,[R6, #+0]
   \   00000022   0228               CMP      R0,#+2
   \   00000024   04D0               BEQ.N    ??OSQPend_2
    408                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0120               MOVS     R0,#+1
   \   00000028   2070               STRB     R0,[R4, #+0]
    409                  return ((void *)0);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   BDE8F081           POP      {R4-R8,PC}
    410              }
    411              if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
   \                     ??OSQPend_2:
   \   00000030   ....               LDR.N    R0,??DataTable8  ;; OSIntNesting
   \   00000032   0078               LDRB     R0,[R0, #+0]
   \   00000034   0028               CMP      R0,#+0
   \   00000036   04D0               BEQ.N    ??OSQPend_3
    412                  *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
   \   00000038   0220               MOVS     R0,#+2
   \   0000003A   2070               STRB     R0,[R4, #+0]
    413                  return ((void *)0);
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   BDE8F081           POP      {R4-R8,PC}
    414              }
    415              if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
   \                     ??OSQPend_3:
   \   00000042   3948               LDR.N    R0,??OSQPend_4   ;; OSLockNesting
   \   00000044   0078               LDRB     R0,[R0, #+0]
   \   00000046   0028               CMP      R0,#+0
   \   00000048   04D0               BEQ.N    ??OSQPend_5
    416                  *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
   \   0000004A   0D20               MOVS     R0,#+13
   \   0000004C   2070               STRB     R0,[R4, #+0]
    417                  return ((void *)0);
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   BDE8F081           POP      {R4-R8,PC}
    418              }
    419              OS_ENTER_CRITICAL();
   \                     ??OSQPend_5:
   \   00000054   ........           BL       OS_CPU_SR_Save
   \   00000058   0746               MOV      R7,R0
    420              pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
   \   0000005A   7068               LDR      R0,[R6, #+4]
    421              if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
   \   0000005C   C18A               LDRH     R1,[R0, #+22]
   \   0000005E   0029               CMP      R1,#+0
   \   00000060   14D0               BEQ.N    ??OSQPend_6
    422                  pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
   \   00000062   0169               LDR      R1,[R0, #+16]
   \   00000064   0A1D               ADDS     R2,R1,#+4
   \   00000066   0261               STR      R2,[R0, #+16]
   \   00000068   0D68               LDR      R5,[R1, #+0]
    423                  pq->OSQEntries--;                        /* Update the number of entries in the queue          */
   \   0000006A   C18A               LDRH     R1,[R0, #+22]
   \   0000006C   491E               SUBS     R1,R1,#+1
   \   0000006E   C182               STRH     R1,[R0, #+22]
    424                  if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
   \   00000070   0169               LDR      R1,[R0, #+16]
   \   00000072   8268               LDR      R2,[R0, #+8]
   \   00000074   9142               CMP      R1,R2
   \   00000076   01D1               BNE.N    ??OSQPend_7
    425                      pq->OSQOut = pq->OSQStart;
   \   00000078   4168               LDR      R1,[R0, #+4]
   \   0000007A   0161               STR      R1,[R0, #+16]
    426                  }
    427                  OS_EXIT_CRITICAL();
   \                     ??OSQPend_7:
   \   0000007C   3846               MOV      R0,R7
   \   0000007E   ........           BL       OS_CPU_SR_Restore
    428                  *perr = OS_ERR_NONE;
   \   00000082   0020               MOVS     R0,#+0
   \   00000084   2070               STRB     R0,[R4, #+0]
    429                  return (pmsg);                           /* Return message received                            */
   \   00000086   2846               MOV      R0,R5
   \   00000088   BDE8F081           POP      {R4-R8,PC}
    430              }
    431              OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
   \                     ??OSQPend_6:
   \   0000008C   DFF89C80           LDR.W    R8,??OSQPend_4+0x4  ;; OSTCBCur
   \   00000090   D8F80000           LDR      R0,[R8, #+0]
   \   00000094   90F83010           LDRB     R1,[R0, #+48]
   \   00000098   41F00401           ORR      R1,R1,#0x4
   \   0000009C   80F83010           STRB     R1,[R0, #+48]
    432              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   000000A0   D8F80000           LDR      R0,[R8, #+0]
   \   000000A4   0021               MOVS     R1,#+0
   \   000000A6   80F83110           STRB     R1,[R0, #+49]
    433              OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
   \   000000AA   D8F80000           LDR      R0,[R8, #+0]
   \   000000AE   C585               STRH     R5,[R0, #+46]
    434              OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
   \   000000B0   3046               MOV      R0,R6
   \   000000B2   ........           BL       OS_EventTaskWait
    435              OS_EXIT_CRITICAL();
   \   000000B6   3846               MOV      R0,R7
   \   000000B8   ........           BL       OS_CPU_SR_Restore
    436              OS_Sched();                                  /* Find next highest priority task ready to run       */
   \   000000BC   ........           BL       OS_Sched
    437              OS_ENTER_CRITICAL();
   \   000000C0   ........           BL       OS_CPU_SR_Save
   \   000000C4   0746               MOV      R7,R0
    438              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   000000C6   D8F80000           LDR      R0,[R8, #+0]
   \   000000CA   00F12401           ADD      R1,R0,#+36
   \   000000CE   497B               LDRB     R1,[R1, #+13]
   \   000000D0   0029               CMP      R1,#+0
   \   000000D2   02D0               BEQ.N    ??OSQPend_8
   \   000000D4   0229               CMP      R1,#+2
   \   000000D6   04D0               BEQ.N    ??OSQPend_9
   \   000000D8   07E0               B.N      ??OSQPend_10
    439                  case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
    440                       pmsg =  OSTCBCur->OSTCBMsg;
   \                     ??OSQPend_8:
   \   000000DA   456A               LDR      R5,[R0, #+36]
    441                      *perr =  OS_ERR_NONE;
   \   000000DC   0020               MOVS     R0,#+0
   \   000000DE   2070               STRB     R0,[R4, #+0]
   \   000000E0   09E0               B.N      ??OSQPend_11
    442                       break;
    443          
    444                  case OS_STAT_PEND_ABORT:
    445                       pmsg = (void *)0;
   \                     ??OSQPend_9:
   \   000000E2   0025               MOVS     R5,#+0
    446                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \   000000E4   0E20               MOVS     R0,#+14
   \   000000E6   2070               STRB     R0,[R4, #+0]
   \   000000E8   05E0               B.N      ??OSQPend_11
    447                       break;
    448          
    449                  case OS_STAT_PEND_TO:
    450                  default:
    451                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSQPend_10:
   \   000000EA   3146               MOV      R1,R6
   \   000000EC   ........           BL       OS_EventTaskRemove
    452                       pmsg = (void *)0;
   \   000000F0   0025               MOVS     R5,#+0
    453                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   000000F2   0A20               MOVS     R0,#+10
   \   000000F4   2070               STRB     R0,[R4, #+0]
    454                       break;
    455              }
    456              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSQPend_11:
   \   000000F6   D8F80000           LDR      R0,[R8, #+0]
   \   000000FA   0021               MOVS     R1,#+0
   \   000000FC   80F83010           STRB     R1,[R0, #+48]
    457              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   00000100   D8F80000           LDR      R0,[R8, #+0]
   \   00000104   80F83110           STRB     R1,[R0, #+49]
    458              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   00000108   D8F80000           LDR      R0,[R8, #+0]
   \   0000010C   C161               STR      R1,[R0, #+28]
    459          #if (OS_EVENT_MULTI_EN > 0)
    460              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   0000010E   D8F80000           LDR      R0,[R8, #+0]
   \   00000112   0162               STR      R1,[R0, #+32]
    461          #endif
    462              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
   \   00000114   D8F80000           LDR      R0,[R8, #+0]
   \   00000118   4162               STR      R1,[R0, #+36]
    463              OS_EXIT_CRITICAL();
   \   0000011A   3846               MOV      R0,R7
   \   0000011C   ........           BL       OS_CPU_SR_Restore
    464              return (pmsg);                                    /* Return received message                       */
   \   00000120   2846               MOV      R0,R5
   \   00000122   BDE8F081           POP      {R4-R8,PC}       ;; return
   \   00000126   00BF               Nop      
   \                     ??OSQPend_4:
   \   00000128   ........           DC32     OSLockNesting
   \   0000012C   ........           DC32     OSTCBCur
    465          }
    466          /*$PAGE*/
    467          /*
    468          *********************************************************************************************************
    469          *                                      ABORT WAITING ON A MESSAGE QUEUE
    470          *
    471          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function 
    472          *              should be used to fault-abort the wait on the queue, rather than to normally signal
    473          *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
    474          *
    475          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
    476          *
    477          *              opt           determines the type of ABORT performed:
    478          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    479          *                                                     queue
    480          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    481          *                                                     queue
    482          *
    483          *              perr          is a pointer to where an error message will be deposited.  Possible error
    484          *                            messages are:
    485          *
    486          *                            OS_ERR_NONE         No tasks were     waiting on the queue.
    487          *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
    488          *                                                and informed of the aborted wait; check return value 
    489          *                                                for the number of tasks whose wait on the queue 
    490          *                                                was aborted.
    491          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
    492          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    493          *
    494          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    495          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    496          *********************************************************************************************************
    497          */
    498          
    499          #if OS_Q_PEND_ABORT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    500          INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    501          {
   \                     OSQPendAbort:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   8846               MOV      R8,R1
   \   00000008   1500               MOVS     R5,R2
    502              INT8U      nbr_tasks;
    503          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    504              OS_CPU_SR  cpu_sr = 0;
    505          #endif
    506          
    507          
    508          
    509          #if OS_ARG_CHK_EN > 0
    510              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
   \   0000000A   02D1               BNE.N    ??OSQPendAbort_0
    511                  return (0);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   BDE8F081           POP      {R4-R8,PC}
    512              }
    513              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
   \                     ??OSQPendAbort_0:
   \   00000012   002C               CMP      R4,#+0
   \   00000014   04D1               BNE.N    ??OSQPendAbort_1
    514                  *perr = OS_ERR_PEVENT_NULL;
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   2870               STRB     R0,[R5, #+0]
    515                  return (0);
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   BDE8F081           POP      {R4-R8,PC}
    516              }
    517          #endif
    518              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
   \                     ??OSQPendAbort_1:
   \   00000020   2078               LDRB     R0,[R4, #+0]
   \   00000022   0228               CMP      R0,#+2
   \   00000024   04D0               BEQ.N    ??OSQPendAbort_2
    519                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0120               MOVS     R0,#+1
   \   00000028   2870               STRB     R0,[R5, #+0]
    520                  return (0);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   BDE8F081           POP      {R4-R8,PC}
    521              }
    522              OS_ENTER_CRITICAL();
   \                     ??OSQPendAbort_2:
   \   00000030   ........           BL       OS_CPU_SR_Save
   \   00000034   0646               MOV      R6,R0
    523              if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
   \   00000036   A07A               LDRB     R0,[R4, #+10]
   \   00000038   0028               CMP      R0,#+0
   \   0000003A   20D0               BEQ.N    ??OSQPendAbort_3
    524                  nbr_tasks = 0;
   \   0000003C   0027               MOVS     R7,#+0
    525                  switch (opt) {
   \   0000003E   B8F1010F           CMP      R8,#+1
   \   00000042   0BD1               BNE.N    ??OSQPendAbort_4
    526                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    527                           while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
   \                     ??OSQPendAbort_5:
   \   00000044   A07A               LDRB     R0,[R4, #+10]
   \   00000046   0028               CMP      R0,#+0
   \   00000048   0FD0               BEQ.N    ??OSQPendAbort_6
    528                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
   \   0000004A   0223               MOVS     R3,#+2
   \   0000004C   0422               MOVS     R2,#+4
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   2046               MOV      R0,R4
   \   00000052   ........           BL       OS_EventTaskRdy
    529                               nbr_tasks++;
   \   00000056   7F1C               ADDS     R7,R7,#+1
   \   00000058   FFB2               UXTB     R7,R7
   \   0000005A   F3E7               B.N      ??OSQPendAbort_5
    530                           }
    531                           break;
    532                         
    533                      case OS_PEND_OPT_NONE:
    534                      default:                                       /* No,  ready HPT       waiting on queue    */
    535                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
   \                     ??OSQPendAbort_4:
   \   0000005C   0223               MOVS     R3,#+2
   \   0000005E   0422               MOVS     R2,#+4
   \   00000060   3946               MOV      R1,R7
   \   00000062   2046               MOV      R0,R4
   \   00000064   ........           BL       OS_EventTaskRdy
    536                           nbr_tasks++;
   \   00000068   0127               MOVS     R7,#+1
    537                           break;
    538                  }
    539                  OS_EXIT_CRITICAL();
   \                     ??OSQPendAbort_6:
   \   0000006A   3046               MOV      R0,R6
   \   0000006C   ........           BL       OS_CPU_SR_Restore
    540                  OS_Sched();                                        /* Find HPT ready to run                    */
   \   00000070   ........           BL       OS_Sched
    541                  *perr = OS_ERR_PEND_ABORT;
   \   00000074   0E20               MOVS     R0,#+14
   \   00000076   2870               STRB     R0,[R5, #+0]
    542                  return (nbr_tasks);
   \   00000078   3846               MOV      R0,R7
   \   0000007A   BDE8F081           POP      {R4-R8,PC}
    543              }
    544              OS_EXIT_CRITICAL();
   \                     ??OSQPendAbort_3:
   \   0000007E   3046               MOV      R0,R6
   \   00000080   ........           BL       OS_CPU_SR_Restore
    545              *perr = OS_ERR_NONE;
   \   00000084   0020               MOVS     R0,#+0
   \   00000086   2870               STRB     R0,[R5, #+0]
    546              return (0);                                            /* No tasks waiting on queue                */
   \   00000088   BDE8F081           POP      {R4-R8,PC}       ;; return
    547          }
    548          #endif
    549          
    550          /*$PAGE*/
    551          /*
    552          *********************************************************************************************************
    553          *                                        POST MESSAGE TO A QUEUE
    554          *
    555          * Description: This function sends a message to a queue
    556          *
    557          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    558          *
    559          *              pmsg          is a pointer to the message to send.
    560          *
    561          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    562          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    563          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    564          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    565          *
    566          * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
    567          *********************************************************************************************************
    568          */
    569          
    570          #if OS_Q_POST_EN > 0

   \                                 In section .text, align 2, keep-with-next
    571          INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
    572          {
   \                     OSQPost:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0646               MOV      R6,R0
   \   00000004   0C46               MOV      R4,R1
    573              OS_Q      *pq;
    574          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    575              OS_CPU_SR  cpu_sr = 0;
    576          #endif
    577          
    578          
    579          
    580          #if OS_ARG_CHK_EN > 0
    581              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
   \   00000006   002E               CMP      R6,#+0
   \   00000008   01D1               BNE.N    ??OSQPost_0
    582                  return (OS_ERR_PEVENT_NULL);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   70BD               POP      {R4-R6,PC}
    583              }
    584          #endif
    585              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
   \                     ??OSQPost_0:
   \   0000000E   3078               LDRB     R0,[R6, #+0]
   \   00000010   0228               CMP      R0,#+2
   \   00000012   01D0               BEQ.N    ??OSQPost_1
    586                  return (OS_ERR_EVENT_TYPE);
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   70BD               POP      {R4-R6,PC}
    587              }
    588              OS_ENTER_CRITICAL();
   \                     ??OSQPost_1:
   \   00000018   ........           BL       OS_CPU_SR_Save
   \   0000001C   0546               MOV      R5,R0
    589              if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
   \   0000001E   B07A               LDRB     R0,[R6, #+10]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   0CD0               BEQ.N    ??OSQPost_2
    590                                                                 /* Ready highest priority task waiting on event */
    591                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   00000024   0023               MOVS     R3,#+0
   \   00000026   0422               MOVS     R2,#+4
   \   00000028   2146               MOV      R1,R4
   \   0000002A   3046               MOV      R0,R6
   \   0000002C   ........           BL       OS_EventTaskRdy
    592                  OS_EXIT_CRITICAL();
   \   00000030   2846               MOV      R0,R5
   \   00000032   ........           BL       OS_CPU_SR_Restore
    593                  OS_Sched();                                    /* Find highest priority task ready to run      */
   \   00000036   ........           BL       OS_Sched
    594                  return (OS_ERR_NONE);
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   70BD               POP      {R4-R6,PC}
    595              }
    596              pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
   \                     ??OSQPost_2:
   \   0000003E   7068               LDR      R0,[R6, #+4]
    597              if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
   \   00000040   C18A               LDRH     R1,[R0, #+22]
   \   00000042   828A               LDRH     R2,[R0, #+20]
   \   00000044   9142               CMP      R1,R2
   \   00000046   04D3               BCC.N    ??OSQPost_3
    598                  OS_EXIT_CRITICAL();
   \   00000048   2846               MOV      R0,R5
   \   0000004A   ........           BL       OS_CPU_SR_Restore
    599                  return (OS_ERR_Q_FULL);
   \   0000004E   1E20               MOVS     R0,#+30
   \   00000050   70BD               POP      {R4-R6,PC}
    600              }
    601              *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
   \                     ??OSQPost_3:
   \   00000052   C168               LDR      R1,[R0, #+12]
   \   00000054   0A1D               ADDS     R2,R1,#+4
   \   00000056   C260               STR      R2,[R0, #+12]
   \   00000058   0C60               STR      R4,[R1, #+0]
    602              pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
   \   0000005A   C18A               LDRH     R1,[R0, #+22]
   \   0000005C   491C               ADDS     R1,R1,#+1
   \   0000005E   C182               STRH     R1,[R0, #+22]
    603              if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
   \   00000060   C168               LDR      R1,[R0, #+12]
   \   00000062   8268               LDR      R2,[R0, #+8]
   \   00000064   9142               CMP      R1,R2
   \   00000066   01D1               BNE.N    ??OSQPost_4
    604                  pq->OSQIn = pq->OSQStart;
   \   00000068   4168               LDR      R1,[R0, #+4]
   \   0000006A   C160               STR      R1,[R0, #+12]
    605              }
    606              OS_EXIT_CRITICAL();
   \                     ??OSQPost_4:
   \   0000006C   2846               MOV      R0,R5
   \   0000006E   ........           BL       OS_CPU_SR_Restore
    607              return (OS_ERR_NONE);
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   70BD               POP      {R4-R6,PC}       ;; return
    608          }
    609          #endif
    610          /*$PAGE*/
    611          /*
    612          *********************************************************************************************************
    613          *                                   POST MESSAGE TO THE FRONT OF A QUEUE
    614          *
    615          * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
    616          *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
    617          *              'priority' messages.
    618          *
    619          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    620          *
    621          *              pmsg          is a pointer to the message to send.
    622          *
    623          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    624          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    625          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    626          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    627          *
    628          * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
    629          *********************************************************************************************************
    630          */
    631          
    632          #if OS_Q_POST_FRONT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    633          INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
    634          {
   \                     OSQPostFront:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
    635              OS_Q      *pq;
    636          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    637              OS_CPU_SR  cpu_sr = 0;
    638          #endif
    639          
    640          
    641          
    642          #if OS_ARG_CHK_EN > 0
    643              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
   \   00000006   002D               CMP      R5,#+0
   \   00000008   01D1               BNE.N    ??OSQPostFront_0
    644                  return (OS_ERR_PEVENT_NULL);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   70BD               POP      {R4-R6,PC}
    645              }
    646          #endif
    647              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \                     ??OSQPostFront_0:
   \   0000000E   2878               LDRB     R0,[R5, #+0]
   \   00000010   0228               CMP      R0,#+2
   \   00000012   01D0               BEQ.N    ??OSQPostFront_1
    648                  return (OS_ERR_EVENT_TYPE);
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   70BD               POP      {R4-R6,PC}
    649              }
    650              OS_ENTER_CRITICAL();
   \                     ??OSQPostFront_1:
   \   00000018   ........           BL       OS_CPU_SR_Save
   \   0000001C   0646               MOV      R6,R0
    651              if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
   \   0000001E   A87A               LDRB     R0,[R5, #+10]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   0CD0               BEQ.N    ??OSQPostFront_2
    652                                                                /* Ready highest priority task waiting on event  */
    653                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   00000024   0023               MOVS     R3,#+0
   \   00000026   0422               MOVS     R2,#+4
   \   00000028   2146               MOV      R1,R4
   \   0000002A   2846               MOV      R0,R5
   \   0000002C   ........           BL       OS_EventTaskRdy
    654                  OS_EXIT_CRITICAL();
   \   00000030   3046               MOV      R0,R6
   \   00000032   ........           BL       OS_CPU_SR_Restore
    655                  OS_Sched();                                   /* Find highest priority task ready to run       */
   \   00000036   ........           BL       OS_Sched
    656                  return (OS_ERR_NONE);
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   70BD               POP      {R4-R6,PC}
    657              }
    658              pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
   \                     ??OSQPostFront_2:
   \   0000003E   6868               LDR      R0,[R5, #+4]
    659              if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
   \   00000040   C18A               LDRH     R1,[R0, #+22]
   \   00000042   828A               LDRH     R2,[R0, #+20]
   \   00000044   9142               CMP      R1,R2
   \   00000046   04D3               BCC.N    ??OSQPostFront_3
    660                  OS_EXIT_CRITICAL();
   \   00000048   3046               MOV      R0,R6
   \   0000004A   ........           BL       OS_CPU_SR_Restore
    661                  return (OS_ERR_Q_FULL);
   \   0000004E   1E20               MOVS     R0,#+30
   \   00000050   70BD               POP      {R4-R6,PC}
    662              }
    663              if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
   \                     ??OSQPostFront_3:
   \   00000052   0169               LDR      R1,[R0, #+16]
   \   00000054   4268               LDR      R2,[R0, #+4]
   \   00000056   9142               CMP      R1,R2
   \   00000058   01D1               BNE.N    ??OSQPostFront_4
    664                  pq->OSQOut = pq->OSQEnd;
   \   0000005A   8168               LDR      R1,[R0, #+8]
   \   0000005C   0161               STR      R1,[R0, #+16]
    665              }
    666              pq->OSQOut--;
   \                     ??OSQPostFront_4:
   \   0000005E   0169               LDR      R1,[R0, #+16]
   \   00000060   091F               SUBS     R1,R1,#+4
   \   00000062   0161               STR      R1,[R0, #+16]
    667              *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
   \   00000064   0C60               STR      R4,[R1, #+0]
    668              pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
   \   00000066   C18A               LDRH     R1,[R0, #+22]
   \   00000068   491C               ADDS     R1,R1,#+1
   \   0000006A   C182               STRH     R1,[R0, #+22]
    669              OS_EXIT_CRITICAL();
   \   0000006C   3046               MOV      R0,R6
   \   0000006E   ........           BL       OS_CPU_SR_Restore
    670              return (OS_ERR_NONE);
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   70BD               POP      {R4-R6,PC}       ;; return
    671          }
    672          #endif
    673          /*$PAGE*/
    674          /*
    675          *********************************************************************************************************
    676          *                                        POST MESSAGE TO A QUEUE
    677          *
    678          * Description: This function sends a message to a queue.  This call has been added to reduce code size
    679          *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
    680          *              capability to broadcast a message to ALL tasks waiting on the message queue.
    681          *
    682          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    683          *
    684          *              pmsg          is a pointer to the message to send.
    685          *
    686          *              opt           determines the type of POST performed:
    687          *                            OS_POST_OPT_NONE         POST to a single waiting task
    688          *                                                     (Identical to OSQPost())
    689          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
    690          *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
    691          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    692          *
    693          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    694          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    695          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    696          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    697          *
    698          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    699          *              interrupt disable time is proportional to the number of tasks waiting on the queue.
    700          *********************************************************************************************************
    701          */
    702          
    703          #if OS_Q_POST_OPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    704          INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
    705          {
   \                     OSQPostOpt:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0746               MOV      R7,R0
   \   00000004   0C46               MOV      R4,R1
   \   00000006   1546               MOV      R5,R2
    706              OS_Q      *pq;
    707          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    708              OS_CPU_SR  cpu_sr = 0;
    709          #endif
    710          
    711          
    712          
    713          #if OS_ARG_CHK_EN > 0
    714              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
   \   00000008   002F               CMP      R7,#+0
   \   0000000A   01D1               BNE.N    ??OSQPostOpt_0
    715                  return (OS_ERR_PEVENT_NULL);
   \   0000000C   0420               MOVS     R0,#+4
   \   0000000E   F2BD               POP      {R1,R4-R7,PC}
    716              }
    717          #endif
    718              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \                     ??OSQPostOpt_0:
   \   00000010   3878               LDRB     R0,[R7, #+0]
   \   00000012   0228               CMP      R0,#+2
   \   00000014   01D0               BEQ.N    ??OSQPostOpt_1
    719                  return (OS_ERR_EVENT_TYPE);
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   F2BD               POP      {R1,R4-R7,PC}
    720              }
    721              OS_ENTER_CRITICAL();
   \                     ??OSQPostOpt_1:
   \   0000001A   ........           BL       OS_CPU_SR_Save
   \   0000001E   0646               MOV      R6,R0
    722              if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
   \   00000020   B87A               LDRB     R0,[R7, #+10]
   \   00000022   0028               CMP      R0,#+0
   \   00000024   1CD0               BEQ.N    ??OSQPostOpt_2
    723                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
   \   00000026   15F0010F           TST      R5,#0x1
   \   0000002A   09D0               BEQ.N    ??OSQPostOpt_3
    724                      while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
   \                     ??OSQPostOpt_4:
   \   0000002C   B87A               LDRB     R0,[R7, #+10]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   0CD0               BEQ.N    ??OSQPostOpt_5
    725                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   00000032   0023               MOVS     R3,#+0
   \   00000034   0422               MOVS     R2,#+4
   \   00000036   2146               MOV      R1,R4
   \   00000038   3846               MOV      R0,R7
   \   0000003A   ........           BL       OS_EventTaskRdy
   \   0000003E   F5E7               B.N      ??OSQPostOpt_4
    726                      }
    727                  } else {                                      /* No,  Post to HPT waiting on queue             */
    728                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \                     ??OSQPostOpt_3:
   \   00000040   0023               MOVS     R3,#+0
   \   00000042   0422               MOVS     R2,#+4
   \   00000044   2146               MOV      R1,R4
   \   00000046   3846               MOV      R0,R7
   \   00000048   ........           BL       OS_EventTaskRdy
    729                  }
    730                  OS_EXIT_CRITICAL();
   \                     ??OSQPostOpt_5:
   \   0000004C   3046               MOV      R0,R6
   \   0000004E   ........           BL       OS_CPU_SR_Restore
    731                  if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
   \   00000052   15F0040F           TST      R5,#0x4
   \   00000056   01D1               BNE.N    ??OSQPostOpt_6
    732                      OS_Sched();                               /* Find highest priority task ready to run       */
   \   00000058   ........           BL       OS_Sched
    733                  }
    734                  return (OS_ERR_NONE);
   \                     ??OSQPostOpt_6:
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   F2BD               POP      {R1,R4-R7,PC}
    735              }
    736              pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
   \                     ??OSQPostOpt_2:
   \   00000060   7868               LDR      R0,[R7, #+4]
    737              if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
   \   00000062   C18A               LDRH     R1,[R0, #+22]
   \   00000064   828A               LDRH     R2,[R0, #+20]
   \   00000066   9142               CMP      R1,R2
   \   00000068   04D3               BCC.N    ??OSQPostOpt_7
    738                  OS_EXIT_CRITICAL();
   \   0000006A   3046               MOV      R0,R6
   \   0000006C   ........           BL       OS_CPU_SR_Restore
    739                  return (OS_ERR_Q_FULL);
   \   00000070   1E20               MOVS     R0,#+30
   \   00000072   F2BD               POP      {R1,R4-R7,PC}
    740              }
    741              if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
   \                     ??OSQPostOpt_7:
   \   00000074   15F0020F           TST      R5,#0x2
   \   00000078   0AD0               BEQ.N    ??OSQPostOpt_8
    742                  if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
   \   0000007A   0169               LDR      R1,[R0, #+16]
   \   0000007C   4268               LDR      R2,[R0, #+4]
   \   0000007E   9142               CMP      R1,R2
   \   00000080   01D1               BNE.N    ??OSQPostOpt_9
    743                      pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
   \   00000082   8168               LDR      R1,[R0, #+8]
   \   00000084   0161               STR      R1,[R0, #+16]
    744                  }
    745                  pq->OSQOut--;
   \                     ??OSQPostOpt_9:
   \   00000086   0169               LDR      R1,[R0, #+16]
   \   00000088   091F               SUBS     R1,R1,#+4
   \   0000008A   0161               STR      R1,[R0, #+16]
    746                  *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
   \   0000008C   0C60               STR      R4,[R1, #+0]
   \   0000008E   09E0               B.N      ??OSQPostOpt_10
    747              } else {                                          /* No,  Post as FIFO                             */
    748                  *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
   \                     ??OSQPostOpt_8:
   \   00000090   C168               LDR      R1,[R0, #+12]
   \   00000092   0A1D               ADDS     R2,R1,#+4
   \   00000094   C260               STR      R2,[R0, #+12]
   \   00000096   0C60               STR      R4,[R1, #+0]
    749                  if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
   \   00000098   C168               LDR      R1,[R0, #+12]
   \   0000009A   8268               LDR      R2,[R0, #+8]
   \   0000009C   9142               CMP      R1,R2
   \   0000009E   01D1               BNE.N    ??OSQPostOpt_10
    750                      pq->OSQIn = pq->OSQStart;
   \   000000A0   4168               LDR      R1,[R0, #+4]
   \   000000A2   C160               STR      R1,[R0, #+12]
    751                  }
    752              }
    753              pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
   \                     ??OSQPostOpt_10:
   \   000000A4   C18A               LDRH     R1,[R0, #+22]
   \   000000A6   491C               ADDS     R1,R1,#+1
   \   000000A8   C182               STRH     R1,[R0, #+22]
    754              OS_EXIT_CRITICAL();
   \   000000AA   3046               MOV      R0,R6
   \   000000AC   ........           BL       OS_CPU_SR_Restore
    755              return (OS_ERR_NONE);
   \   000000B0   0020               MOVS     R0,#+0
   \   000000B2   F2BD               POP      {R1,R4-R7,PC}    ;; return
    756          }
    757          #endif
    758          /*$PAGE*/
    759          /*
    760          *********************************************************************************************************
    761          *                                        QUERY A MESSAGE QUEUE
    762          *
    763          * Description: This function obtains information about a message queue.
    764          *
    765          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    766          *
    767          *              p_q_data      is a pointer to a structure that will contain information about the message
    768          *                            queue.
    769          *
    770          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    771          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
    772          *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
    773          *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
    774          *********************************************************************************************************
    775          */
    776          
    777          #if OS_Q_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    778          INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
    779          {
   \                     OSQQuery:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
    780              OS_Q      *pq;
    781              INT8U      i;
    782          #if OS_LOWEST_PRIO <= 63
    783              INT8U     *psrc;
    784              INT8U     *pdest;
    785          #else
    786              INT16U    *psrc;
    787              INT16U    *pdest;
    788          #endif
    789          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    790              OS_CPU_SR  cpu_sr = 0;
    791          #endif
    792          
    793          
    794          
    795          #if OS_ARG_CHK_EN > 0
    796              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
   \   00000006   002D               CMP      R5,#+0
   \   00000008   01D1               BNE.N    ??OSQQuery_0
    797                  return (OS_ERR_PEVENT_NULL);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   70BD               POP      {R4-R6,PC}
    798              }
    799              if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
   \                     ??OSQQuery_0:
   \   0000000E   002C               CMP      R4,#+0
   \   00000010   01D1               BNE.N    ??OSQQuery_1
    800                  return (OS_ERR_PDATA_NULL);
   \   00000012   0920               MOVS     R0,#+9
   \   00000014   70BD               POP      {R4-R6,PC}
    801              }
    802          #endif
    803              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
   \                     ??OSQQuery_1:
   \   00000016   2878               LDRB     R0,[R5, #+0]
   \   00000018   0228               CMP      R0,#+2
   \   0000001A   01D0               BEQ.N    ??OSQQuery_2
    804                  return (OS_ERR_EVENT_TYPE);
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   70BD               POP      {R4-R6,PC}
    805              }
    806              OS_ENTER_CRITICAL();
   \                     ??OSQQuery_2:
   \   00000020   ........           BL       OS_CPU_SR_Save
    807              p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
   \   00000024   A97A               LDRB     R1,[R5, #+10]
   \   00000026   2173               STRB     R1,[R4, #+12]
    808              psrc                 = &pevent->OSEventTbl[0];
   \   00000028   05F10B01           ADD      R1,R5,#+11
    809              pdest                = &p_q_data->OSEventTbl[0];
   \   0000002C   04F10802           ADD      R2,R4,#+8
    810              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
   \   00000030   0023               MOVS     R3,#+0
   \   00000032   05E0               B.N      ??OSQQuery_3
    811                  *pdest++ = *psrc++;
   \                     ??OSQQuery_4:
   \   00000034   11F8016B           LDRB     R6,[R1], #+1
   \   00000038   02F8016B           STRB     R6,[R2], #+1
    812              }
   \   0000003C   5B1C               ADDS     R3,R3,#+1
   \   0000003E   DBB2               UXTB     R3,R3
   \                     ??OSQQuery_3:
   \   00000040   1E46               MOV      R6,R3
   \   00000042   042E               CMP      R6,#+4
   \   00000044   F6D3               BCC.N    ??OSQQuery_4
    813              pq = (OS_Q *)pevent->OSEventPtr;
   \   00000046   6968               LDR      R1,[R5, #+4]
    814              if (pq->OSQEntries > 0) {
   \   00000048   CA8A               LDRH     R2,[R1, #+22]
   \   0000004A   002A               CMP      R2,#+0
   \   0000004C   03D0               BEQ.N    ??OSQQuery_5
    815                  p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
   \   0000004E   0A69               LDR      R2,[R1, #+16]
   \   00000050   1268               LDR      R2,[R2, #+0]
   \   00000052   2260               STR      R2,[R4, #+0]
   \   00000054   00E0               B.N      ??OSQQuery_6
    816              } else {
    817                  p_q_data->OSMsg = (void *)0;
   \                     ??OSQQuery_5:
   \   00000056   2260               STR      R2,[R4, #+0]
    818              }
    819              p_q_data->OSNMsgs = pq->OSQEntries;
   \                     ??OSQQuery_6:
   \   00000058   CA8A               LDRH     R2,[R1, #+22]
   \   0000005A   A280               STRH     R2,[R4, #+4]
    820              p_q_data->OSQSize = pq->OSQSize;
   \   0000005C   898A               LDRH     R1,[R1, #+20]
   \   0000005E   E180               STRH     R1,[R4, #+6]
    821              OS_EXIT_CRITICAL();
   \   00000060   ........           BL       OS_CPU_SR_Restore
    822              return (OS_ERR_NONE);
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   70BD               POP      {R4-R6,PC}       ;; return
    823          }
    824          #endif                                                 /* OS_Q_QUERY_EN                                */
    825          
    826          /*$PAGE*/
    827          /*
    828          *********************************************************************************************************
    829          *                                      QUEUE MODULE INITIALIZATION
    830          *
    831          * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
    832          *               application MUST NOT call this function.
    833          *
    834          * Arguments   :  none
    835          *
    836          * Returns     : none
    837          *
    838          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    839          *********************************************************************************************************
    840          */
    841          

   \                                 In section .text, align 4, keep-with-next
    842          void  OS_QInit (void)
    843          {
   \                     OS_QInit:
   \   00000000   10B5               PUSH     {R4,LR}
    844          #if OS_MAX_QS == 1
    845              OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
    846              OSQFreeList->OSQPtr = (OS_Q *)0;
    847          #endif
    848          
    849          #if OS_MAX_QS >= 2
    850              INT16U  i;
    851              OS_Q   *pq1;
    852              OS_Q   *pq2;
    853          
    854          
    855          
    856              OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
   \   00000002   0B4C               LDR.N    R4,??OS_QInit_0  ;; OSQTbl
   \   00000004   6021               MOVS     R1,#+96
   \   00000006   2046               MOV      R0,R4
   \   00000008   ........           BL       OS_MemClr
    857              pq1 = &OSQTbl[0];
   \   0000000C   2046               MOV      R0,R4
    858              pq2 = &OSQTbl[1];
   \   0000000E   04F11801           ADD      R1,R4,#+24
    859              for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
   \   00000012   0022               MOVS     R2,#+0
   \   00000014   04E0               B.N      ??OS_QInit_1
    860                  pq1->OSQPtr = pq2;
   \                     ??OS_QInit_2:
   \   00000016   40F8181B           STR      R1,[R0], #+24
    861                  pq1++;
    862                  pq2++;
   \   0000001A   1831               ADDS     R1,R1,#+24
    863              }
   \   0000001C   521C               ADDS     R2,R2,#+1
   \   0000001E   92B2               UXTH     R2,R2
   \                     ??OS_QInit_1:
   \   00000020   1346               MOV      R3,R2
   \   00000022   032B               CMP      R3,#+3
   \   00000024   F7D3               BCC.N    ??OS_QInit_2
    864              pq1->OSQPtr = (OS_Q *)0;
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   0160               STR      R1,[R0, #+0]
    865              OSQFreeList = &OSQTbl[0];
   \   0000002A   ....               LDR.N    R0,??DataTable9  ;; OSQFreeList
   \   0000002C   0460               STR      R4,[R0, #+0]
    866          #endif
    867          }
   \   0000002E   10BD               POP      {R4,PC}          ;; return
   \                     ??OS_QInit_0:
   \   00000030   ........           DC32     OSQTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     OSQFreeList
    868          #endif                                               /* OS_Q_EN                                        */

   Maximum stack usage in bytes:

     Function     .cstack
     --------     -------
     OSQAccept        16
     OSQCreate        24
     OSQDel           24
     OSQFlush          8
     OSQPend          24
     OSQPendAbort     24
     OSQPost          16
     OSQPostFront     16
     OSQPostOpt       24
     OSQQuery         16
     OS_QInit          8


   Section sizes:

     Function/Label Bytes
     -------------- -----
     OSQAccept        96
     OSQCreate       148
     OSQDel          252
     OSQFlush         46
     OSQPend         304
     OSQPendAbort    140
     OSQPost         118
     OSQPostFront    118
     OSQPostOpt      180
     OSQQuery        104
     OS_QInit         52
     ??DataTable7      4
     ??DataTable8      4
     ??DataTable9      4

 
 1 570 bytes in section .text
 
 1 570 bytes of CODE memory

Errors: none
Warnings: none
